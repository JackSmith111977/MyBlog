---
title: JavaScript 笔记
date: 2025-11-23 21:45:00
tags: 
    - 前端
    - JavaScript
cover: https://kei-blog.oss-cn-beijing.aliyuncs.com/asset/115945063_p0-cut.jpg
categories: 
    - 编程语言
---

# JavaScript 笔记
本文是基于[MDN Web Docs](https://mdn.org.cn), 同时结合本人的学习整理而成的笔记

## 目录
- [JavaScript 笔记](#javascript-笔记)
  - [目录](#目录)
  - [语法与类型](#语法与类型)
    - [声明](#声明)
    - [声明与初始化](#声明与初始化)
    - [变量作用域](#变量作用域)
      - [全局变量和局部变量](#全局变量和局部变量)
    - [变量提升](#变量提升)

## 语法与类型
[回到目录](#目录)

### 声明
[回到上一级](#语法与类型)

* var: 声明一个变量，并可选择将其初始化为一个值。
* let: 声明一个**块作用域**的局部变量，并可选择将其初始化为一个值。
* const: 声明一个**块作用域**的**只读**命名常量
* 使用关键字 var。例如，var x = 42。此语法可用于声明**局部变量**和**全局变量**，具体取决于执行上下文
* 使用关键字 const 或 let。例如，let y = 13。此语法可用于声明块作用域的**局部变量**

### 声明与初始化
[回到上一级](#语法与类型)
* 在像 let x = 42 这样的语句中，let x 部分称为**声明**，= 42 部分称为**初始化器**
* 在 var 和 let 声明中，初始化器是可选的。如果变量未带初始化器声明，则它被赋值为 **undefined**
* const 声明**总是**需要一个初始化器，因为它们禁止在声明后进行任何类型的赋值，并且隐式地用 undefined 初始化很可能是程序员的错误

### 变量作用域
[回到上一级](#语法与类型)
* 全局作用域：脚本模式下所有代码的默认作用域。
* 模块作用域：模块模式下代码的作用域。
* 函数作用域：通过函数创建的作用域

此外，用 let 或 const 声明的变量可以属于一个额外的作用域

* 块作用域：由一对花括号（一个块）创建的作用域

#### 全局变量和局部变量
[回到上一级](#变量作用域)
* 当您在任何**函数之外**声明变量时，它被称为**全局变量**，因为它可用于当前文档中的任何其他代码
* 当您在**函数内部**声明变量时，它被称为**局部变量**，因为它仅在该函数内部可用
* let 和 const 声明也可以作用域到它们声明的**块语句**
~~~javascript
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
~~~
* 然而，用 var 创建的变量不是块作用域的，而只是块所在函数（或全局作用域）的**局部变量**
~~~javascript
if (true) {
  var x = 5;
}
console.log(x); // x is 5
~~~

### 变量提升
[回到上一级](#语法与类型)

* 用 var 声明的变量会被提升，这意味着您可以在其作用域中的**任何位置**引用该变量，即使其声明尚未到达
* 您可以将 var 声明视为被“提升”到其函数或全局作用域的**顶部**
* 但是，如果您在变量声明之前访问它，其值始终为 undefined，因为**只有其声明和默认初始化**（使用 undefined）会被提升，**而不是其值赋值**

~~~javascript
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
~~~

~~~javascript
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
~~~
* 两种写法等价, 前者会被解释为后者
* 由于提升，函数中的所有 var 语句都应**尽可能地放置在函数的顶部**。这种最佳实践提高了代码的清晰度
* let 和 const 是否提升是定义上的争论。在变量声明之前在块中引用变量总是会导致 ReferenceError，因为该变量从块开始直到声明被处理为止都处于“暂时死区”中




















