---
title: "位运算"
date: 2025-10-11 20:46:00
tags: 
    - 算法
    - 位运算
categories:
    - 算法笔记
---

# 位运算

## 目录
- [位运算](#位运算)
  - [目录](#目录)
  - [仅含置位位的最小整数](#仅含置位位的最小整数)
    - [题目描述](#题目描述)
    - [解题思路](#解题思路)
    - [代码实现](#代码实现)
    - [复杂度分析](#复杂度分析)
  - [使两个整数相等的位更改次数](#使两个整数相等的位更改次数)
    - [题目描述](#题目描述-1)
    - [解题思路](#解题思路-1)
    - [代码实现](#代码实现-1)
    - [复杂度分析](#复杂度分析-1)


## 仅含置位位的最小整数

### 题目描述
给你一个正整数 n。

返回 大于等于 n 且二进制表示仅包含 置位 位的 最小 整数 x 。

置位 位指的是二进制表示中值为 1 的位。

 

示例 1：

输入： n = 5

输出： 7

解释：

7 的二进制表示是 "111"。

示例 2：

输入： n = 10

输出： 15

解释：

15 的二进制表示是 "1111"。

示例 3：

输入： n = 3

输出： 3

解释：

3 的二进制表示是 "11"。

 

提示：

1 <= n <= 1000

### 解题思路
1. 朴素思路，从1开始遍历，直到第一个大于n的仅含置位位的整数，即遍历2的i次方减去1
2. 进阶思路，直接计算n的二进制位数m，2的m次方减1，即为所求

### 代码实现
~~~python
# 朴素思路
class Solution:
    def smallestNumber(self, n: int) -> int:
        i = 1
        while(True):
            # num >> i 即num除以2的i次方
            x = (1 << i) - 1 # 左移位，即2的i次方
            if x >= n:
                return x
            i += 1

# 进阶思路
class Solution:
    def smallestNumber(self, n: int) -> int:
        return (1 << n.bit_length()) - 1
~~~

### 复杂度分析
1. 朴素思路需要遍历 log(n)次，时间复杂度为 O(log(n))
2. 进阶思路只需要计算n的二进制位数，时间复杂度为 O(1)


## 使两个整数相等的位更改次数

### 题目描述
给你两个正整数 n 和 k。

你可以选择 n 的 二进制表示 中任意一个值为 1 的位，并将其改为 0。

返回使得 n 等于 k 所需要的更改次数。如果无法实现，返回 -1。

 

示例 1：

输入： n = 13, k = 4

输出： 2

解释：
最初，n 和 k 的二进制表示分别为 n = (1101)2 和 k = (0100)2，

我们可以改变 n 的第一位和第四位。结果整数为 n = (0100)2 = k。

示例 2：

输入： n = 21, k = 21

输出： 0

解释：
n 和 k 已经相等，因此不需要更改。

示例 3：

输入： n = 14, k = 13

输出： -1

解释：
无法使 n 等于 k。

 

提示：

1 <= n, k <= 106

### 解题思路
1. n只能改1为0，使用位运算思路
2. 比如n = 14(1110)，k = 13(1101)，化为集合形式，n = {3,2,1}，k = {3,2,0}，k不是n的子集，则无法实现
3. 比如n = 13(1101)，k = 4(0100)，化为集合形式，n = {3,2,0}，k = {2}，k是n的子集，n可以化为k
4. 判断子集关系可以用以下方法
    1. n & k == k
    2. n | k == n
5. 最后计算需要修改的位数，即异或运算的值

### 代码实现
~~~python
class Solution:
    def minChanges(self, n: int, k: int) -> int:
        # if n & k != k: # 只有k在n的子集中，才能使n改为k，即与运算等于k，或者或运算等于n
        if n | k != n: 
            return -1
        else:
            return (n ^ k).bit_count() # 需要更改的数字为异或值
~~~

### 复杂度分析
时间复杂度为 O(1)



