{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/copy-codeblock.js","path":"js/copy-codeblock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/lax.min.js","path":"lib/lax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/preset/plain.styl","path":"preset/plain.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.css","path":"lib/fancybox/fancybox.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.umd.js","path":"lib/fancybox/fancybox.umd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","path":"lib/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","path":"lib/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.css","path":"lib/mdui_043tiny/mdui.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.js","path":"lib/mdui_043tiny/mdui.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","path":"css/color.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","path":"css/content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","path":"css/kira-code-copy.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","path":"css/kira-friends.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","path":"css/kira-image.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","path":"css/right-column.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","path":"css/constants.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","path":"css/sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","path":"js/kira-image.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","path":"lib/lazysizes.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","path":"lib/smooth-scrolling.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","path":"js/kira-code-copy.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","path":"deps/css/APlayer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","path":"deps/js/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","path":"deps/js/Meting.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","path":"lib/highlight/highlight.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","path":"lib/mdui/mdui.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","path":"lib/highlight/atom-one-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","path":"lib/mdui/mdui.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","path":"lib/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","path":"lib/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","path":"lib/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"source/pic/101573594_p0.png","path":"pic/101573594_p0.png","modified":0,"renderable":0},{"_id":"source/pic/125981673_p0.png","path":"pic/125981673_p0.png","modified":0,"renderable":0},{"_id":"source/pic/125349440_p0.png","path":"pic/125349440_p0.png","modified":0,"renderable":0},{"_id":"source/assert/eg1.png","path":"assert/eg1.png","modified":0,"renderable":0},{"_id":"source/assert/微信图片_20250914151010_28_9.png","path":"assert/微信图片_20250914151010_28_9.png","modified":0,"renderable":0},{"_id":"source/assert/machine_learining/1.png","path":"assert/machine_learining/1.png","modified":0,"renderable":0},{"_id":"source/assert/machine_learining/2.png","path":"assert/machine_learining/2.png","modified":0,"renderable":0},{"_id":"source/assert/machine_learining/3.png","path":"assert/machine_learining/3.png","modified":0,"renderable":0},{"_id":"source/assert/machine_learining/4.png","path":"assert/machine_learining/4.png","modified":0,"renderable":0},{"_id":"source/assert/rainwatertrap2.png","path":"assert/rainwatertrap2.png","modified":1,"renderable":0},{"_id":"source/assert/algorithm/rainwatertrap.png","path":"assert/algorithm/rainwatertrap.png","modified":1,"renderable":0},{"_id":"source/assert/algorithm/rainwatertrap2.png","path":"assert/algorithm/rainwatertrap2.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1756308328891},{"_id":"source/_posts/test.md","hash":"cec3046d08cb8e4808b35eb206c34588e86fc916","modified":1756309250494},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1756308969812},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1756308962456},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1756308970880},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1756308970950},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1756308969715},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1756308970978},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1756308971043},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1756308971122},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1756308971238},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1756308971180},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1756308971266},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1756308971079},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1756308971336},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1756308971386},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1756308971595},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1756308971558},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1756308971633},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1756308971666},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1756308971690},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1756308971738},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1756308971924},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1756308971830},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1756308972022},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1756308972068},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1756308971960},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1756308971880},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1756308972114},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1756308972205},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1756308972164},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1756308972256},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1756308971996},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1756308972337},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1756308972289},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1756308972362},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1756308972420},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1756308965410},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1756308966294},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1756308967480},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1756308972401},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1756308967556},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1756308967858},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1756308967920},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1756308968352},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1756308968999},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1756308963784},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1756308965623},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1756308964163},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1756308966739},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1756308964516},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1756308967141},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1756308967270},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1756308967032},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1756308967385},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1756308968030},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1756308966068},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1756308967976},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1756308968423},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1756308969894},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1756308968227},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1756308964980},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1756308969958},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1756308970798},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1756308969666},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1756308963120},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1756308967634},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1756308965892},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1756308966422},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1756308967727},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1756308966862},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1756308968484},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1756308970534},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1756308970052},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1756308970136},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1756308970391},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1756308970228},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1756308968153},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1756308970284},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1756308970478},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1756308970438},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1756308970692},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1756308970583},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1756308970630},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1756308970752},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1756308969360},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1756308969527},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1756308968888},{"_id":"public/2025/08/27/hello-world/index.html","hash":"1ba974760832be63bd119a7727d87000c9183b90","modified":1756309251568},{"_id":"public/archives/index.html","hash":"5715cf1f73b16b3b3b3932a8f1769cfc3ce9ff7a","modified":1756309251568},{"_id":"public/archives/2025/index.html","hash":"9b738a5deb69b9eb42a3f80abe71dd39d78fd186","modified":1756309251568},{"_id":"public/2025/08/27/test/index.html","hash":"95d69ee85b4e11a386218ed4fe5753879839f23d","modified":1756309251568},{"_id":"public/index.html","hash":"c0bc266c6460bcbe7ca04b31c423037dea5558f8","modified":1756309251568},{"_id":"public/archives/2025/08/index.html","hash":"86a631291b8b557206f85a610582912f60abd216","modified":1756309251568},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1756309251568},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1756309251568},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1756309251568},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1756309251568},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1756309251568},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1756309251568},{"_id":"node_modules/hexo-theme-nexmoe/.eslintignore","hash":"1d606028dff10b1a8c635142235182379dc3c64e","modified":1756384386168},{"_id":"node_modules/hexo-theme-nexmoe/.eslintrc.json","hash":"ca45d8e5d80ad6b7004cddacae7fc7d8040b2d6f","modified":1756384397643},{"_id":"node_modules/hexo-theme-nexmoe/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1756384386502},{"_id":"node_modules/hexo-theme-nexmoe/index.js","hash":"f3d92ae5f32a9aee66f8b24083a2004d69a2b761","modified":1756384396414},{"_id":"node_modules/hexo-theme-nexmoe/README.md","hash":"7e77fc64595bc4afe6a56ebe0fe525a874b4f017","modified":1756384400525},{"_id":"node_modules/hexo-theme-nexmoe/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1756384398294},{"_id":"node_modules/hexo-theme-nexmoe/package.json","hash":"5f5c79d7fdaa58fa87142085f1f010762afdd643","modified":1756384398211},{"_id":"node_modules/hexo-theme-nexmoe/.github/release-drafter.yml","hash":"9be21d7a486404050224d61415226e1ba321f169","modified":1756384403520},{"_id":"node_modules/hexo-theme-nexmoe/demo/package.json","hash":"883603a5be41686e89c26519e5bfe097343edcc6","modified":1756384398134},{"_id":"node_modules/hexo-theme-nexmoe/crowdin.yml","hash":"f9f02a9cab975c7de721c5dc4179b77870019cc6","modified":1756384402740},{"_id":"node_modules/hexo-theme-nexmoe/include/README.md","hash":"912c1a78db7138e3ff6e1ce622dd00e3bfb1afab","modified":1756384400466},{"_id":"node_modules/hexo-theme-nexmoe/demo/_config.yml","hash":"f5a551599d83995e0dbc4719e7950fa889b3dc64","modified":1756384402643},{"_id":"node_modules/hexo-theme-nexmoe/demo/_config.nexmoe.yml","hash":"8f508665b4512954103e04e1e86f9ebfe30e7748","modified":1756384402544},{"_id":"node_modules/hexo-theme-nexmoe/include/dependency.js","hash":"ed975738b982c19565bc2869a51277723fd23e6b","modified":1756384395412},{"_id":"node_modules/hexo-theme-nexmoe/languages/en.yml","hash":"1a2ab324edb076988fa7a098d2b011d80738a047","modified":1756384403026},{"_id":"node_modules/hexo-theme-nexmoe/include/config.js","hash":"f26ff9408ca6ce956ef40ac6c6996da36c9df67d","modified":1756384394844},{"_id":"node_modules/hexo-theme-nexmoe/languages/default.yml","hash":"c76f93c3c0ac4582694e330647f2fe424930ec3a","modified":1756384402864},{"_id":"node_modules/hexo-theme-nexmoe/languages/it.yml","hash":"334afb6a7967d71ebd2fb32bdd1f8b20174c82bd","modified":1756384403229},{"_id":"node_modules/hexo-theme-nexmoe/languages/ja.yml","hash":"773c3b0464771c6d5149a2175bb9d7eaceb755ea","modified":1756384403278},{"_id":"node_modules/hexo-theme-nexmoe/include/register.js","hash":"446119e7fbc44da8d0fc8c3628c14fadb225c558","modified":1756384397487},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-CN.yml","hash":"b30de168c5bc226cdb9dbd7358b7b0d33a34e1d5","modified":1756384403685},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh.yml","hash":"81aa48d1ada886cb10f5a195c3afb250f962f3ac","modified":1756384403986},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-HK.yml","hash":"6b6ada7b425c137cd51edc2f4890b96a21482558","modified":1756384403824},{"_id":"node_modules/hexo-theme-nexmoe/layout/archives.ejs","hash":"2395fdfee67880c1c6b4796882c6fda67930f1f7","modified":1756384390773},{"_id":"node_modules/hexo-theme-nexmoe/layout/index.jsx","hash":"20373ddf76f6d59dde51833e754c9f70cc804f77","modified":1756384399169},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-TW.yml","hash":"e4ababddda52aa89f0fd51909c2211bcd10abb53","modified":1756384403943},{"_id":"node_modules/hexo-theme-nexmoe/layout/layout.jsx","hash":"e347c8e933b3e496add81502c1a2e229b0042f73","modified":1756384399267},{"_id":"node_modules/hexo-theme-nexmoe/layout/post.ejs","hash":"a22ebd3ceec83722a0c2b1a5bc11688818ae25a7","modified":1756384392766},{"_id":"node_modules/hexo-theme-nexmoe/source/_config.yml","hash":"c09a5a5a10889ef15cbfad988474527ccad19546","modified":1756384402689},{"_id":"node_modules/hexo-theme-nexmoe/layout/py.jsx","hash":"590216a1f66a2085d98544fe082c503ec3baa02e","modified":1756384399448},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_en.md","hash":"557484415c610222b16b58df470c2a768782c4fc","modified":1756384399855},{"_id":"node_modules/hexo-theme-nexmoe/scripts/index.js","hash":"c00aba78d38330728dbbdbb0bae57f1b00a7de5e","modified":1756384396549},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"d6c77dbb2a3d638d748280fb37dd29375aebe98c","modified":1756384399894},{"_id":"node_modules/hexo-theme-nexmoe/.github/workflows/npm-publish.yml","hash":"b57ce794238f61bb8223752e516970cd1b7732c9","modified":1756384403433},{"_id":"node_modules/hexo-theme-nexmoe/.github/workflows/release-drafter.yml","hash":"ccbe1e1ae6ee3b2a7d32362791aa006afa95e94d","modified":1756384403614},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"843abf5e1d7b06cb1feddd75f7025150d46a91c2","modified":1756384400184},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_en.md","hash":"803f6736473a122ed78867e64681defcd2edd954","modified":1756384400111},{"_id":"node_modules/hexo-theme-nexmoe/demo/.github/dependabot.yml","hash":"25b0257a0db2c5b6a5756d8990bc2cba12f54fc5","modified":1756384402955},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/draft.md","hash":"204ab550ddffa92051ea0eb2484a78d84dac3693","modified":1756384400043},{"_id":"node_modules/hexo-theme-nexmoe/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1756384394949},{"_id":"node_modules/hexo-theme-nexmoe/layout/_index/list.ejs","hash":"e98a95f50d6f9042302ec4fad62ac85c5336ba26","modified":1756384392467},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/page.md","hash":"f0af1cb10f27d859caa51c8e3704469d9ed842a6","modified":1756384400339},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/post.md","hash":"e7169dab8ce62d41e3734e30706fa786cc7d46f4","modified":1756384400421},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/archive.ejs","hash":"2c8c5ee017bfdd56cbb80c7796ef9393aea16d52","modified":1756384390432},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/category.ejs","hash":"99113b9f2cb4ffefdda3e3a343647ac6a5083091","modified":1756384391082},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/search.ejs","hash":"9771d5e03623a8892c23dab9b24360edbaf87233","modified":1756384393153},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/recent_posts.ejs","hash":"7d9eaf8228eda803aa4956e55432f78e056d6a01","modified":1756384392867},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/social.ejs","hash":"133927c64cbe6f9cf6601e32be0b03ed576dfbf5","modified":1756384393304},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/hitokoto.ejs","hash":"2c9c3567d2b5a99cdbca90673c638409529881db","modified":1756384392105},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tag.ejs","hash":"ddf844f08124454bea2a30f8349b63f3cb63ac16","modified":1756384393543},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tagcloud.ejs","hash":"25e1af5116bd5cbf6c1d1e259a8564e21a3a28d5","modified":1756384393676},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/head.ejs","hash":"c14cec07f778dbf643e51671e47c2e6e711045b8","modified":1756384391741},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/background.jsx","hash":"05ee70bc00ddac592469a9e56cfdb9f683f130ef","modified":1756384398423},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/paginator.jsx","hash":"9b1f26c6f899b1c66c65d7213137f02796b56236","modified":1756384399302},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/right.ejs","hash":"e4db789fcf7f7dfe58e22c78ae30a5db2355cc47","modified":1756384393023},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/link.ejs","hash":"61bc7a6018309f5b3525b451ccdd62e6664f7e74","modified":1756384392269},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/image_filter.js","hash":"284c3f15eaba3ff6db42fe12f921fada5c6f24b4","modified":1756384396344},{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","hash":"2021dacedfe0f6f2ed6fdf6a9e9c067fe792cde0","modified":1756384402058},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/css_auto_version.js","hash":"354700a113aca785c82bd59a16901a2dff2a2580","modified":1756384395233},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/searchbox.jsx","hash":"83714b79399e0bef913bef8c4dbef58e9dd875f2","modified":1756384399699},{"_id":"node_modules/hexo-theme-nexmoe/source/js/copy-codeblock.js","hash":"51f1b526133258db1080826574c50a683a34c559","modified":1756384395069},{"_id":"node_modules/hexo-theme-nexmoe/scripts/tag/links.js","hash":"3676a23bdf32e0c1a933ccb8a79da6c5880a2e19","modified":1756384396908},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/js_auto_version.js","hash":"96e6d7d0dadd39198e33ec8d5f0331e4a600ca37","modified":1756384396623},{"_id":"node_modules/hexo-theme-nexmoe/scripts/tag/gallery.js","hash":"bc07b003bd405138ff4bca5fb03ba180fc29b92e","modified":1756384396154},{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","hash":"965c3befaa26a06484204b34f20b8770e186866a","modified":1756384394650},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","hash":"eb69cd78f6ab8d3e83576dae29f09c9af0ffe8b9","modified":1756384397567},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/footer.jsx","hash":"3ede4910be7915854ee06a545aa8ee04bd216031","modified":1756384399012},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/header.jsx","hash":"3ede4910be7915854ee06a545aa8ee04bd216031","modified":1756384399121},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/body.jsx","hash":"7e63a37bcd01a67950fb4f52895bf9e6cf9f955b","modified":1756384398500},{"_id":"node_modules/hexo-theme-nexmoe/source/preset/plain.styl","hash":"0413a4e36642110f0a23738d10f2874e6e43ed6d","modified":1756384401847},{"_id":"node_modules/hexo-theme-nexmoe/demo/source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1756384400312},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/lax.min.js","hash":"1de100aa90834f1f4fae9a4deb44a73048fefff0","modified":1756384396869},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/content.jsx","hash":"13a868d0b70283aaaa49770ad530261eda7a750d","modified":1756384398764},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/header.ejs","hash":"24ebcbd15daee1b6b1ede4ffaffa9b86f7154167","modified":1756384391969},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/tag.ejs","hash":"5934bcb1b256642708c97f61da85fbdbd959a078","modified":1756384393395},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/content.jsx","hash":"4bfadb1ce4e732289f43f81cfce41fb35a3f2f89","modified":1756384398616},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/footer.jsx","hash":"167f67e30cdb15576c9cd9dd7cc6aafb4625e069","modified":1756384398878},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/meta.ejs","hash":"be2fdf6732f49d5d3277b4e4b0a4f9fc85fa4643","modified":1756384392657},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/word-count.ejs","hash":"5415f792394b364fcbc1502971874dac6ea54de4","modified":1756384393815},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_widget/hitokoto.styl","hash":"0086bb5a3f250439be64588fca075ee3326a6ad1","modified":1756384401400},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/archives.styl","hash":"3f401f6caf7e7ed6c0b7fe622ed02a25cc9e5237","modified":1756384400632},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/copyright.ejs","hash":"bf2cb43d66842b4bc51eb6908c588044a68d1364","modified":1756384391433},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_widget/index.styl","hash":"465acffbe8cc98c3b275cc286c0991f422930b60","modified":1756384401471},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/body.jsx","hash":"1d8210e9968298440a1da0cc86c3e3454dba4427","modified":1756384398593},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/pagination.styl","hash":"aa22dd62542d69f07ce5178cd3f94cf20c9f1bca","modified":1756384401720},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/background.styl","hash":"a4c012e17734de0bf1a62bf5b5ebc98755b23bcb","modified":1756384400804},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/copy-codeblock.styl","hash":"83372948cb098a8ad1da8bde17963701b8e39409","modified":1756384401100},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_index/list.styl","hash":"6ce0e88126225e582c4d788c4c88a30c11fee8fb","modified":1756384401653},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.css","hash":"cbce0cfc36f47e30e9c9824875f0b854a05f1916","modified":1756384388222},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/py.styl","hash":"53c72cb99593d83523559013713fc25b4ae5957c","modified":1756384401902},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/searchbox.styl","hash":"b25cefb269bb7188ed9d6ab0b530f30e138b33d1","modified":1756384401940},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1756384387325},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","hash":"a82acbfeabc50a6668ebf6115b5c5c3d308079b6","modified":1756384394279},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/article.styl","hash":"726d9837026a4979dae3d9d790feba952de98b48","modified":1756384400755},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","hash":"1d1851c2197382a9b7cd3b3fcdef79a61ad331f6","modified":1756384394074},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","hash":"3566d949bdc045cd816be382d180b796e0a78748","modified":1756384388634},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","hash":"0dd0193f6f400e5da6d3aef89f76c22c79e0f396","modified":1756384397710},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","hash":"e292802913e6c248a17797dc24ecfc0a3473c3cf","modified":1756384402347},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","hash":"2af6d26577c3ae2ca126351f0be764cbae9da6ff","modified":1756384402165},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","hash":"a536d4780220f9cd7fc5126d9ec1108b19afb6b9","modified":1756384396267},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","hash":"b0f4b5501cbcaeaf15dc608359574a29bc4c4265","modified":1756384402312},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/nexmoe/content.styl","hash":"718c99320e6862a020e2652d8259c980283a6ac0","modified":1756384400900},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/nexmoe/header.styl","hash":"b1c905f3a6089936aa6740546c266c03a99a8169","modified":1756384401242},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","hash":"9209e4f7e45d37e58356e5ede7ea9d6d9e922d77","modified":1756384402442},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/footer.styl","hash":"bebef911fb8030bbfed418492e6c1c0eae2306a7","modified":1756384401135},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/header.styl","hash":"fb047e449d0a3f37f8beffc31af0ed9ffa2da9d3","modified":1756384401287},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/content.styl","hash":"0e382da59dfe8bb1451b115e1c32f40ed126174f","modified":1756384401015},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.umd.js","hash":"f2126b3e96721606a2ba20e0f148404814262171","modified":1756384395782},{"_id":"node_modules/hexo-theme-nexmoe/demo/package-lock.json","hash":"37e07fd906a664c3706e684e8efcb4d86f31e3e9","modified":1756384398058},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.css","hash":"1500b5d27b8ce2e7c543bb6d7205de43059378db","modified":1756384390040},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.js","hash":"5c0bced25b23773e764338ae4581f366f984cb6c","modified":1756384397391},{"_id":"node_modules/hexo-theme-kira/package.json","hash":"7366cfb765732b16fa06f243a6cce21b6aeb1749","modified":1756385948491},{"_id":"node_modules/hexo-theme-kira/languages/it.yml","hash":"708e1a520eebd468b9895fe5f80c79c1cdca0fc8","modified":1756385950335},{"_id":"node_modules/hexo-theme-kira/languages/default.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1756385950264},{"_id":"node_modules/hexo-theme-kira/languages/en.yml","hash":"d3e7f13edbe8c6fcf1c18f679c8fa9f919941d5b","modified":1756385950299},{"_id":"node_modules/hexo-theme-kira/languages/ja.yml","hash":"2f848f022dd6eb70893dbf0d1f68440d487b285e","modified":1756385950366},{"_id":"node_modules/hexo-theme-kira/languages/zh-CN.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1756385950401},{"_id":"node_modules/hexo-theme-kira/languages/zh-HK.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1756385950453},{"_id":"node_modules/hexo-theme-kira/languages/zh-TW.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1756385950629},{"_id":"node_modules/hexo-theme-kira/layout/friends.ejs","hash":"0702afdbfa01a4266a29f3e018928a3a4aedd16a","modified":1756385944886},{"_id":"node_modules/hexo-theme-kira/readme.md","hash":"a32af4ed2ed53d223ad5456a5e0a45b46972306a","modified":1756385948594},{"_id":"node_modules/hexo-theme-kira/layout/index.ejs","hash":"d7dd4eba4d8b4306f78e59b7f7b7142e5e9755f2","modified":1756385945498},{"_id":"node_modules/hexo-theme-kira/layout/archives.ejs","hash":"bc09ed31aea541e207edfa0dc1482f74ed6d8361","modified":1756385944352},{"_id":"node_modules/hexo-theme-kira/layout/_widget/archive.ejs","hash":"1b7927c453a4ba3bc91f57585d1c9a028f3a2634","modified":1756385944064},{"_id":"node_modules/hexo-theme-kira/layout/layout.ejs","hash":"155fc956d1d3f70b97b7415503328af5b6d8ffc9","modified":1758373361456},{"_id":"node_modules/hexo-theme-kira/layout/_widget/social.ejs","hash":"78ee34ba7813bc3cb9ac0155a251a7db5fc20668","modified":1756385946053},{"_id":"node_modules/hexo-theme-kira/layout/post.ejs","hash":"4ec75cf603d272ed094ea79c615cda56b861bdcb","modified":1756385945823},{"_id":"node_modules/hexo-theme-kira/layout/components/right-column.ejs","hash":"6db93a9722a5288f96ab16dd54783e187909657f","modified":1756385945876},{"_id":"node_modules/hexo-theme-kira/layout/components/friends.ejs","hash":"1833dafebc1997996b8c77d55683b1d97de2a71b","modified":1756385944762},{"_id":"node_modules/hexo-theme-kira/layout/components/copyright.ejs","hash":"7a6bf6be3cd1605c7974a33baf8b54a90a50b141","modified":1756385944666},{"_id":"node_modules/hexo-theme-kira/scripts/tag/biliplayer.js","hash":"573c7bd45e38c96c5cad922e23d19e1abd70fb7b","modified":1756385946755},{"_id":"node_modules/hexo-theme-kira/layout/components/header.ejs","hash":"c1e28f64f4ea8cbccb77bcb7ebd78a7bbecf2f94","modified":1756385945317},{"_id":"node_modules/hexo-theme-kira/layout/components/kira-image.ejs","hash":"3222ae7c8d79afc3cd5ed0f1e8ef1b51b3fdda36","modified":1756385945602},{"_id":"node_modules/hexo-theme-kira/scripts/tag/kira-player.js","hash":"cfbae6ff10abc986ea05044c536b6870f3c2a0f5","modified":1756385947762},{"_id":"node_modules/hexo-theme-kira/layout/_widget/category.ejs","hash":"249ecb1c70bcbb5dd792deb7ca597ece06497cac","modified":1756385944517},{"_id":"node_modules/hexo-theme-kira/scripts/tag/meting.js","hash":"9d9474ea97a789b3c1d7b1153c30475eca0967d9","modified":1756385948173},{"_id":"node_modules/hexo-theme-kira/scripts/utils/image_auto_lazyload.js","hash":"fef224ee29365821af9a0d4fe18f99665a65eb80","modified":1756385947572},{"_id":"node_modules/hexo-theme-kira/scripts/tag/codepen.js","hash":"8b871ebc448984b97559f07313845c384080ed0f","modified":1756385946863},{"_id":"node_modules/hexo-theme-kira/layout/components/sidebar.ejs","hash":"f3a34ba45e03f231a0acc2ca81214cbb61c80d7e","modified":1756385945977},{"_id":"node_modules/hexo-theme-kira/LICENSE","hash":"16401737d2489b2399c6bcb2274e8835bc21c2ec","modified":1756385940041},{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","hash":"014aeb1e8edee23ab191accde28b903094e0250a","modified":1756385948698},{"_id":"node_modules/hexo-theme-kira/layout/_widget/tagcloud.ejs","hash":"ae70b1e05f4b9e0bdc4bc4946aab9a2f04b62441","modified":1756385946206},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","hash":"de24fe89ea6609bedb10d6883813900613bc666c","modified":1756385948885},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","hash":"5d71b0348e8777d44fcac4dd1b42691bb60ca0a0","modified":1756385948767},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","hash":"f855d66a230c058d879afabe9440d6983228f75c","modified":1756385949073},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","hash":"0ec2c5bee6b740d1c470b1552b0489ce2752a43b","modified":1756385949103},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","hash":"174acae9379c2521e9658ee7a9cca78121efdb56","modified":1756385949156},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","hash":"9882f6fdf8b0a840b461fe68b5a5781ac5f9a135","modified":1756385948973},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","hash":"6012db7df3e0491f2469025b8e39e3542a389e00","modified":1756385949269},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","hash":"a50707cf85e00790344d1822ca6aaf3482e06e90","modified":1756385949510},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","hash":"4638f0d7f257287e680ac67abd3241331a7f57c5","modified":1756385949351},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","hash":"24e882ac68cc8ae1bbcdd156192101c68859bdc7","modified":1756385949397},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/gitalk.ejs","hash":"6ea24c937c1b38598323cae3f42c2a5e12d8fff0","modified":1756385945126},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","hash":"84aa358b87ca68af35b331fc1c807f68f8c22dd4","modified":1756385947754},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","hash":"30165070270d51377ab8a5b2bd6ee03d81c2ab26","modified":1756385949443},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","hash":"3d7d083ddd43da4fbc5af70d888ad2f39d7c5f9b","modified":1756385947906},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","hash":"768b978c8bef776a5ac32b3c86df498b881f882b","modified":1756385947721},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","hash":"172f73ad5a78d7976a3b0e8f69672270520002ff","modified":1756385949553},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/giscus.ejs","hash":"2df2a6b98e5060d0c2dd2ef9bb2f6a690a747e16","modified":1756385945029},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","hash":"c9a7d747dfa8fe4d3fc7ddb096b0506f55ff1fd4","modified":1756385948295},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","hash":"13c907c5a0df08f4a94be5ee2ca544b5a5a247ad","modified":1756385948401},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1756385946640},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1756385940824},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","hash":"56dddcd32332b54853ba9eadba3c883f95f00275","modified":1756385941530},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1756385942241},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","hash":"84918de2a2e36d051ee51c3ea17f5d6e601714da","modified":1756385942510},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","hash":"65b9325f267371c9e5a07a7a3a224c5766d07c18","modified":1756385946344},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","hash":"72c1211ab8026e3f7419f05bf8860fac6e96fe65","modified":1756385947481},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","hash":"fccceb7956fd4f43c5ce1a18a100513ba353753c","modified":1756385948478},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","hash":"a066712350eb107bdfeb78130ec4ce58d3a29655","modified":1756385949603},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","hash":"7938931f0d753453933c6c75ff1ff1d02b51c983","modified":1756385949688},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","hash":"47b0a99b271ef70b3663dab0d611e471db59a49b","modified":1756385949795},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","hash":"9b0794e07fb0b700c73032b6ea596d88b2bbe196","modified":1756385947405},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","hash":"003a814293e06d95d569b7ba7bb4d2eb2a774caa","modified":1756385948083},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1756385949940},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1756385950033},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1756385950219},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","hash":"5b08b35be36d94907e2205c3ed221db03a1f7b69","modified":1756385943824},{"_id":"source/friends.md","hash":"c7bd7ad6c95d75c506b9ed8dd6355fdcf2ab35a6","modified":1756385483631},{"_id":"source/about.md","hash":"38287a64332d252523fbb37b34de7c8f872f9211","modified":1758371777573},{"_id":"source/archive.md","hash":"00d3773d9b4a900f930fab0daa16a60e505470b1","modified":1756385483628},{"_id":"source/About-Kei/index.md","hash":"3787e5b137816efaa5c3ca0dd430a701d5ab5650","modified":1756450842271},{"_id":"source/pic/125349440_p0.png","hash":"731cb93b4cb2513938e5f7e7e2e49f613a4a8ee8","modified":1748400423311},{"_id":"source/pic/125981673_p0.png","hash":"2734031ed178567d5f3b16dfbac527b26db57e6c","modified":1751698164830},{"_id":"source/pic/101573594_p0.png","hash":"1c49ad11716ea306db3f43891b52882d8cd80c38","modified":1756435256108},{"_id":"source/_posts/aboutKei.md","hash":"9556c14570c3b8f0f8a62b61be50426fb476d945","modified":1756451004372},{"_id":"source/_posts/PythonTips.md","hash":"040cb0485b2144e8eb0d5d2eb2166c21fe463a87","modified":1758857676105},{"_id":"source/_posts/JavaTips.md","hash":"0e332e07b04ca6e5f0299a2d03899fbbe6567af1","modified":1757167250573},{"_id":"source/_posts/climb_stairs.md","hash":"f3189c54a960de340ab1ad25dc9f8598978ae678","modified":1758641125829},{"_id":"source/_posts/combined_sum.md","hash":"c78672ec845d0ea7416be1ff1842d2b10e641a3e","modified":1758682105105},{"_id":"source/_posts/fixed_length_slide_window_problem.md","hash":"95f24511ce5b70880f4517f8ade106c90f05a421","modified":1758641170714},{"_id":"source/_posts/machine_learning.md","hash":"a490c79c1513bd26056bbefba4280051362e4dbc","modified":1758374233325},{"_id":"source/assert/eg1.png","hash":"bf2b8957e8797d3c8ad2bbcfd04960992c1f9350","modified":1758208199923},{"_id":"source/assert/微信图片_20250914151010_28_9.png","hash":"e7cb1d02a730c9b6f0c7cc95de3b8910e80001ea","modified":1757833837664},{"_id":"source/_posts/binarySearch.md","hash":"b0eaf6b538454a4c1a405ccdeeb9b5a6daaf1de2","modified":1758641186991},{"_id":"source/_posts/machine_learning_.md","hash":"ed721bdd54977c923af8a018c08b2c7f13fba144","modified":1758806457882},{"_id":"source/assert/machine_learining/1.png","hash":"12c5005f680a9a51d12e7077fda130e2de55501f","modified":1758380544428},{"_id":"source/assert/machine_learining/3.png","hash":"90d8a82cfe8faaeb236d94bfedbef19c31d6f33a","modified":1758380586364},{"_id":"source/assert/machine_learining/2.png","hash":"af3c3ace8d185c8203782188ee77dd306ba35556","modified":1758380563527},{"_id":"source/assert/machine_learining/4.png","hash":"a1a60ba253e479410c5acb8b9c36a1b91d7e52a6","modified":1758380603885},{"_id":"source/_posts/android_develop.md","hash":"b892547a2cdeeb2176696a574e6be17b8ee8de9b","modified":1758895869557},{"_id":"source/_posts/monotonic_stack.md","hash":"bd979c1571cb9f1599a06815e3f0fa63c91ee1bb","modified":1758965212098},{"_id":"source/assert/algorithm/rainwatertrap2.png","hash":"a9bd3cf1afe5c94feac06ac55461da7e5f4ca010","modified":1758965101919},{"_id":"source/assert/algorithm/rainwatertrap.png","hash":"d6302d62734ddb20329b7b1f21447c4534c6bd26","modified":1758964954235},{"_id":"source/assert/rainwatertrap2.png","hash":"d6302d62734ddb20329b7b1f21447c4534c6bd26","modified":1758965058718}],"Category":[{"name":"算法笔记","_id":"cmfwpg9v10000ugtlbce15dne"},{"name":"编程语言","_id":"cmg22ta0b0001wotl6ge6ge9d"},{"name":"项目开发","_id":"cmg22ta0j0004wotlg4lnacog"}],"Data":[],"Page":[{"title":"我的朋友","layout":"friends","_content":"\n## 我的朋友\n","source":"friends.md","raw":"---\ntitle: 我的朋友\nlayout: friends\n---\n\n## 我的朋友\n","date":"2025-08-28T12:51:23.631Z","updated":"2025-08-28T12:51:23.631Z","path":"friends.html","comments":1,"_id":"cmewhimqd0000u4tla9s18h1z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E6%88%91%E7%9A%84%E6%9C%8B%E5%8F%8B\">我的朋友</span></h2></body></html>","excerpt":"","more":"<h2 id=\"我的朋友\"><a href=\"#我的朋友\" class=\"headerlink\" title=\"我的朋友\"></a>我的朋友</h2>"},{"title":"文章归档","layout":"archives","_content":"","source":"archive.md","raw":"---\ntitle: 文章归档\nlayout: archives\n---\n","date":"2025-08-28T12:51:23.628Z","updated":"2025-08-28T12:51:23.628Z","path":"archive.html","comments":1,"_id":"cmewhimqh0001u4tl112f0vou","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"关于本人","layout":"about","_content":"\n## 自我介绍\n$$\nx = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\n$$\n","source":"about.md","raw":"---\ntitle: 关于本人\nlayout: about\n---\n\n## 自我介绍\n$$\nx = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\n$$\n","date":"2025-09-20T12:36:17.573Z","updated":"2025-09-20T12:36:17.573Z","path":"about.html","_id":"cmewhimqi0003u4tl4atj5kog","comments":1,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D\">自我介绍</span></h2><p>$$<br>x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}<br>$$</p>\n</body></html>","excerpt":"","more":"<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>$$<br>x &#x3D; \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}<br>$$</p>\n"}],"Post":[{"title":"test","date":"2025-08-27T15:40:50.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2025-08-27 23:40:50\ntags:\n---\n","slug":"test","published":1,"updated":"2025-08-27T15:40:50.494Z","comments":1,"layout":"post","photos":[],"_id":"cmeu56jwd00015ktlb5y9ei7b","content":"","excerpt":"","more":""},{"title":"About Kei","date":"2025-08-29T07:00:42.000Z","_content":"","source":"_posts/aboutKei.md","raw":"---\ntitle: About Kei\ndate: 2025-08-29 15:00:42\ntags: txt\n---","slug":"aboutKei","published":1,"updated":"2025-08-29T07:03:24.372Z","comments":1,"layout":"post","photos":[],"_id":"cmewhlst20000c0tl6a4l66i8","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"Java笔记(持续更新...)","date":"2025-09-03T13:45:00.000Z","cover":"https://kei-blog.oss-cn-beijing.aliyuncs.com/asset/115945063_p0-cut.jpg","_content":"\n\n# Java 笔记\n---\n## 目录\n\n> [静态变量、静态方法](#静态变量静态方法)\n> [继承](#继承)\n> [多态](#多态)\n> [final关键字](#final-关键字)\n> [设计模式](#设计模式)\n> [枚举类](#枚举类)\n> [抽象类](#抽象类)\n> [接口](#接口)\n> [代码块](#代码块)\n> [内部类](#内部类)\n> [函数式编程](#函数式编程)\n> [常用API](#常用api)\n> [GUI编程](#gui编程)\n\n\n---\n## 静态变量、静态方法\n\n[返回目录](#目录)\n\n### 定义\n1. **静态变量（类变量）**：属于类，只加载一份，可以被类和类的全部对象访问\n2. **实例变量（对象变量）**：属于对象，每个对象有自己一份\n3. **静态方法（类方法）**：属于类，只能访问静态变量，不能访问实例变量\n4. **实例方法（对象方法）**：属于对象\n\n### 应用\n1. **静态变量**的应用实例: 记录对象的创建数量\n2. **静态方法**应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法\n~~~java\npublic class Student {\n    // 静态变量（类变量）：属于类，只加载一份，可以被类和类的全部对象访问\n    static String schoolName;\n    // 实例变量（对象变量）：属于对象，每个对象有自己一份\n    String name;\n    // 静态变量的应用实例: 记录对象的创建数量\n    static Integer count = 0 ;\n\n\n    public Student(String name){\n        this.name = name;\n        // 同一个类中，访问静态变量，类名可以不写\n        count++;\n    }\n\n    public Student(){\n        count++;\n    }\n\n    // 静态方法（类方法）：属于类，只能访问静态变量，不能访问实例变量\n    // 静态方法应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法\n    public static void printHelloWorld(){\n        System.out.println(\"Hello World\");\n    }\n\n    // 实例方法（对象方法）：属于对象\n    public void printName(){\n        System.out.println(name);\n    }\n\n}\n~~~\n\n### 注意事项\n1. **静态方法**可以直接访问**静态变量**，不能直接访问**实例变量**\n2. **实例方法**既可以直接访问**静态变量**，也可以直接访问**实例变量**\n3. **静态方法**不能使用`this`关键字（不属于对象，自然不可以用`this`）\n\n### 访问方式\n1. **静态变量**访问方式：**类名**.静态成员变量名<font color=red>（推荐方式）</font>\n2. **静态变量**访问方式：**对象名**.静态成员变量名（不推荐）\n3. **静态方法**访问方式：**类名**.静态方法名\n\n## 继承\n\n[返回目录](#目录)\n\n### 子类构造器的特点\n1. 子类的全部构造器，都会先调用父类的构造器，再调用自己的构造器\n2. 默认情况下，子类构造器的第一行都是`super();`(**写不写都有**)调用父类构造器，可自行指定有参还是无参\n\n### 兄弟构造器\n1. 构造器中可以使用`this(参数);`调用兄弟构造器，可用于为某个参数赋予默认值\n2. `super();`和`this();`必须写在构造器的**第一行**，并且**不能同时使用**\n\n## 多态\n\n[返回目录](#目录)\n\n### 认识多态\n1. 多态是在**继承/实现**情况下的一种现象，表现为**对象多态、行为多态**\n```java\npublic class main {\n    public static void main(String[] args) {\n        // 对象多态\n        Animal wolf = new Wolf();\n        Animal dog = new Dog();\n\n        // 行为多态\n        wolf.run();\n        System.out.println(wolf.name);\n        dog.run();\n        System.out.println(dog.name);\n\n        // 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n        goRun(wolf);\n        goRun(dog);\n\n        // 强制类型转换，解决多态下无法调用子类独有方法的问题\n        // 注意：对象的真实类型与强制转换的类型不同，会导致ClassCastException异常\n        Wolf newWolf = (Wolf)wolf;\n        Dog newDog = (Dog)dog;\n        newWolf.howl();\n        newDog.bark();\n\n        // instanceof 判断对象是否是某个类的实例\n        if(wolf instanceof Dog){\n            Dog newNewDog = (Dog)wolf;\n        } else if(wolf instanceof Wolf){\n            Wolf newNewWolf = (Wolf)wolf;\n        }\n\n    }\n\n    // 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n    public static void goRun(Animal animal){\n        animal.run();\n    }\n}\n\npublic class Animal {\n    String name = \"animal\";\n    public void run(){\n        System.out.println(\"running\");\n    }\n}\n\npublic class Dog extends Animal{\n    String name = \"Dog\";\n    @Override\n    public void run()\n    {\n        System.out.println(\"Dog is running\");\n    }\n\n    // 多态无法调用子类独有的方法\n    public void bark()\n    {\n        System.out.println(\"Dog is barking\");\n    }\n}\n\npublic class Wolf extends Animal{\n    String name = \"Wolf\";\n    @Override\n    public void run()\n    {\n        System.out.println(\"Wolf is running\");\n    }\n\n    // 多态无法调用子类独有的方法\n    public void howl()\n    {\n        System.out.println(\"Wolf is howling\");\n    }\n}\n```\n2. `run()`方法：编译看左`Animal`，运行看右`Dog/Wolf`\n3. `name`属性：编译看左`Animal`，运行看也左`Animal`\n\n### 多态的特性\n1. 多态模式下，右边的对象是解耦合的，便于拓展和维护\n2. 定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n3. 多态模式下，无法调用子类独有的方法\n4. 多态模式下，强制类型转换成子类对象，此时可以调用子类独有的方法\n5. 对象的真实类型与强制转换的类型不同，会导致`ClassCastException`异常\n6. `instanceof` 判断对象是否是某个类的实例，强制类型转换之前可以检查是否是某个类的实例\n\n## final 关键字\n\n[返回目录](#目录)\n\n### 基本概念\n1. `final` 关键字修饰类：表示该类不能被继承，称为**最终类**\n2. `final` 关键字修饰方法：表示该方法不能被重写，称为**最终方法**\n3. `final` 关键字修饰变量：表示该变量有且仅能赋值一次\n\n### 使用场景\n1. 使用`final`修饰**静态变量**，可以声明一个**常量**，通常作为系统配置信息，不再修改(常量通常全大写，多个单词用下划线连接，如`MAX_SIZE`)\n2. 使用`final`修饰**基本变量**，变量储存的**数据**不能改变\n3. 使用`final`修饰**引用变量**(类对象、数组对象)，变量存储的**地址**不能改变，但对象内部数据可以改变\n\n## 设计模式\n\n[返回目录](#目录)\n\n### 单例设计模式\n#### 作用\n确保某个类只创建一个对象\n\n#### 实现方式\n##### 饿汉式单例--用对象之前已创建完毕\n1. 将类的构造器私有\n2. 定义一个类变量记住一个对象\n3. 定义一个类方法获取对象\n\n~~~java\n// 饿汉式单例\npublic class A {\n    // 1. 私有化构造器：确保单例类对外不能创建对象\n    private A(){\n    }\n\n    // 2. 创建静态成员变量记住唯一的一个实例\n    private static final A a = new A();\n\n    // 3. 创建静态方法，返回唯一实例\n    public static A getInstance(){\n        return a;\n    }\n}\n~~~\n\n##### 懒汉式单例--用对象时才创建对象\n\n~~~java\n// 懒汉式单例\npublic class B {\n    // 私有化构造器\n    private B(){}\n\n    // 静态变量记住唯一实例\n    private static B b;\n\n    // 静态方法获取唯一实例\n    public static B getInstance(){\n        if(b == null){\n            b = new B();\n        }\n        return b;\n    }\n}\n~~~\n\n---\n### 模板方法设计模式\n#### 基本概念\n提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现\n#### 实现方式\n1. 定义模板方法，把共同实现步骤放进去\n2. 定义抽象方法，交给具体的子类完成\n3. 建议使用`final`修饰模板方法，防止被重写\n\n~~~java\npublic abstract class People {\n    // 模板方法设计模式\n    public final void write(){\n        System.out.println(\"重复部分代码\");\n        // 模板方法知道子类一定要重写的部分\n        // 使用抽象方法来实现重写部分\n        writeMain();\n\n        System.out.println(\"重复部分代码\");\n    }\n\n    // 定义一个抽象方法，子类必须实现\n    public abstract void writeMain();\n}\n\npublic class Student extends People{\n\n    @Override\n    public void writeMain() {\n        System.out.println(\"学生写代码\");\n    }\n}\n\npublic class Teacher extends People{\n    @Override\n    public void writeMain() {\n        System.out.println(\"老师写代码\");\n    }\n}\n~~~\n\n## 枚举类\n[返回目录](#目录)\n\n### 特点\n1. 枚举类都是最终类，不能被继承，都继承自`java.lang.Enum`\n2. 枚举类第一行只能罗列一些名称，这些名称是常量，每个常量会记住枚举类的一个对象\n3. 枚举类的构造器都是私有的，不能对外创建对象\n~~~java\n// 反编译后的枚举类结构\npublic final class com.kei.enumDemo.A extends java.lang.Enum<com.kei.enumDemo.A> {\n  public static final com.kei.enumDemo.A X;\n  public static final com.kei.enumDemo.A Y;\n  public static final com.kei.enumDemo.A Z;\n  public static com.kei.enumDemo.A[] values();\n  public static com.kei.enumDemo.A valueOf(java.lang.String);\n  static {};\n}\n~~~\n\n### Api\n1. `name()`：返回枚举常量的名称\n2. `ordinal()`：返回枚举常量的索引，索引从0开始\n\n### 使用场景\n1. 枚举类一般用于信息分类和标志\n2. 枚举类作为形参可以约束传入参数\n\n\n## 抽象类\n[返回目录](#目录)\n### 抽象类和抽象方法\n1. 抽象类：抽象类不能实例化对象，只能被继承\n2. 抽象方法：抽象方法没有方法体，方法体由子类实现\n\n## 接口\n[返回目录](#目录)\n### 基本概念\n`interface` 关键字定义接口\n1. 定义常量，接口中的常量public static final 可以不写，默认是public static final\n2. 定义抽象方法，接口中的抽象方法public abstract 可以不写，默认是public abstract\n3. 接口不能实例化对象\n4. 接口可以被实现类通过`implements`关键字**实现**，一个类只能**继承**一个父类，但可以**实现**多个接口\n5. 实现类必须实现所有接口中的抽象方法，否则必须声明抽象类\n\n### 接口的好处\n1. 解决了单继承的不足，使类的角色更多\n2. 面相接口编程，进一步解耦合\n\n### JDK8 新特性\n1. 默认方法：使用`default`关键字定义，默认被`public`修饰，只能由接口实现类对象调用，实际上是对象（实例）方法\n2. 私有方法：使用`private`关键字定义，只能由接口内部其他实例调用，不能被继承\n3. 静态方法：使用`static`关键字定义，默认被`public`修饰，只能由接口名称调用，实际上是类方法\n\n### 注意事项\n1. 多继承：**接口**可以继承多个**接口**\n2. 多实现：**接口**可以被多个**类**实现\n3. 一个接口继承多个接口时，若存在签名冲突，则不支持多继承和多实现\n4. 一个接口继承多个接口时，若存在同名默认方法，重写该方法可以不冲突\n5. 一个类继承了父类，同时实现了接口，若有同名方法，则父类方法优先\n6. 一个类继承了父类，同时实现了接口，若有同名方法，可通过`接口名.super.接口方法()`调用接口方法\n\n\n## 代码块\n\n[返回目录](#目录)\n\n### 静态代码块\n**格式**：`static{ }`\n**特点**：**类**加载时自动执行，只执行一次\n**作用**：完成**类**的初始化，静态变量的初始化赋值\n\n### 实例代码块\n**格式**：`{ }`\n**特点**：**对象**创建时自动执行，每次创建对象都会执行\n**作用**：完成**对象**的初始化，实例变量的初始化赋值\n\n## 内部类\n\n[返回目录](#目录)\n\n### 基本概念\n当一个类定义在另一个类的内部，这个类就是内部类\n当一个类的内部，包含一个完整的事物，且这个事物没必要单独设计，这个类可以被设计为内部类\n\n### 成员内部类\n1. 定义在外部类内，无`static`修饰，属于**外部类对象持有**的\n2. 创建内部类对象的语法：`外部类名.内部类名 对象名 = new 外部类对象().new 内部类名()`\n3. 成员内部类可以直接访问外部类**静态成员**，也可以访问外部类**实例成员**（成员内部类寄生于外部类对象）\n4. 成员内部类可以通过`外部类名.this`访问外部类对象\n\n### 静态内部类\n1. 定义在外部类内，有`static`修饰，属于**外部类持有**的\n2. 创建内部类对象的语法：`外部类名.内部类名 对象名 = new 外部类名.内部类名()`\n3. 静态内部类可以直接访问外部类**静态成员**，不能访问外部类**实例成员**\n\n### 匿名内部类\n1. 匿名内部类是一种特殊的局部内部类，不需要声明类名，默认有一个隐藏的名称\n2. 匿名内部类本质是一个子类，并且会立即创建一个子类对象，编译后会生成一个 `类名$编号.class` 文件\n~~~java\nnew 类或接口(参数){\n    类体（一般是方法重写）\n}\n~~~\n3. 用于更方便创建子类\n\n## 函数式编程\n\n[返回目录](#目录)\n\n### Lambda 表达式\n1. 语法：`(参数列表) -> {方法体}`\n2. 函数式接口：只有一个抽象方法的接口\n3. 可以简化函数式接口的匿名内部类\n\n### 静态方法引用\n1. 格式：`类名::静态方法名`\n2. 如果一个Lambda表达式里只调用一个静态方法，并且`->`前后的参数的形式一致，则可以使用静态方法引用\n\n### 实例方法引用\n1. 语法：`对象::实例方法名`\n2. 如果一个Lambda表达式里只调用一个实例方法，并且`->`前后的参数的形式一致，则可以使用实例方法引用\n\n### 特定类型方法引用\n1. 语法：`特定类名::实例方法名`\n2. 如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表的第一个参数作为方法的主调，后面所有参数都是作为实例方法的入参，则可以使用特定类型方法引用\n\n~~~java\npublic class Main2 {\n    public static void main(String[] args) {\n        // 需求：一个英文人名数组，按字母升序排序\n        String[] names = {\"Tom\", \"Jerry\", \"Mike\", \"Mary\", \"Smith\", \"Kate\", \"tom\", \"jam\", \"milk\"};\n\n        // 排序\n        Arrays.sort(names);\n        // 忽略首字母大小写\n        Arrays.sort(names, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                // compareToIgnoreCase(): 忽略大小写\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n\n        // Lambda 表达式\n        Arrays.sort(names, (o1, o2) -> o1.compareToIgnoreCase(o2));\n\n        // 特定的方法引用：类名::方法名\n        Arrays.sort(names, String::compareToIgnoreCase);\n\n        System.out.println(Arrays.toString(names));\n\n    }\n}\n~~~\n\n### 构造器引用\n1. 语法：`类名::new`\n2. 如果某个Lambda表达式里只是在创建对象，并且`->`前后的参数形式一致，则可以使用构造器引用\n\n~~~java\npublic class Main3 {\n    public static void main(String[] args) {\n        CarFactory factory = new CarFactory() {\n            @Override\n            public Car create(String name) {\n                return new Car(name);\n            }\n        };\n        // Lambda 表达式\n        CarFactory factory2 = (name) -> new Car(name);\n\n        // 构造器引用\n        CarFactory factory3 = Car::new;\n    }\n\n}\n\n@FunctionalInterface\ninterface CarFactory {\n    Car create(String name);\n}\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\nclass Car{\n    private String name;\n}\n~~~\n\n## 常用API\n\n[返回目录](#目录)\n\n> [String](#string)\n> [ArrayList](#arraylist)\n\n### String\n#### 创建字符串\n1. **方式一**：`String str = \"hello world\";`\n2. 方式二：调用构造器创建字符串对象\n   1. `String str = new String();` 创建一个空字符串对象\n   2. `String str = new String(\"hello world\");` 创建一个字符串对象\n   3. `String str = new String(char[] value);` 根据字符数组创建一个字符串对象\n   4. `String str = new String(byte[] value);` 根据字节数组创建一个字符串对象\n3. 方式一存放在**常量池**中，且相同的字符串对象只创建一个\n4. 方式二存放在**堆**中，且相同内容可以创建多个对象\n\n#### 处理字符串\n| 方法 | 作用 |\n| --- | --- |\n|`int length()`|获取字符串长度|\n|`boolean equals(Object obj)`|字符串内容比较（`==`比较的是字符串地址！）|\n|`char charAt(int index)`|获取索引处的字符|\n|`char[] toCharArray()`|转换成字符数组|\n|`boolean equalsIgnoreCase(String str)`|判断字符串内容是否一致，忽略大小写|\n|`String substring(int beginIndex, int endIndex)`|根据索引截取字符串|\n|`String substring(int beginIndex)`|从索引处截取字符串|\n|`String replace(CharSequence oldChar, CharSequence newChar)`|新值替换旧值|\n|`boolean contains(CharSequence s)`|判断字符串中是否包含子串|\n|`boolean startsWith(String prefix)`|判断字符串是否以指定字符开头|\n|`String[] split(String regex)`|将字符串按某个字符分割为字符串数组|\n\n### ArrayList\n| 方法 | 作用 |\n| --- | --- |\n|`ArrayList<E>()`|创建一个空的集合对象，E为集合中元素的数据类型，可不指定|\n|`boolean add(E e)`|添加元素到集合末尾|\n|`void add(int index, E element)`|在指定索引处添加元素|\n|`E get(int index)`|获取指定索引处的元素|\n|`int size()`|获取集合大小|\n|`E remove(int index)`|删除指定索引处的元素，返回删除的元素|\n|`boolean remove(Object o)`|删除指定元素，返回是否删除成功|\n|`E set(int index, E element)`|修改指定索引处的元素，返回修改前的元素|\n\n\n\n## *GUI编程\n> 目前项目开发几乎不使用Java来开发GUI界面，仅了解\n\n[返回目录](#目录)\n\n### 常见的Swing组件\n|组件|作用|\n| --- | --- |\n|[JFrame](#jframe)|窗口|\n|[JPanel](#jpanel)|面板，用于组织其他组件的容器|\n|[JButton](#jbutton)|按钮|\n|JTextField|文本输入框|\n|JTable|表格|\n\n### JFrame\n|API|作用|value|\n| --- | --- | --- |\n|`void setSize(int width, int height)`|设置窗口大小|\n|`void setLocationRelativeTo(Component c)`|设置窗口位置|\n|`void setDefaultCloseOperation(int operation)`|设置关闭方式|`JFrame.EXIT_ON_CLOSE` 关闭窗口时退出程序|\n|`void setVisible(boolean b)`|设置窗口是否可见|\n|`void add(Component c)`|添加组件|\n\n### JPanel\n[back to GUI编程](#gui编程)\n|API|作用|value|\n| --- | --- | --- |\n|`void add(Component c)`|添加组件|\n\n### JButton\n[back to GUI编程](#gui编程)\n|API|作用|value|\n| --- | --- | --- |\n|`void setText(String text)`|设置按钮文本|\n\n### Layout Manager\n[back to GUI编程](#gui编程)\n|Layout Manager|作用|\n| --- | --- |\n|`BorderLayout`|边界布局，将容器分成5个区域，North、South、East、West、Center，每个区域只有一个组件|\n|`FlowLayout`|流式布局，组件排满一行自动换行|\n|`GridLayout`|网格布局，组件会自动填充|\n|`GridBagLayout`|网格布局，组件会自动填充|\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaTips.md","raw":"---\ntitle: Java笔记(持续更新...)\ndate: 2025-09-03 21:45:00\ntags: Java\ncover: https://kei-blog.oss-cn-beijing.aliyuncs.com/asset/115945063_p0-cut.jpg\n---\n\n\n# Java 笔记\n---\n## 目录\n\n> [静态变量、静态方法](#静态变量静态方法)\n> [继承](#继承)\n> [多态](#多态)\n> [final关键字](#final-关键字)\n> [设计模式](#设计模式)\n> [枚举类](#枚举类)\n> [抽象类](#抽象类)\n> [接口](#接口)\n> [代码块](#代码块)\n> [内部类](#内部类)\n> [函数式编程](#函数式编程)\n> [常用API](#常用api)\n> [GUI编程](#gui编程)\n\n\n---\n## 静态变量、静态方法\n\n[返回目录](#目录)\n\n### 定义\n1. **静态变量（类变量）**：属于类，只加载一份，可以被类和类的全部对象访问\n2. **实例变量（对象变量）**：属于对象，每个对象有自己一份\n3. **静态方法（类方法）**：属于类，只能访问静态变量，不能访问实例变量\n4. **实例方法（对象方法）**：属于对象\n\n### 应用\n1. **静态变量**的应用实例: 记录对象的创建数量\n2. **静态方法**应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法\n~~~java\npublic class Student {\n    // 静态变量（类变量）：属于类，只加载一份，可以被类和类的全部对象访问\n    static String schoolName;\n    // 实例变量（对象变量）：属于对象，每个对象有自己一份\n    String name;\n    // 静态变量的应用实例: 记录对象的创建数量\n    static Integer count = 0 ;\n\n\n    public Student(String name){\n        this.name = name;\n        // 同一个类中，访问静态变量，类名可以不写\n        count++;\n    }\n\n    public Student(){\n        count++;\n    }\n\n    // 静态方法（类方法）：属于类，只能访问静态变量，不能访问实例变量\n    // 静态方法应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法\n    public static void printHelloWorld(){\n        System.out.println(\"Hello World\");\n    }\n\n    // 实例方法（对象方法）：属于对象\n    public void printName(){\n        System.out.println(name);\n    }\n\n}\n~~~\n\n### 注意事项\n1. **静态方法**可以直接访问**静态变量**，不能直接访问**实例变量**\n2. **实例方法**既可以直接访问**静态变量**，也可以直接访问**实例变量**\n3. **静态方法**不能使用`this`关键字（不属于对象，自然不可以用`this`）\n\n### 访问方式\n1. **静态变量**访问方式：**类名**.静态成员变量名<font color=red>（推荐方式）</font>\n2. **静态变量**访问方式：**对象名**.静态成员变量名（不推荐）\n3. **静态方法**访问方式：**类名**.静态方法名\n\n## 继承\n\n[返回目录](#目录)\n\n### 子类构造器的特点\n1. 子类的全部构造器，都会先调用父类的构造器，再调用自己的构造器\n2. 默认情况下，子类构造器的第一行都是`super();`(**写不写都有**)调用父类构造器，可自行指定有参还是无参\n\n### 兄弟构造器\n1. 构造器中可以使用`this(参数);`调用兄弟构造器，可用于为某个参数赋予默认值\n2. `super();`和`this();`必须写在构造器的**第一行**，并且**不能同时使用**\n\n## 多态\n\n[返回目录](#目录)\n\n### 认识多态\n1. 多态是在**继承/实现**情况下的一种现象，表现为**对象多态、行为多态**\n```java\npublic class main {\n    public static void main(String[] args) {\n        // 对象多态\n        Animal wolf = new Wolf();\n        Animal dog = new Dog();\n\n        // 行为多态\n        wolf.run();\n        System.out.println(wolf.name);\n        dog.run();\n        System.out.println(dog.name);\n\n        // 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n        goRun(wolf);\n        goRun(dog);\n\n        // 强制类型转换，解决多态下无法调用子类独有方法的问题\n        // 注意：对象的真实类型与强制转换的类型不同，会导致ClassCastException异常\n        Wolf newWolf = (Wolf)wolf;\n        Dog newDog = (Dog)dog;\n        newWolf.howl();\n        newDog.bark();\n\n        // instanceof 判断对象是否是某个类的实例\n        if(wolf instanceof Dog){\n            Dog newNewDog = (Dog)wolf;\n        } else if(wolf instanceof Wolf){\n            Wolf newNewWolf = (Wolf)wolf;\n        }\n\n    }\n\n    // 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n    public static void goRun(Animal animal){\n        animal.run();\n    }\n}\n\npublic class Animal {\n    String name = \"animal\";\n    public void run(){\n        System.out.println(\"running\");\n    }\n}\n\npublic class Dog extends Animal{\n    String name = \"Dog\";\n    @Override\n    public void run()\n    {\n        System.out.println(\"Dog is running\");\n    }\n\n    // 多态无法调用子类独有的方法\n    public void bark()\n    {\n        System.out.println(\"Dog is barking\");\n    }\n}\n\npublic class Wolf extends Animal{\n    String name = \"Wolf\";\n    @Override\n    public void run()\n    {\n        System.out.println(\"Wolf is running\");\n    }\n\n    // 多态无法调用子类独有的方法\n    public void howl()\n    {\n        System.out.println(\"Wolf is howling\");\n    }\n}\n```\n2. `run()`方法：编译看左`Animal`，运行看右`Dog/Wolf`\n3. `name`属性：编译看左`Animal`，运行看也左`Animal`\n\n### 多态的特性\n1. 多态模式下，右边的对象是解耦合的，便于拓展和维护\n2. 定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强\n3. 多态模式下，无法调用子类独有的方法\n4. 多态模式下，强制类型转换成子类对象，此时可以调用子类独有的方法\n5. 对象的真实类型与强制转换的类型不同，会导致`ClassCastException`异常\n6. `instanceof` 判断对象是否是某个类的实例，强制类型转换之前可以检查是否是某个类的实例\n\n## final 关键字\n\n[返回目录](#目录)\n\n### 基本概念\n1. `final` 关键字修饰类：表示该类不能被继承，称为**最终类**\n2. `final` 关键字修饰方法：表示该方法不能被重写，称为**最终方法**\n3. `final` 关键字修饰变量：表示该变量有且仅能赋值一次\n\n### 使用场景\n1. 使用`final`修饰**静态变量**，可以声明一个**常量**，通常作为系统配置信息，不再修改(常量通常全大写，多个单词用下划线连接，如`MAX_SIZE`)\n2. 使用`final`修饰**基本变量**，变量储存的**数据**不能改变\n3. 使用`final`修饰**引用变量**(类对象、数组对象)，变量存储的**地址**不能改变，但对象内部数据可以改变\n\n## 设计模式\n\n[返回目录](#目录)\n\n### 单例设计模式\n#### 作用\n确保某个类只创建一个对象\n\n#### 实现方式\n##### 饿汉式单例--用对象之前已创建完毕\n1. 将类的构造器私有\n2. 定义一个类变量记住一个对象\n3. 定义一个类方法获取对象\n\n~~~java\n// 饿汉式单例\npublic class A {\n    // 1. 私有化构造器：确保单例类对外不能创建对象\n    private A(){\n    }\n\n    // 2. 创建静态成员变量记住唯一的一个实例\n    private static final A a = new A();\n\n    // 3. 创建静态方法，返回唯一实例\n    public static A getInstance(){\n        return a;\n    }\n}\n~~~\n\n##### 懒汉式单例--用对象时才创建对象\n\n~~~java\n// 懒汉式单例\npublic class B {\n    // 私有化构造器\n    private B(){}\n\n    // 静态变量记住唯一实例\n    private static B b;\n\n    // 静态方法获取唯一实例\n    public static B getInstance(){\n        if(b == null){\n            b = new B();\n        }\n        return b;\n    }\n}\n~~~\n\n---\n### 模板方法设计模式\n#### 基本概念\n提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现\n#### 实现方式\n1. 定义模板方法，把共同实现步骤放进去\n2. 定义抽象方法，交给具体的子类完成\n3. 建议使用`final`修饰模板方法，防止被重写\n\n~~~java\npublic abstract class People {\n    // 模板方法设计模式\n    public final void write(){\n        System.out.println(\"重复部分代码\");\n        // 模板方法知道子类一定要重写的部分\n        // 使用抽象方法来实现重写部分\n        writeMain();\n\n        System.out.println(\"重复部分代码\");\n    }\n\n    // 定义一个抽象方法，子类必须实现\n    public abstract void writeMain();\n}\n\npublic class Student extends People{\n\n    @Override\n    public void writeMain() {\n        System.out.println(\"学生写代码\");\n    }\n}\n\npublic class Teacher extends People{\n    @Override\n    public void writeMain() {\n        System.out.println(\"老师写代码\");\n    }\n}\n~~~\n\n## 枚举类\n[返回目录](#目录)\n\n### 特点\n1. 枚举类都是最终类，不能被继承，都继承自`java.lang.Enum`\n2. 枚举类第一行只能罗列一些名称，这些名称是常量，每个常量会记住枚举类的一个对象\n3. 枚举类的构造器都是私有的，不能对外创建对象\n~~~java\n// 反编译后的枚举类结构\npublic final class com.kei.enumDemo.A extends java.lang.Enum<com.kei.enumDemo.A> {\n  public static final com.kei.enumDemo.A X;\n  public static final com.kei.enumDemo.A Y;\n  public static final com.kei.enumDemo.A Z;\n  public static com.kei.enumDemo.A[] values();\n  public static com.kei.enumDemo.A valueOf(java.lang.String);\n  static {};\n}\n~~~\n\n### Api\n1. `name()`：返回枚举常量的名称\n2. `ordinal()`：返回枚举常量的索引，索引从0开始\n\n### 使用场景\n1. 枚举类一般用于信息分类和标志\n2. 枚举类作为形参可以约束传入参数\n\n\n## 抽象类\n[返回目录](#目录)\n### 抽象类和抽象方法\n1. 抽象类：抽象类不能实例化对象，只能被继承\n2. 抽象方法：抽象方法没有方法体，方法体由子类实现\n\n## 接口\n[返回目录](#目录)\n### 基本概念\n`interface` 关键字定义接口\n1. 定义常量，接口中的常量public static final 可以不写，默认是public static final\n2. 定义抽象方法，接口中的抽象方法public abstract 可以不写，默认是public abstract\n3. 接口不能实例化对象\n4. 接口可以被实现类通过`implements`关键字**实现**，一个类只能**继承**一个父类，但可以**实现**多个接口\n5. 实现类必须实现所有接口中的抽象方法，否则必须声明抽象类\n\n### 接口的好处\n1. 解决了单继承的不足，使类的角色更多\n2. 面相接口编程，进一步解耦合\n\n### JDK8 新特性\n1. 默认方法：使用`default`关键字定义，默认被`public`修饰，只能由接口实现类对象调用，实际上是对象（实例）方法\n2. 私有方法：使用`private`关键字定义，只能由接口内部其他实例调用，不能被继承\n3. 静态方法：使用`static`关键字定义，默认被`public`修饰，只能由接口名称调用，实际上是类方法\n\n### 注意事项\n1. 多继承：**接口**可以继承多个**接口**\n2. 多实现：**接口**可以被多个**类**实现\n3. 一个接口继承多个接口时，若存在签名冲突，则不支持多继承和多实现\n4. 一个接口继承多个接口时，若存在同名默认方法，重写该方法可以不冲突\n5. 一个类继承了父类，同时实现了接口，若有同名方法，则父类方法优先\n6. 一个类继承了父类，同时实现了接口，若有同名方法，可通过`接口名.super.接口方法()`调用接口方法\n\n\n## 代码块\n\n[返回目录](#目录)\n\n### 静态代码块\n**格式**：`static{ }`\n**特点**：**类**加载时自动执行，只执行一次\n**作用**：完成**类**的初始化，静态变量的初始化赋值\n\n### 实例代码块\n**格式**：`{ }`\n**特点**：**对象**创建时自动执行，每次创建对象都会执行\n**作用**：完成**对象**的初始化，实例变量的初始化赋值\n\n## 内部类\n\n[返回目录](#目录)\n\n### 基本概念\n当一个类定义在另一个类的内部，这个类就是内部类\n当一个类的内部，包含一个完整的事物，且这个事物没必要单独设计，这个类可以被设计为内部类\n\n### 成员内部类\n1. 定义在外部类内，无`static`修饰，属于**外部类对象持有**的\n2. 创建内部类对象的语法：`外部类名.内部类名 对象名 = new 外部类对象().new 内部类名()`\n3. 成员内部类可以直接访问外部类**静态成员**，也可以访问外部类**实例成员**（成员内部类寄生于外部类对象）\n4. 成员内部类可以通过`外部类名.this`访问外部类对象\n\n### 静态内部类\n1. 定义在外部类内，有`static`修饰，属于**外部类持有**的\n2. 创建内部类对象的语法：`外部类名.内部类名 对象名 = new 外部类名.内部类名()`\n3. 静态内部类可以直接访问外部类**静态成员**，不能访问外部类**实例成员**\n\n### 匿名内部类\n1. 匿名内部类是一种特殊的局部内部类，不需要声明类名，默认有一个隐藏的名称\n2. 匿名内部类本质是一个子类，并且会立即创建一个子类对象，编译后会生成一个 `类名$编号.class` 文件\n~~~java\nnew 类或接口(参数){\n    类体（一般是方法重写）\n}\n~~~\n3. 用于更方便创建子类\n\n## 函数式编程\n\n[返回目录](#目录)\n\n### Lambda 表达式\n1. 语法：`(参数列表) -> {方法体}`\n2. 函数式接口：只有一个抽象方法的接口\n3. 可以简化函数式接口的匿名内部类\n\n### 静态方法引用\n1. 格式：`类名::静态方法名`\n2. 如果一个Lambda表达式里只调用一个静态方法，并且`->`前后的参数的形式一致，则可以使用静态方法引用\n\n### 实例方法引用\n1. 语法：`对象::实例方法名`\n2. 如果一个Lambda表达式里只调用一个实例方法，并且`->`前后的参数的形式一致，则可以使用实例方法引用\n\n### 特定类型方法引用\n1. 语法：`特定类名::实例方法名`\n2. 如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表的第一个参数作为方法的主调，后面所有参数都是作为实例方法的入参，则可以使用特定类型方法引用\n\n~~~java\npublic class Main2 {\n    public static void main(String[] args) {\n        // 需求：一个英文人名数组，按字母升序排序\n        String[] names = {\"Tom\", \"Jerry\", \"Mike\", \"Mary\", \"Smith\", \"Kate\", \"tom\", \"jam\", \"milk\"};\n\n        // 排序\n        Arrays.sort(names);\n        // 忽略首字母大小写\n        Arrays.sort(names, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                // compareToIgnoreCase(): 忽略大小写\n                return o1.compareToIgnoreCase(o2);\n            }\n        });\n\n        // Lambda 表达式\n        Arrays.sort(names, (o1, o2) -> o1.compareToIgnoreCase(o2));\n\n        // 特定的方法引用：类名::方法名\n        Arrays.sort(names, String::compareToIgnoreCase);\n\n        System.out.println(Arrays.toString(names));\n\n    }\n}\n~~~\n\n### 构造器引用\n1. 语法：`类名::new`\n2. 如果某个Lambda表达式里只是在创建对象，并且`->`前后的参数形式一致，则可以使用构造器引用\n\n~~~java\npublic class Main3 {\n    public static void main(String[] args) {\n        CarFactory factory = new CarFactory() {\n            @Override\n            public Car create(String name) {\n                return new Car(name);\n            }\n        };\n        // Lambda 表达式\n        CarFactory factory2 = (name) -> new Car(name);\n\n        // 构造器引用\n        CarFactory factory3 = Car::new;\n    }\n\n}\n\n@FunctionalInterface\ninterface CarFactory {\n    Car create(String name);\n}\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\nclass Car{\n    private String name;\n}\n~~~\n\n## 常用API\n\n[返回目录](#目录)\n\n> [String](#string)\n> [ArrayList](#arraylist)\n\n### String\n#### 创建字符串\n1. **方式一**：`String str = \"hello world\";`\n2. 方式二：调用构造器创建字符串对象\n   1. `String str = new String();` 创建一个空字符串对象\n   2. `String str = new String(\"hello world\");` 创建一个字符串对象\n   3. `String str = new String(char[] value);` 根据字符数组创建一个字符串对象\n   4. `String str = new String(byte[] value);` 根据字节数组创建一个字符串对象\n3. 方式一存放在**常量池**中，且相同的字符串对象只创建一个\n4. 方式二存放在**堆**中，且相同内容可以创建多个对象\n\n#### 处理字符串\n| 方法 | 作用 |\n| --- | --- |\n|`int length()`|获取字符串长度|\n|`boolean equals(Object obj)`|字符串内容比较（`==`比较的是字符串地址！）|\n|`char charAt(int index)`|获取索引处的字符|\n|`char[] toCharArray()`|转换成字符数组|\n|`boolean equalsIgnoreCase(String str)`|判断字符串内容是否一致，忽略大小写|\n|`String substring(int beginIndex, int endIndex)`|根据索引截取字符串|\n|`String substring(int beginIndex)`|从索引处截取字符串|\n|`String replace(CharSequence oldChar, CharSequence newChar)`|新值替换旧值|\n|`boolean contains(CharSequence s)`|判断字符串中是否包含子串|\n|`boolean startsWith(String prefix)`|判断字符串是否以指定字符开头|\n|`String[] split(String regex)`|将字符串按某个字符分割为字符串数组|\n\n### ArrayList\n| 方法 | 作用 |\n| --- | --- |\n|`ArrayList<E>()`|创建一个空的集合对象，E为集合中元素的数据类型，可不指定|\n|`boolean add(E e)`|添加元素到集合末尾|\n|`void add(int index, E element)`|在指定索引处添加元素|\n|`E get(int index)`|获取指定索引处的元素|\n|`int size()`|获取集合大小|\n|`E remove(int index)`|删除指定索引处的元素，返回删除的元素|\n|`boolean remove(Object o)`|删除指定元素，返回是否删除成功|\n|`E set(int index, E element)`|修改指定索引处的元素，返回修改前的元素|\n\n\n\n## *GUI编程\n> 目前项目开发几乎不使用Java来开发GUI界面，仅了解\n\n[返回目录](#目录)\n\n### 常见的Swing组件\n|组件|作用|\n| --- | --- |\n|[JFrame](#jframe)|窗口|\n|[JPanel](#jpanel)|面板，用于组织其他组件的容器|\n|[JButton](#jbutton)|按钮|\n|JTextField|文本输入框|\n|JTable|表格|\n\n### JFrame\n|API|作用|value|\n| --- | --- | --- |\n|`void setSize(int width, int height)`|设置窗口大小|\n|`void setLocationRelativeTo(Component c)`|设置窗口位置|\n|`void setDefaultCloseOperation(int operation)`|设置关闭方式|`JFrame.EXIT_ON_CLOSE` 关闭窗口时退出程序|\n|`void setVisible(boolean b)`|设置窗口是否可见|\n|`void add(Component c)`|添加组件|\n\n### JPanel\n[back to GUI编程](#gui编程)\n|API|作用|value|\n| --- | --- | --- |\n|`void add(Component c)`|添加组件|\n\n### JButton\n[back to GUI编程](#gui编程)\n|API|作用|value|\n| --- | --- | --- |\n|`void setText(String text)`|设置按钮文本|\n\n### Layout Manager\n[back to GUI编程](#gui编程)\n|Layout Manager|作用|\n| --- | --- |\n|`BorderLayout`|边界布局，将容器分成5个区域，North、South、East、West、Center，每个区域只有一个组件|\n|`FlowLayout`|流式布局，组件排满一行自动换行|\n|`GridLayout`|网格布局，组件会自动填充|\n|`GridBagLayout`|网格布局，组件会自动填充|\n\n\n\n\n\n\n\n\n\n","slug":"JavaTips","published":1,"updated":"2025-09-06T14:00:50.573Z","_id":"cmf88q0440000c4tlhzl9avjf","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"java-%E7%AC%94%E8%AE%B0\">Java 笔记</span></h1><hr>\n<h2><span id=\"%E7%9B%AE%E5%BD%95\">目录</span></h2><blockquote>\n<p><a href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\">静态变量、静态方法</a><br><a href=\"#%E7%BB%A7%E6%89%BF\">继承</a><br><a href=\"#%E5%A4%9A%E6%80%81\">多态</a><br><a href=\"#final-%E5%85%B3%E9%94%AE%E5%AD%97\">final关键字</a><br><a href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">设计模式</a><br><a href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB\">枚举类</a><br><a href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\">抽象类</a><br><a href=\"#%E6%8E%A5%E5%8F%A3\">接口</a><br><a href=\"#%E4%BB%A3%E7%A0%81%E5%9D%97\">代码块</a><br><a href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\">内部类</a><br><a href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\">函数式编程</a><br><a href=\"#%E5%B8%B8%E7%94%A8api\">常用API</a><br><a href=\"#gui%E7%BC%96%E7%A8%8B\">GUI编程</a></p>\n</blockquote>\n<hr>\n<h2><span id=\"%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\">静态变量、静态方法</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%AE%9A%E4%B9%89\">定义</span></h3><ol>\n<li><strong>静态变量（类变量）</strong>：属于类，只加载一份，可以被类和类的全部对象访问</li>\n<li><strong>实例变量（对象变量）</strong>：属于对象，每个对象有自己一份</li>\n<li><strong>静态方法（类方法）</strong>：属于类，只能访问静态变量，不能访问实例变量</li>\n<li><strong>实例方法（对象方法）</strong>：属于对象</li>\n</ol>\n<h3><span id=\"%E5%BA%94%E7%94%A8\">应用</span></h3><ol>\n<li><strong>静态变量</strong>的应用实例: 记录对象的创建数量</li>\n<li><strong>静态方法</strong>应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> {<br>    <span class=\"hljs-comment\">// 静态变量（类变量）：属于类，只加载一份，可以被类和类的全部对象访问</span><br>    <span class=\"hljs-keyword\">static</span> String schoolName;<br>    <span class=\"hljs-comment\">// 实例变量（对象变量）：属于对象，每个对象有自己一份</span><br>    String name;<br>    <span class=\"hljs-comment\">// 静态变量的应用实例: 记录对象的创建数量</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ;<br><br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Student</span><span class=\"hljs-params\">(String name)</span>{<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>        <span class=\"hljs-comment\">// 同一个类中，访问静态变量，类名可以不写</span><br>        count++;<br>    }<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Student</span><span class=\"hljs-params\">()</span>{<br>        count++;<br>    }<br><br>    <span class=\"hljs-comment\">// 静态方法（类方法）：属于类，只能访问静态变量，不能访问实例变量</span><br>    <span class=\"hljs-comment\">// 静态方法应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printHelloWorld</span><span class=\"hljs-params\">()</span>{<br>        System.out.println(<span class=\"hljs-string\">\"Hello World\"</span>);<br>    }<br><br>    <span class=\"hljs-comment\">// 实例方法（对象方法）：属于对象</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printName</span><span class=\"hljs-params\">()</span>{<br>        System.out.println(name);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li><strong>静态方法</strong>可以直接访问<strong>静态变量</strong>，不能直接访问<strong>实例变量</strong></li>\n<li><strong>实例方法</strong>既可以直接访问<strong>静态变量</strong>，也可以直接访问<strong>实例变量</strong></li>\n<li><strong>静态方法</strong>不能使用<code>this</code>关键字（不属于对象，自然不可以用<code>this</code>）</li>\n</ol>\n<h3><span id=\"%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F\">访问方式</span></h3><ol>\n<li><strong>静态变量</strong>访问方式：<strong>类名</strong>.静态成员变量名<font color=\"red\">（推荐方式）</font></li>\n<li><strong>静态变量</strong>访问方式：<strong>对象名</strong>.静态成员变量名（不推荐）</li>\n<li><strong>静态方法</strong>访问方式：<strong>类名</strong>.静态方法名</li>\n</ol>\n<h2><span id=\"%E7%BB%A7%E6%89%BF\">继承</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9\">子类构造器的特点</span></h3><ol>\n<li>子类的全部构造器，都会先调用父类的构造器，再调用自己的构造器</li>\n<li>默认情况下，子类构造器的第一行都是<code>super();</code>(<strong>写不写都有</strong>)调用父类构造器，可自行指定有参还是无参</li>\n</ol>\n<h3><span id=\"%E5%85%84%E5%BC%9F%E6%9E%84%E9%80%A0%E5%99%A8\">兄弟构造器</span></h3><ol>\n<li>构造器中可以使用<code>this(参数);</code>调用兄弟构造器，可用于为某个参数赋予默认值</li>\n<li><code>super();</code>和<code>this();</code>必须写在构造器的<strong>第一行</strong>，并且<strong>不能同时使用</strong></li>\n</ol>\n<h2><span id=\"%E5%A4%9A%E6%80%81\">多态</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81\">认识多态</span></h3><ol>\n<li>多态是在<strong>继承/实现</strong>情况下的一种现象，表现为<strong>对象多态、行为多态</strong><figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">main</span> {<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {<br>        <span class=\"hljs-comment\">// 对象多态</span><br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">wolf</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Wolf</span>();<br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">dog</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><br>        <span class=\"hljs-comment\">// 行为多态</span><br>        wolf.run();<br>        System.out.println(wolf.name);<br>        dog.run();<br>        System.out.println(dog.name);<br><br>        <span class=\"hljs-comment\">// 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</span><br>        goRun(wolf);<br>        goRun(dog);<br><br>        <span class=\"hljs-comment\">// 强制类型转换，解决多态下无法调用子类独有方法的问题</span><br>        <span class=\"hljs-comment\">// 注意：对象的真实类型与强制转换的类型不同，会导致ClassCastException异常</span><br>        <span class=\"hljs-type\">Wolf</span> <span class=\"hljs-variable\">newWolf</span> <span class=\"hljs-operator\">=</span> (Wolf)wolf;<br>        <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">newDog</span> <span class=\"hljs-operator\">=</span> (Dog)dog;<br>        newWolf.howl();<br>        newDog.bark();<br><br>        <span class=\"hljs-comment\">// instanceof 判断对象是否是某个类的实例</span><br>        <span class=\"hljs-keyword\">if</span>(wolf <span class=\"hljs-keyword\">instanceof</span> Dog){<br>            <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">newNewDog</span> <span class=\"hljs-operator\">=</span> (Dog)wolf;<br>        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(wolf <span class=\"hljs-keyword\">instanceof</span> Wolf){<br>            <span class=\"hljs-type\">Wolf</span> <span class=\"hljs-variable\">newNewWolf</span> <span class=\"hljs-operator\">=</span> (Wolf)wolf;<br>        }<br><br>    }<br><br>    <span class=\"hljs-comment\">// 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">goRun</span><span class=\"hljs-params\">(Animal animal)</span>{<br>        animal.run();<br>    }<br>}<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> {<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"animal\"</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span>{<br>        System.out.println(<span class=\"hljs-string\">\"running\"</span>);<br>    }<br>}<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>{<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"Dog\"</span>;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span><br>    {<br>        System.out.println(<span class=\"hljs-string\">\"Dog is running\"</span>);<br>    }<br><br>    <span class=\"hljs-comment\">// 多态无法调用子类独有的方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bark</span><span class=\"hljs-params\">()</span><br>    {<br>        System.out.println(<span class=\"hljs-string\">\"Dog is barking\"</span>);<br>    }<br>}<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>{<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"Wolf\"</span>;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span><br>    {<br>        System.out.println(<span class=\"hljs-string\">\"Wolf is running\"</span>);<br>    }<br><br>    <span class=\"hljs-comment\">// 多态无法调用子类独有的方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">howl</span><span class=\"hljs-params\">()</span><br>    {<br>        System.out.println(<span class=\"hljs-string\">\"Wolf is howling\"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li>\n<li><code>run()</code>方法：编译看左<code>Animal</code>，运行看右<code>Dog/Wolf</code></li>\n<li><code>name</code>属性：编译看左<code>Animal</code>，运行看也左<code>Animal</code></li>\n</ol>\n<h3><span id=\"%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E6%80%A7\">多态的特性</span></h3><ol>\n<li>多态模式下，右边的对象是解耦合的，便于拓展和维护</li>\n<li>定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</li>\n<li>多态模式下，无法调用子类独有的方法</li>\n<li>多态模式下，强制类型转换成子类对象，此时可以调用子类独有的方法</li>\n<li>对象的真实类型与强制转换的类型不同，会导致<code>ClassCastException</code>异常</li>\n<li><code>instanceof</code> 判断对象是否是某个类的实例，强制类型转换之前可以检查是否是某个类的实例</li>\n</ol>\n<h2><span id=\"final-%E5%85%B3%E9%94%AE%E5%AD%97\">final 关键字</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</span></h3><ol>\n<li><code>final</code> 关键字修饰类：表示该类不能被继承，称为<strong>最终类</strong></li>\n<li><code>final</code> 关键字修饰方法：表示该方法不能被重写，称为<strong>最终方法</strong></li>\n<li><code>final</code> 关键字修饰变量：表示该变量有且仅能赋值一次</li>\n</ol>\n<h3><span id=\"%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">使用场景</span></h3><ol>\n<li>使用<code>final</code>修饰<strong>静态变量</strong>，可以声明一个<strong>常量</strong>，通常作为系统配置信息，不再修改(常量通常全大写，多个单词用下划线连接，如<code>MAX_SIZE</code>)</li>\n<li>使用<code>final</code>修饰<strong>基本变量</strong>，变量储存的<strong>数据</strong>不能改变</li>\n<li>使用<code>final</code>修饰<strong>引用变量</strong>(类对象、数组对象)，变量存储的<strong>地址</strong>不能改变，但对象内部数据可以改变</li>\n</ol>\n<h2><span id=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">设计模式</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">单例设计模式</span></h3><h4><span id=\"%E4%BD%9C%E7%94%A8\">作用</span></h4><p>确保某个类只创建一个对象</p>\n<h4><span id=\"%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">实现方式</span></h4><h5><span id=\"%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E2%80%93%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%89%8D%E5%B7%B2%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%AF%95\">饿汉式单例–用对象之前已创建完毕</span></h5><ol>\n<li>将类的构造器私有</li>\n<li>定义一个类变量记住一个对象</li>\n<li>定义一个类方法获取对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 饿汉式单例</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {<br>    <span class=\"hljs-comment\">// 1. 私有化构造器：确保单例类对外不能创建对象</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>{<br>    }<br><br>    <span class=\"hljs-comment\">// 2. 创建静态成员变量记住唯一的一个实例</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">A</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">A</span>();<br><br>    <span class=\"hljs-comment\">// 3. 创建静态方法，返回唯一实例</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> A <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span>{<br>        <span class=\"hljs-keyword\">return</span> a;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h5><span id=\"%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E2%80%93%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%89%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">懒汉式单例–用对象时才创建对象</span></h5><figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 懒汉式单例</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> {<br>    <span class=\"hljs-comment\">// 私有化构造器</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>{}<br><br>    <span class=\"hljs-comment\">// 静态变量记住唯一实例</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> B b;<br><br>    <span class=\"hljs-comment\">// 静态方法获取唯一实例</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> B <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span>{<br>        <span class=\"hljs-keyword\">if</span>(b == <span class=\"hljs-literal\">null</span>){<br>            b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">B</span>();<br>        }<br>        <span class=\"hljs-keyword\">return</span> b;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h3><span id=\"%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">模板方法设计模式</span></h3><h4><span id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</span></h4><p>提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现</p>\n<h4><span id=\"%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">实现方式</span></h4><ol>\n<li>定义模板方法，把共同实现步骤放进去</li>\n<li>定义抽象方法，交给具体的子类完成</li>\n<li>建议使用<code>final</code>修饰模板方法，防止被重写</li>\n</ol>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">People</span> {<br>    <span class=\"hljs-comment\">// 模板方法设计模式</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">write</span><span class=\"hljs-params\">()</span>{<br>        System.out.println(<span class=\"hljs-string\">\"重复部分代码\"</span>);<br>        <span class=\"hljs-comment\">// 模板方法知道子类一定要重写的部分</span><br>        <span class=\"hljs-comment\">// 使用抽象方法来实现重写部分</span><br>        writeMain();<br><br>        System.out.println(<span class=\"hljs-string\">\"重复部分代码\"</span>);<br>    }<br><br>    <span class=\"hljs-comment\">// 定义一个抽象方法，子类必须实现</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span>;<br>}<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">People</span>{<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span> {<br>        System.out.println(<span class=\"hljs-string\">\"学生写代码\"</span>);<br>    }<br>}<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">People</span>{<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span> {<br>        System.out.println(<span class=\"hljs-string\">\"老师写代码\"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2><span id=\"%E6%9E%9A%E4%B8%BE%E7%B1%BB\">枚举类</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E7%89%B9%E7%82%B9\">特点</span></h3><ol>\n<li>枚举类都是最终类，不能被继承，都继承自<code>java.lang.Enum</code></li>\n<li>枚举类第一行只能罗列一些名称，这些名称是常量，每个常量会记住枚举类的一个对象</li>\n<li>枚举类的构造器都是私有的，不能对外创建对象<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 反编译后的枚举类结构</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">com</span>.kei.enumDemo.A <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">java</span>.lang.Enum&lt;com.kei.enumDemo.A&gt; {<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A X;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A Y;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A Z;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> com.kei.enumDemo.A[] values();<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> com.kei.enumDemo.A <span class=\"hljs-title function_\">valueOf</span><span class=\"hljs-params\">(java.lang.String)</span>;<br>  <span class=\"hljs-keyword\">static</span> {};<br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3><span id=\"api\">Api</span></h3><ol>\n<li><code>name()</code>：返回枚举常量的名称</li>\n<li><code>ordinal()</code>：返回枚举常量的索引，索引从0开始</li>\n</ol>\n<h3><span id=\"%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">使用场景</span></h3><ol>\n<li>枚举类一般用于信息分类和标志</li>\n<li>枚举类作为形参可以约束传入参数</li>\n</ol>\n<h2><span id=\"%E6%8A%BD%E8%B1%A1%E7%B1%BB\">抽象类</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\">抽象类和抽象方法</span></h3><ol>\n<li>抽象类：抽象类不能实例化对象，只能被继承</li>\n<li>抽象方法：抽象方法没有方法体，方法体由子类实现</li>\n</ol>\n<h2><span id=\"%E6%8E%A5%E5%8F%A3\">接口</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</span></h3><p><code>interface</code> 关键字定义接口</p>\n<ol>\n<li>定义常量，接口中的常量public static final 可以不写，默认是public static final</li>\n<li>定义抽象方法，接口中的抽象方法public abstract 可以不写，默认是public abstract</li>\n<li>接口不能实例化对象</li>\n<li>接口可以被实现类通过<code>implements</code>关键字<strong>实现</strong>，一个类只能<strong>继承</strong>一个父类，但可以<strong>实现</strong>多个接口</li>\n<li>实现类必须实现所有接口中的抽象方法，否则必须声明抽象类</li>\n</ol>\n<h3><span id=\"%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A5%BD%E5%A4%84\">接口的好处</span></h3><ol>\n<li>解决了单继承的不足，使类的角色更多</li>\n<li>面相接口编程，进一步解耦合</li>\n</ol>\n<h3><span id=\"jdk8-%E6%96%B0%E7%89%B9%E6%80%A7\">JDK8 新特性</span></h3><ol>\n<li>默认方法：使用<code>default</code>关键字定义，默认被<code>public</code>修饰，只能由接口实现类对象调用，实际上是对象（实例）方法</li>\n<li>私有方法：使用<code>private</code>关键字定义，只能由接口内部其他实例调用，不能被继承</li>\n<li>静态方法：使用<code>static</code>关键字定义，默认被<code>public</code>修饰，只能由接口名称调用，实际上是类方法</li>\n</ol>\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li>多继承：<strong>接口</strong>可以继承多个<strong>接口</strong></li>\n<li>多实现：<strong>接口</strong>可以被多个<strong>类</strong>实现</li>\n<li>一个接口继承多个接口时，若存在签名冲突，则不支持多继承和多实现</li>\n<li>一个接口继承多个接口时，若存在同名默认方法，重写该方法可以不冲突</li>\n<li>一个类继承了父类，同时实现了接口，若有同名方法，则父类方法优先</li>\n<li>一个类继承了父类，同时实现了接口，若有同名方法，可通过<code>接口名.super.接口方法()</code>调用接口方法</li>\n</ol>\n<h2><span id=\"%E4%BB%A3%E7%A0%81%E5%9D%97\">代码块</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\">静态代码块</span></h3><p><strong>格式</strong>：<code>static{ }</code><br><strong>特点</strong>：<strong>类</strong>加载时自动执行，只执行一次<br><strong>作用</strong>：完成<strong>类</strong>的初始化，静态变量的初始化赋值</p>\n<h3><span id=\"%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97\">实例代码块</span></h3><p><strong>格式</strong>：<code>{ }</code><br><strong>特点</strong>：<strong>对象</strong>创建时自动执行，每次创建对象都会执行<br><strong>作用</strong>：完成<strong>对象</strong>的初始化，实例变量的初始化赋值</p>\n<h2><span id=\"%E5%86%85%E9%83%A8%E7%B1%BB\">内部类</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</span></h3><p>当一个类定义在另一个类的内部，这个类就是内部类<br>当一个类的内部，包含一个完整的事物，且这个事物没必要单独设计，这个类可以被设计为内部类</p>\n<h3><span id=\"%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\">成员内部类</span></h3><ol>\n<li>定义在外部类内，无<code>static</code>修饰，属于<strong>外部类对象持有</strong>的</li>\n<li>创建内部类对象的语法：<code>外部类名.内部类名 对象名 = new 外部类对象().new 内部类名()</code></li>\n<li>成员内部类可以直接访问外部类<strong>静态成员</strong>，也可以访问外部类<strong>实例成员</strong>（成员内部类寄生于外部类对象）</li>\n<li>成员内部类可以通过<code>外部类名.this</code>访问外部类对象</li>\n</ol>\n<h3><span id=\"%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\">静态内部类</span></h3><ol>\n<li>定义在外部类内，有<code>static</code>修饰，属于<strong>外部类持有</strong>的</li>\n<li>创建内部类对象的语法：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code></li>\n<li>静态内部类可以直接访问外部类<strong>静态成员</strong>，不能访问外部类<strong>实例成员</strong></li>\n</ol>\n<h3><span id=\"%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\">匿名内部类</span></h3><ol>\n<li>匿名内部类是一种特殊的局部内部类，不需要声明类名，默认有一个隐藏的名称</li>\n<li>匿名内部类本质是一个子类，并且会立即创建一个子类对象，编译后会生成一个 <code>类名$编号.class</code> 文件<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> 类或接口(参数){<br>    类体（一般是方法重写）<br>}<br></code></pre></td></tr></tbody></table></figure></li>\n<li>用于更方便创建子类</li>\n</ol>\n<h2><span id=\"%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\">函数式编程</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F\">Lambda 表达式</span></h3><ol>\n<li>语法：<code>(参数列表) -&gt; {方法体}</code></li>\n<li>函数式接口：只有一个抽象方法的接口</li>\n<li>可以简化函数式接口的匿名内部类</li>\n</ol>\n<h3><span id=\"%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\">静态方法引用</span></h3><ol>\n<li>格式：<code>类名::静态方法名</code></li>\n<li>如果一个Lambda表达式里只调用一个静态方法，并且<code>-&gt;</code>前后的参数的形式一致，则可以使用静态方法引用</li>\n</ol>\n<h3><span id=\"%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\">实例方法引用</span></h3><ol>\n<li>语法：<code>对象::实例方法名</code></li>\n<li>如果一个Lambda表达式里只调用一个实例方法，并且<code>-&gt;</code>前后的参数的形式一致，则可以使用实例方法引用</li>\n</ol>\n<h3><span id=\"%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\">特定类型方法引用</span></h3><ol>\n<li>语法：<code>特定类名::实例方法名</code></li>\n<li>如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表的第一个参数作为方法的主调，后面所有参数都是作为实例方法的入参，则可以使用特定类型方法引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main2</span> {<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {<br>        <span class=\"hljs-comment\">// 需求：一个英文人名数组，按字母升序排序</span><br>        String[] names = {<span class=\"hljs-string\">\"Tom\"</span>, <span class=\"hljs-string\">\"Jerry\"</span>, <span class=\"hljs-string\">\"Mike\"</span>, <span class=\"hljs-string\">\"Mary\"</span>, <span class=\"hljs-string\">\"Smith\"</span>, <span class=\"hljs-string\">\"Kate\"</span>, <span class=\"hljs-string\">\"tom\"</span>, <span class=\"hljs-string\">\"jam\"</span>, <span class=\"hljs-string\">\"milk\"</span>};<br><br>        <span class=\"hljs-comment\">// 排序</span><br>        Arrays.sort(names);<br>        <span class=\"hljs-comment\">// 忽略首字母大小写</span><br>        Arrays.sort(names, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>&lt;String&gt;() {<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(String o1, String o2)</span> {<br>                <span class=\"hljs-comment\">// compareToIgnoreCase(): 忽略大小写</span><br>                <span class=\"hljs-keyword\">return</span> o1.compareToIgnoreCase(o2);<br>            }<br>        });<br><br>        <span class=\"hljs-comment\">// Lambda 表达式</span><br>        Arrays.sort(names, (o1, o2) -&gt; o1.compareToIgnoreCase(o2));<br><br>        <span class=\"hljs-comment\">// 特定的方法引用：类名::方法名</span><br>        Arrays.sort(names, String::compareToIgnoreCase);<br><br>        System.out.println(Arrays.toString(names));<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8\">构造器引用</span></h3><ol>\n<li>语法：<code>类名::new</code></li>\n<li>如果某个Lambda表达式里只是在创建对象，并且<code>-&gt;</code>前后的参数形式一致，则可以使用构造器引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main3</span> {<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {<br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CarFactory</span>() {<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> Car <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(String name)</span> {<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(name);<br>            }<br>        };<br>        <span class=\"hljs-comment\">// Lambda 表达式</span><br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory2</span> <span class=\"hljs-operator\">=</span> (name) -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(name);<br><br>        <span class=\"hljs-comment\">// 构造器引用</span><br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory3</span> <span class=\"hljs-operator\">=</span> Car::<span class=\"hljs-keyword\">new</span>;<br>    }<br><br>}<br><br><span class=\"hljs-meta\">@FunctionalInterface</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CarFactory</span> {<br>    Car <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(String name)</span>;<br>}<br><br><span class=\"hljs-meta\">@Data</span><br><span class=\"hljs-meta\">@NoArgsConstructor</span><br><span class=\"hljs-meta\">@AllArgsConstructor</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span>{<br>    <span class=\"hljs-keyword\">private</span> String name;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2><span id=\"%E5%B8%B8%E7%94%A8api\">常用API</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<blockquote>\n<p><a href=\"#string\">String</a><br><a href=\"#arraylist\">ArrayList</a></p>\n</blockquote>\n<h3><span id=\"string\">String</span></h3><h4><span id=\"%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\">创建字符串</span></h4><ol>\n<li><strong>方式一</strong>：<code>String str = \"hello world\";</code></li>\n<li>方式二：调用构造器创建字符串对象<ol>\n<li><code>String str = new String();</code> 创建一个空字符串对象</li>\n<li><code>String str = new String(\"hello world\");</code> 创建一个字符串对象</li>\n<li><code>String str = new String(char[] value);</code> 根据字符数组创建一个字符串对象</li>\n<li><code>String str = new String(byte[] value);</code> 根据字节数组创建一个字符串对象</li>\n</ol>\n</li>\n<li>方式一存放在<strong>常量池</strong>中，且相同的字符串对象只创建一个</li>\n<li>方式二存放在<strong>堆</strong>中，且相同内容可以创建多个对象</li>\n</ol>\n<h4><span id=\"%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2\">处理字符串</span></h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>int length()</code></td>\n<td>获取字符串长度</td>\n</tr>\n<tr>\n<td><code>boolean equals(Object obj)</code></td>\n<td>字符串内容比较（<code>==</code>比较的是字符串地址！）</td>\n</tr>\n<tr>\n<td><code>char charAt(int index)</code></td>\n<td>获取索引处的字符</td>\n</tr>\n<tr>\n<td><code>char[] toCharArray()</code></td>\n<td>转换成字符数组</td>\n</tr>\n<tr>\n<td><code>boolean equalsIgnoreCase(String str)</code></td>\n<td>判断字符串内容是否一致，忽略大小写</td>\n</tr>\n<tr>\n<td><code>String substring(int beginIndex, int endIndex)</code></td>\n<td>根据索引截取字符串</td>\n</tr>\n<tr>\n<td><code>String substring(int beginIndex)</code></td>\n<td>从索引处截取字符串</td>\n</tr>\n<tr>\n<td><code>String replace(CharSequence oldChar, CharSequence newChar)</code></td>\n<td>新值替换旧值</td>\n</tr>\n<tr>\n<td><code>boolean contains(CharSequence s)</code></td>\n<td>判断字符串中是否包含子串</td>\n</tr>\n<tr>\n<td><code>boolean startsWith(String prefix)</code></td>\n<td>判断字符串是否以指定字符开头</td>\n</tr>\n<tr>\n<td><code>String[] split(String regex)</code></td>\n<td>将字符串按某个字符分割为字符串数组</td>\n</tr>\n</tbody></table>\n<h3><span id=\"arraylist\">ArrayList</span></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ArrayList&lt;E&gt;()</code></td>\n<td>创建一个空的集合对象，E为集合中元素的数据类型，可不指定</td>\n</tr>\n<tr>\n<td><code>boolean add(E e)</code></td>\n<td>添加元素到集合末尾</td>\n</tr>\n<tr>\n<td><code>void add(int index, E element)</code></td>\n<td>在指定索引处添加元素</td>\n</tr>\n<tr>\n<td><code>E get(int index)</code></td>\n<td>获取指定索引处的元素</td>\n</tr>\n<tr>\n<td><code>int size()</code></td>\n<td>获取集合大小</td>\n</tr>\n<tr>\n<td><code>E remove(int index)</code></td>\n<td>删除指定索引处的元素，返回删除的元素</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>删除指定元素，返回是否删除成功</td>\n</tr>\n<tr>\n<td><code>E set(int index, E element)</code></td>\n<td>修改指定索引处的元素，返回修改前的元素</td>\n</tr>\n</tbody></table>\n<h2><span id=\"gui%E7%BC%96%E7%A8%8B\">*GUI编程</span></h2><blockquote>\n<p>目前项目开发几乎不使用Java来开发GUI界面，仅了解</p>\n</blockquote>\n<p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%B8%B8%E8%A7%81%E7%9A%84swing%E7%BB%84%E4%BB%B6\">常见的Swing组件</span></h3><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"#jframe\">JFrame</a></td>\n<td>窗口</td>\n</tr>\n<tr>\n<td><a href=\"#jpanel\">JPanel</a></td>\n<td>面板，用于组织其他组件的容器</td>\n</tr>\n<tr>\n<td><a href=\"#jbutton\">JButton</a></td>\n<td>按钮</td>\n</tr>\n<tr>\n<td>JTextField</td>\n<td>文本输入框</td>\n</tr>\n<tr>\n<td>JTable</td>\n<td>表格</td>\n</tr>\n</tbody></table>\n<h3><span id=\"jframe\">JFrame</span></h3><table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void setSize(int width, int height)</code></td>\n<td>设置窗口大小</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void setLocationRelativeTo(Component c)</code></td>\n<td>设置窗口位置</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void setDefaultCloseOperation(int operation)</code></td>\n<td>设置关闭方式</td>\n<td><code>JFrame.EXIT_ON_CLOSE</code> 关闭窗口时退出程序</td>\n</tr>\n<tr>\n<td><code>void setVisible(boolean b)</code></td>\n<td>设置窗口是否可见</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void add(Component c)</code></td>\n<td>添加组件</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3><span id=\"jpanel\">JPanel</span></h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void add(Component c)</code></td>\n<td>添加组件</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3><span id=\"jbutton\">JButton</span></h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void setText(String text)</code></td>\n<td>设置按钮文本</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3><span id=\"layout-manager\">Layout Manager</span></h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>Layout Manager</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BorderLayout</code></td>\n<td>边界布局，将容器分成5个区域，North、South、East、West、Center，每个区域只有一个组件</td>\n</tr>\n<tr>\n<td><code>FlowLayout</code></td>\n<td>流式布局，组件排满一行自动换行</td>\n</tr>\n<tr>\n<td><code>GridLayout</code></td>\n<td>网格布局，组件会自动填充</td>\n</tr>\n<tr>\n<td><code>GridBagLayout</code></td>\n<td>网格布局，组件会自动填充</td>\n</tr>\n</tbody></table>\n</body></html>","excerpt":"","more":"<h1 id=\"Java-笔记\"><a href=\"#Java-笔记\" class=\"headerlink\" title=\"Java 笔记\"></a>Java 笔记</h1><hr>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><blockquote>\n<p><a href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\">静态变量、静态方法</a><br><a href=\"#%E7%BB%A7%E6%89%BF\">继承</a><br><a href=\"#%E5%A4%9A%E6%80%81\">多态</a><br><a href=\"#final-%E5%85%B3%E9%94%AE%E5%AD%97\">final关键字</a><br><a href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">设计模式</a><br><a href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB\">枚举类</a><br><a href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\">抽象类</a><br><a href=\"#%E6%8E%A5%E5%8F%A3\">接口</a><br><a href=\"#%E4%BB%A3%E7%A0%81%E5%9D%97\">代码块</a><br><a href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\">内部类</a><br><a href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\">函数式编程</a><br><a href=\"#%E5%B8%B8%E7%94%A8api\">常用API</a><br><a href=\"#gui%E7%BC%96%E7%A8%8B\">GUI编程</a></p>\n</blockquote>\n<hr>\n<h2 id=\"静态变量、静态方法\"><a href=\"#静态变量、静态方法\" class=\"headerlink\" title=\"静态变量、静态方法\"></a>静态变量、静态方法</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><strong>静态变量（类变量）</strong>：属于类，只加载一份，可以被类和类的全部对象访问</li>\n<li><strong>实例变量（对象变量）</strong>：属于对象，每个对象有自己一份</li>\n<li><strong>静态方法（类方法）</strong>：属于类，只能访问静态变量，不能访问实例变量</li>\n<li><strong>实例方法（对象方法）</strong>：属于对象</li>\n</ol>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ol>\n<li><strong>静态变量</strong>的应用实例: 记录对象的创建数量</li>\n<li><strong>静态方法</strong>应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br>    <span class=\"hljs-comment\">// 静态变量（类变量）：属于类，只加载一份，可以被类和类的全部对象访问</span><br>    <span class=\"hljs-keyword\">static</span> String schoolName;<br>    <span class=\"hljs-comment\">// 实例变量（对象变量）：属于对象，每个对象有自己一份</span><br>    String name;<br>    <span class=\"hljs-comment\">// 静态变量的应用实例: 记录对象的创建数量</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ;<br><br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Student</span><span class=\"hljs-params\">(String name)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name;<br>        <span class=\"hljs-comment\">// 同一个类中，访问静态变量，类名可以不写</span><br>        count++;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Student</span><span class=\"hljs-params\">()</span>&#123;<br>        count++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 静态方法（类方法）：属于类，只能访问静态变量，不能访问实例变量</span><br>    <span class=\"hljs-comment\">// 静态方法应用实例：对于只需要完成某个功能，而不需要直接访问对象的数据的方法，可以使用静态方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printHelloWorld</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Hello World&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 实例方法（对象方法）：属于对象</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printName</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(name);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><strong>静态方法</strong>可以直接访问<strong>静态变量</strong>，不能直接访问<strong>实例变量</strong></li>\n<li><strong>实例方法</strong>既可以直接访问<strong>静态变量</strong>，也可以直接访问<strong>实例变量</strong></li>\n<li><strong>静态方法</strong>不能使用<code>this</code>关键字（不属于对象，自然不可以用<code>this</code>）</li>\n</ol>\n<h3 id=\"访问方式\"><a href=\"#访问方式\" class=\"headerlink\" title=\"访问方式\"></a>访问方式</h3><ol>\n<li><strong>静态变量</strong>访问方式：<strong>类名</strong>.静态成员变量名<font color=red>（推荐方式）</font></li>\n<li><strong>静态变量</strong>访问方式：<strong>对象名</strong>.静态成员变量名（不推荐）</li>\n<li><strong>静态方法</strong>访问方式：<strong>类名</strong>.静态方法名</li>\n</ol>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"子类构造器的特点\"><a href=\"#子类构造器的特点\" class=\"headerlink\" title=\"子类构造器的特点\"></a>子类构造器的特点</h3><ol>\n<li>子类的全部构造器，都会先调用父类的构造器，再调用自己的构造器</li>\n<li>默认情况下，子类构造器的第一行都是<code>super();</code>(<strong>写不写都有</strong>)调用父类构造器，可自行指定有参还是无参</li>\n</ol>\n<h3 id=\"兄弟构造器\"><a href=\"#兄弟构造器\" class=\"headerlink\" title=\"兄弟构造器\"></a>兄弟构造器</h3><ol>\n<li>构造器中可以使用<code>this(参数);</code>调用兄弟构造器，可用于为某个参数赋予默认值</li>\n<li><code>super();</code>和<code>this();</code>必须写在构造器的<strong>第一行</strong>，并且<strong>不能同时使用</strong></li>\n</ol>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"认识多态\"><a href=\"#认识多态\" class=\"headerlink\" title=\"认识多态\"></a>认识多态</h3><ol>\n<li>多态是在<strong>继承&#x2F;实现</strong>情况下的一种现象，表现为<strong>对象多态、行为多态</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">main</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 对象多态</span><br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">wolf</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Wolf</span>();<br>        <span class=\"hljs-type\">Animal</span> <span class=\"hljs-variable\">dog</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><br>        <span class=\"hljs-comment\">// 行为多态</span><br>        wolf.run();<br>        System.out.println(wolf.name);<br>        dog.run();<br>        System.out.println(dog.name);<br><br>        <span class=\"hljs-comment\">// 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</span><br>        goRun(wolf);<br>        goRun(dog);<br><br>        <span class=\"hljs-comment\">// 强制类型转换，解决多态下无法调用子类独有方法的问题</span><br>        <span class=\"hljs-comment\">// 注意：对象的真实类型与强制转换的类型不同，会导致ClassCastException异常</span><br>        <span class=\"hljs-type\">Wolf</span> <span class=\"hljs-variable\">newWolf</span> <span class=\"hljs-operator\">=</span> (Wolf)wolf;<br>        <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">newDog</span> <span class=\"hljs-operator\">=</span> (Dog)dog;<br>        newWolf.howl();<br>        newDog.bark();<br><br>        <span class=\"hljs-comment\">// instanceof 判断对象是否是某个类的实例</span><br>        <span class=\"hljs-keyword\">if</span>(wolf <span class=\"hljs-keyword\">instanceof</span> Dog)&#123;<br>            <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">newNewDog</span> <span class=\"hljs-operator\">=</span> (Dog)wolf;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(wolf <span class=\"hljs-keyword\">instanceof</span> Wolf)&#123;<br>            <span class=\"hljs-type\">Wolf</span> <span class=\"hljs-variable\">newNewWolf</span> <span class=\"hljs-operator\">=</span> (Wolf)wolf;<br>        &#125;<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">// 多态的好处2：定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">goRun</span><span class=\"hljs-params\">(Animal animal)</span>&#123;<br>        animal.run();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;animal&quot;</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Dog&quot;</span>;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog is running&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 多态无法调用子类独有的方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bark</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Dog is barking&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Wolf&quot;</span>;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Wolf is running&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 多态无法调用子类独有的方法</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">howl</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Wolf is howling&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><code>run()</code>方法：编译看左<code>Animal</code>，运行看右<code>Dog/Wolf</code></li>\n<li><code>name</code>属性：编译看左<code>Animal</code>，运行看也左<code>Animal</code></li>\n</ol>\n<h3 id=\"多态的特性\"><a href=\"#多态的特性\" class=\"headerlink\" title=\"多态的特性\"></a>多态的特性</h3><ol>\n<li>多态模式下，右边的对象是解耦合的，便于拓展和维护</li>\n<li>定义方法时，使用父类的形参，可以接收一切子类对象，拓展性强</li>\n<li>多态模式下，无法调用子类独有的方法</li>\n<li>多态模式下，强制类型转换成子类对象，此时可以调用子类独有的方法</li>\n<li>对象的真实类型与强制转换的类型不同，会导致<code>ClassCastException</code>异常</li>\n<li><code>instanceof</code> 判断对象是否是某个类的实例，强制类型转换之前可以检查是否是某个类的实例</li>\n</ol>\n<h2 id=\"final-关键字\"><a href=\"#final-关键字\" class=\"headerlink\" title=\"final 关键字\"></a>final 关键字</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li><code>final</code> 关键字修饰类：表示该类不能被继承，称为<strong>最终类</strong></li>\n<li><code>final</code> 关键字修饰方法：表示该方法不能被重写，称为<strong>最终方法</strong></li>\n<li><code>final</code> 关键字修饰变量：表示该变量有且仅能赋值一次</li>\n</ol>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>使用<code>final</code>修饰<strong>静态变量</strong>，可以声明一个<strong>常量</strong>，通常作为系统配置信息，不再修改(常量通常全大写，多个单词用下划线连接，如<code>MAX_SIZE</code>)</li>\n<li>使用<code>final</code>修饰<strong>基本变量</strong>，变量储存的<strong>数据</strong>不能改变</li>\n<li>使用<code>final</code>修饰<strong>引用变量</strong>(类对象、数组对象)，变量存储的<strong>地址</strong>不能改变，但对象内部数据可以改变</li>\n</ol>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"单例设计模式\"><a href=\"#单例设计模式\" class=\"headerlink\" title=\"单例设计模式\"></a>单例设计模式</h3><h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>确保某个类只创建一个对象</p>\n<h4 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><h5 id=\"饿汉式单例–用对象之前已创建完毕\"><a href=\"#饿汉式单例–用对象之前已创建完毕\" class=\"headerlink\" title=\"饿汉式单例–用对象之前已创建完毕\"></a>饿汉式单例–用对象之前已创建完毕</h5><ol>\n<li>将类的构造器私有</li>\n<li>定义一个类变量记住一个对象</li>\n<li>定义一个类方法获取对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 饿汉式单例</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-comment\">// 1. 私有化构造器：确保单例类对外不能创建对象</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>&#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 2. 创建静态成员变量记住唯一的一个实例</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">A</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">A</span>();<br><br>    <span class=\"hljs-comment\">// 3. 创建静态方法，返回唯一实例</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> A <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"懒汉式单例–用对象时才创建对象\"><a href=\"#懒汉式单例–用对象时才创建对象\" class=\"headerlink\" title=\"懒汉式单例–用对象时才创建对象\"></a>懒汉式单例–用对象时才创建对象</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 懒汉式单例</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> &#123;<br>    <span class=\"hljs-comment\">// 私有化构造器</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>&#123;&#125;<br><br>    <span class=\"hljs-comment\">// 静态变量记住唯一实例</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> B b;<br><br>    <span class=\"hljs-comment\">// 静态方法获取唯一实例</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> B <span class=\"hljs-title function_\">getInstance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(b == <span class=\"hljs-literal\">null</span>)&#123;<br>            b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">B</span>();<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"模板方法设计模式\"><a href=\"#模板方法设计模式\" class=\"headerlink\" title=\"模板方法设计模式\"></a>模板方法设计模式</h3><h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现</p>\n<h4 id=\"实现方式-1\"><a href=\"#实现方式-1\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><ol>\n<li>定义模板方法，把共同实现步骤放进去</li>\n<li>定义抽象方法，交给具体的子类完成</li>\n<li>建议使用<code>final</code>修饰模板方法，防止被重写</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">People</span> &#123;<br>    <span class=\"hljs-comment\">// 模板方法设计模式</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">write</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;重复部分代码&quot;</span>);<br>        <span class=\"hljs-comment\">// 模板方法知道子类一定要重写的部分</span><br>        <span class=\"hljs-comment\">// 使用抽象方法来实现重写部分</span><br>        writeMain();<br><br>        System.out.println(<span class=\"hljs-string\">&quot;重复部分代码&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 定义一个抽象方法，子类必须实现</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">People</span>&#123;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;学生写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">People</span>&#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeMain</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;老师写代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>枚举类都是最终类，不能被继承，都继承自<code>java.lang.Enum</code></li>\n<li>枚举类第一行只能罗列一些名称，这些名称是常量，每个常量会记住枚举类的一个对象</li>\n<li>枚举类的构造器都是私有的，不能对外创建对象<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 反编译后的枚举类结构</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">com</span>.kei.enumDemo.A <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">java</span>.lang.Enum&lt;com.kei.enumDemo.A&gt; &#123;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A X;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A Y;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> com.kei.enumDemo.A Z;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> com.kei.enumDemo.A[] values();<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> com.kei.enumDemo.A <span class=\"hljs-title function_\">valueOf</span><span class=\"hljs-params\">(java.lang.String)</span>;<br>  <span class=\"hljs-keyword\">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Api\"><a href=\"#Api\" class=\"headerlink\" title=\"Api\"></a>Api</h3><ol>\n<li><code>name()</code>：返回枚举常量的名称</li>\n<li><code>ordinal()</code>：返回枚举常量的索引，索引从0开始</li>\n</ol>\n<h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>枚举类一般用于信息分类和标志</li>\n<li>枚举类作为形参可以约束传入参数</li>\n</ol>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"抽象类和抽象方法\"><a href=\"#抽象类和抽象方法\" class=\"headerlink\" title=\"抽象类和抽象方法\"></a>抽象类和抽象方法</h3><ol>\n<li>抽象类：抽象类不能实例化对象，只能被继承</li>\n<li>抽象方法：抽象方法没有方法体，方法体由子类实现</li>\n</ol>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"基本概念-2\"><a href=\"#基本概念-2\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><code>interface</code> 关键字定义接口</p>\n<ol>\n<li>定义常量，接口中的常量public static final 可以不写，默认是public static final</li>\n<li>定义抽象方法，接口中的抽象方法public abstract 可以不写，默认是public abstract</li>\n<li>接口不能实例化对象</li>\n<li>接口可以被实现类通过<code>implements</code>关键字<strong>实现</strong>，一个类只能<strong>继承</strong>一个父类，但可以<strong>实现</strong>多个接口</li>\n<li>实现类必须实现所有接口中的抽象方法，否则必须声明抽象类</li>\n</ol>\n<h3 id=\"接口的好处\"><a href=\"#接口的好处\" class=\"headerlink\" title=\"接口的好处\"></a>接口的好处</h3><ol>\n<li>解决了单继承的不足，使类的角色更多</li>\n<li>面相接口编程，进一步解耦合</li>\n</ol>\n<h3 id=\"JDK8-新特性\"><a href=\"#JDK8-新特性\" class=\"headerlink\" title=\"JDK8 新特性\"></a>JDK8 新特性</h3><ol>\n<li>默认方法：使用<code>default</code>关键字定义，默认被<code>public</code>修饰，只能由接口实现类对象调用，实际上是对象（实例）方法</li>\n<li>私有方法：使用<code>private</code>关键字定义，只能由接口内部其他实例调用，不能被继承</li>\n<li>静态方法：使用<code>static</code>关键字定义，默认被<code>public</code>修饰，只能由接口名称调用，实际上是类方法</li>\n</ol>\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>多继承：<strong>接口</strong>可以继承多个<strong>接口</strong></li>\n<li>多实现：<strong>接口</strong>可以被多个<strong>类</strong>实现</li>\n<li>一个接口继承多个接口时，若存在签名冲突，则不支持多继承和多实现</li>\n<li>一个接口继承多个接口时，若存在同名默认方法，重写该方法可以不冲突</li>\n<li>一个类继承了父类，同时实现了接口，若有同名方法，则父类方法优先</li>\n<li>一个类继承了父类，同时实现了接口，若有同名方法，可通过<code>接口名.super.接口方法()</code>调用接口方法</li>\n</ol>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h3><p><strong>格式</strong>：<code>static&#123; &#125;</code><br><strong>特点</strong>：<strong>类</strong>加载时自动执行，只执行一次<br><strong>作用</strong>：完成<strong>类</strong>的初始化，静态变量的初始化赋值</p>\n<h3 id=\"实例代码块\"><a href=\"#实例代码块\" class=\"headerlink\" title=\"实例代码块\"></a>实例代码块</h3><p><strong>格式</strong>：<code>&#123; &#125;</code><br><strong>特点</strong>：<strong>对象</strong>创建时自动执行，每次创建对象都会执行<br><strong>作用</strong>：完成<strong>对象</strong>的初始化，实例变量的初始化赋值</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"基本概念-3\"><a href=\"#基本概念-3\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>当一个类定义在另一个类的内部，这个类就是内部类<br>当一个类的内部，包含一个完整的事物，且这个事物没必要单独设计，这个类可以被设计为内部类</p>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><ol>\n<li>定义在外部类内，无<code>static</code>修饰，属于<strong>外部类对象持有</strong>的</li>\n<li>创建内部类对象的语法：<code>外部类名.内部类名 对象名 = new 外部类对象().new 内部类名()</code></li>\n<li>成员内部类可以直接访问外部类<strong>静态成员</strong>，也可以访问外部类<strong>实例成员</strong>（成员内部类寄生于外部类对象）</li>\n<li>成员内部类可以通过<code>外部类名.this</code>访问外部类对象</li>\n</ol>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><ol>\n<li>定义在外部类内，有<code>static</code>修饰，属于<strong>外部类持有</strong>的</li>\n<li>创建内部类对象的语法：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code></li>\n<li>静态内部类可以直接访问外部类<strong>静态成员</strong>，不能访问外部类<strong>实例成员</strong></li>\n</ol>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><ol>\n<li>匿名内部类是一种特殊的局部内部类，不需要声明类名，默认有一个隐藏的名称</li>\n<li>匿名内部类本质是一个子类，并且会立即创建一个子类对象，编译后会生成一个 <code>类名$编号.class</code> 文件<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> 类或接口(参数)&#123;<br>    类体（一般是方法重写）<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>用于更方便创建子类</li>\n</ol>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h3><ol>\n<li>语法：<code>(参数列表) -&gt; &#123;方法体&#125;</code></li>\n<li>函数式接口：只有一个抽象方法的接口</li>\n<li>可以简化函数式接口的匿名内部类</li>\n</ol>\n<h3 id=\"静态方法引用\"><a href=\"#静态方法引用\" class=\"headerlink\" title=\"静态方法引用\"></a>静态方法引用</h3><ol>\n<li>格式：<code>类名::静态方法名</code></li>\n<li>如果一个Lambda表达式里只调用一个静态方法，并且<code>-&gt;</code>前后的参数的形式一致，则可以使用静态方法引用</li>\n</ol>\n<h3 id=\"实例方法引用\"><a href=\"#实例方法引用\" class=\"headerlink\" title=\"实例方法引用\"></a>实例方法引用</h3><ol>\n<li>语法：<code>对象::实例方法名</code></li>\n<li>如果一个Lambda表达式里只调用一个实例方法，并且<code>-&gt;</code>前后的参数的形式一致，则可以使用实例方法引用</li>\n</ol>\n<h3 id=\"特定类型方法引用\"><a href=\"#特定类型方法引用\" class=\"headerlink\" title=\"特定类型方法引用\"></a>特定类型方法引用</h3><ol>\n<li>语法：<code>特定类名::实例方法名</code></li>\n<li>如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表的第一个参数作为方法的主调，后面所有参数都是作为实例方法的入参，则可以使用特定类型方法引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main2</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-comment\">// 需求：一个英文人名数组，按字母升序排序</span><br>        String[] names = &#123;<span class=\"hljs-string\">&quot;Tom&quot;</span>, <span class=\"hljs-string\">&quot;Jerry&quot;</span>, <span class=\"hljs-string\">&quot;Mike&quot;</span>, <span class=\"hljs-string\">&quot;Mary&quot;</span>, <span class=\"hljs-string\">&quot;Smith&quot;</span>, <span class=\"hljs-string\">&quot;Kate&quot;</span>, <span class=\"hljs-string\">&quot;tom&quot;</span>, <span class=\"hljs-string\">&quot;jam&quot;</span>, <span class=\"hljs-string\">&quot;milk&quot;</span>&#125;;<br><br>        <span class=\"hljs-comment\">// 排序</span><br>        Arrays.sort(names);<br>        <span class=\"hljs-comment\">// 忽略首字母大小写</span><br>        Arrays.sort(names, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>&lt;String&gt;() &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(String o1, String o2)</span> &#123;<br>                <span class=\"hljs-comment\">// compareToIgnoreCase(): 忽略大小写</span><br>                <span class=\"hljs-keyword\">return</span> o1.compareToIgnoreCase(o2);<br>            &#125;<br>        &#125;);<br><br>        <span class=\"hljs-comment\">// Lambda 表达式</span><br>        Arrays.sort(names, (o1, o2) -&gt; o1.compareToIgnoreCase(o2));<br><br>        <span class=\"hljs-comment\">// 特定的方法引用：类名::方法名</span><br>        Arrays.sort(names, String::compareToIgnoreCase);<br><br>        System.out.println(Arrays.toString(names));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h3><ol>\n<li>语法：<code>类名::new</code></li>\n<li>如果某个Lambda表达式里只是在创建对象，并且<code>-&gt;</code>前后的参数形式一致，则可以使用构造器引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main3</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CarFactory</span>() &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> Car <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(String name)</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(name);<br>            &#125;<br>        &#125;;<br>        <span class=\"hljs-comment\">// Lambda 表达式</span><br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory2</span> <span class=\"hljs-operator\">=</span> (name) -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(name);<br><br>        <span class=\"hljs-comment\">// 构造器引用</span><br>        <span class=\"hljs-type\">CarFactory</span> <span class=\"hljs-variable\">factory3</span> <span class=\"hljs-operator\">=</span> Car::<span class=\"hljs-keyword\">new</span>;<br>    &#125;<br><br>&#125;<br><br><span class=\"hljs-meta\">@FunctionalInterface</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">CarFactory</span> &#123;<br>    Car <span class=\"hljs-title function_\">create</span><span class=\"hljs-params\">(String name)</span>;<br>&#125;<br><br><span class=\"hljs-meta\">@Data</span><br><span class=\"hljs-meta\">@NoArgsConstructor</span><br><span class=\"hljs-meta\">@AllArgsConstructor</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span>&#123;<br>    <span class=\"hljs-keyword\">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<blockquote>\n<p><a href=\"#string\">String</a><br><a href=\"#arraylist\">ArrayList</a></p>\n</blockquote>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"创建字符串\"><a href=\"#创建字符串\" class=\"headerlink\" title=\"创建字符串\"></a>创建字符串</h4><ol>\n<li><strong>方式一</strong>：<code>String str = &quot;hello world&quot;;</code></li>\n<li>方式二：调用构造器创建字符串对象<ol>\n<li><code>String str = new String();</code> 创建一个空字符串对象</li>\n<li><code>String str = new String(&quot;hello world&quot;);</code> 创建一个字符串对象</li>\n<li><code>String str = new String(char[] value);</code> 根据字符数组创建一个字符串对象</li>\n<li><code>String str = new String(byte[] value);</code> 根据字节数组创建一个字符串对象</li>\n</ol>\n</li>\n<li>方式一存放在<strong>常量池</strong>中，且相同的字符串对象只创建一个</li>\n<li>方式二存放在<strong>堆</strong>中，且相同内容可以创建多个对象</li>\n</ol>\n<h4 id=\"处理字符串\"><a href=\"#处理字符串\" class=\"headerlink\" title=\"处理字符串\"></a>处理字符串</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>int length()</code></td>\n<td>获取字符串长度</td>\n</tr>\n<tr>\n<td><code>boolean equals(Object obj)</code></td>\n<td>字符串内容比较（<code>==</code>比较的是字符串地址！）</td>\n</tr>\n<tr>\n<td><code>char charAt(int index)</code></td>\n<td>获取索引处的字符</td>\n</tr>\n<tr>\n<td><code>char[] toCharArray()</code></td>\n<td>转换成字符数组</td>\n</tr>\n<tr>\n<td><code>boolean equalsIgnoreCase(String str)</code></td>\n<td>判断字符串内容是否一致，忽略大小写</td>\n</tr>\n<tr>\n<td><code>String substring(int beginIndex, int endIndex)</code></td>\n<td>根据索引截取字符串</td>\n</tr>\n<tr>\n<td><code>String substring(int beginIndex)</code></td>\n<td>从索引处截取字符串</td>\n</tr>\n<tr>\n<td><code>String replace(CharSequence oldChar, CharSequence newChar)</code></td>\n<td>新值替换旧值</td>\n</tr>\n<tr>\n<td><code>boolean contains(CharSequence s)</code></td>\n<td>判断字符串中是否包含子串</td>\n</tr>\n<tr>\n<td><code>boolean startsWith(String prefix)</code></td>\n<td>判断字符串是否以指定字符开头</td>\n</tr>\n<tr>\n<td><code>String[] split(String regex)</code></td>\n<td>将字符串按某个字符分割为字符串数组</td>\n</tr>\n</tbody></table>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ArrayList&lt;E&gt;()</code></td>\n<td>创建一个空的集合对象，E为集合中元素的数据类型，可不指定</td>\n</tr>\n<tr>\n<td><code>boolean add(E e)</code></td>\n<td>添加元素到集合末尾</td>\n</tr>\n<tr>\n<td><code>void add(int index, E element)</code></td>\n<td>在指定索引处添加元素</td>\n</tr>\n<tr>\n<td><code>E get(int index)</code></td>\n<td>获取指定索引处的元素</td>\n</tr>\n<tr>\n<td><code>int size()</code></td>\n<td>获取集合大小</td>\n</tr>\n<tr>\n<td><code>E remove(int index)</code></td>\n<td>删除指定索引处的元素，返回删除的元素</td>\n</tr>\n<tr>\n<td><code>boolean remove(Object o)</code></td>\n<td>删除指定元素，返回是否删除成功</td>\n</tr>\n<tr>\n<td><code>E set(int index, E element)</code></td>\n<td>修改指定索引处的元素，返回修改前的元素</td>\n</tr>\n</tbody></table>\n<h2 id=\"GUI编程\"><a href=\"#GUI编程\" class=\"headerlink\" title=\"*GUI编程\"></a>*GUI编程</h2><blockquote>\n<p>目前项目开发几乎不使用Java来开发GUI界面，仅了解</p>\n</blockquote>\n<p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"常见的Swing组件\"><a href=\"#常见的Swing组件\" class=\"headerlink\" title=\"常见的Swing组件\"></a>常见的Swing组件</h3><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"#jframe\">JFrame</a></td>\n<td>窗口</td>\n</tr>\n<tr>\n<td><a href=\"#jpanel\">JPanel</a></td>\n<td>面板，用于组织其他组件的容器</td>\n</tr>\n<tr>\n<td><a href=\"#jbutton\">JButton</a></td>\n<td>按钮</td>\n</tr>\n<tr>\n<td>JTextField</td>\n<td>文本输入框</td>\n</tr>\n<tr>\n<td>JTable</td>\n<td>表格</td>\n</tr>\n</tbody></table>\n<h3 id=\"JFrame\"><a href=\"#JFrame\" class=\"headerlink\" title=\"JFrame\"></a>JFrame</h3><table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void setSize(int width, int height)</code></td>\n<td>设置窗口大小</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void setLocationRelativeTo(Component c)</code></td>\n<td>设置窗口位置</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void setDefaultCloseOperation(int operation)</code></td>\n<td>设置关闭方式</td>\n<td><code>JFrame.EXIT_ON_CLOSE</code> 关闭窗口时退出程序</td>\n</tr>\n<tr>\n<td><code>void setVisible(boolean b)</code></td>\n<td>设置窗口是否可见</td>\n<td></td>\n</tr>\n<tr>\n<td><code>void add(Component c)</code></td>\n<td>添加组件</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"JPanel\"><a href=\"#JPanel\" class=\"headerlink\" title=\"JPanel\"></a>JPanel</h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void add(Component c)</code></td>\n<td>添加组件</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"JButton\"><a href=\"#JButton\" class=\"headerlink\" title=\"JButton\"></a>JButton</h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>作用</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>void setText(String text)</code></td>\n<td>设置按钮文本</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"Layout-Manager\"><a href=\"#Layout-Manager\" class=\"headerlink\" title=\"Layout Manager\"></a>Layout Manager</h3><p><a href=\"#gui%E7%BC%96%E7%A8%8B\">back to GUI编程</a></p>\n<table>\n<thead>\n<tr>\n<th>Layout Manager</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BorderLayout</code></td>\n<td>边界布局，将容器分成5个区域，North、South、East、West、Center，每个区域只有一个组件</td>\n</tr>\n<tr>\n<td><code>FlowLayout</code></td>\n<td>流式布局，组件排满一行自动换行</td>\n</tr>\n<tr>\n<td><code>GridLayout</code></td>\n<td>网格布局，组件会自动填充</td>\n</tr>\n<tr>\n<td><code>GridBagLayout</code></td>\n<td>网格布局，组件会自动填充</td>\n</tr>\n</tbody></table>\n"},{"title":"Python笔记(持续更新中)","date":"2025-09-06T11:56:00.000Z","updated":"2025-09-26T03:34:36.105Z","cover":"https://kei-blog.oss-cn-beijing.aliyuncs.com/asset/130997637_p0-cut.jpg","_content":"\n<style>\n.table-container {\n  overflow-x: auto;\n  margin: 1em 0;\n}\n\ntable {\n  min-width: 100%;\n  display: block;\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\nth, td {\n  padding: 8px 12px;\n  text-align: left;\n  white-space: nowrap;\n}\n</style>\n\n# Python 笔记\n\n## 目录\n> 1. [列表 list](#列表-list)\n> 2. [元组 tuple](#元组-tuple)\n> 3. [字符串 string](#字符串-string)\n> 4. [集合 set](#集合-set)\n> 5. [字典 dict](#字典-dict)\n> 6. [容器 container](#容器-container)\n> 7. [文件 file](#文件)\n> 8. [正则表达式](#正则表达式)\n> 9. [异常 Exception](#异常-exception)\n> 10. [模块 module](#模块-module)\n> 11. [json](#json)\n> 12. [pyecharts](#pyecharts)\n> 13. [面向对象 OOP](#面向对象)\n\n\n## 列表 list\n\n[返回目录](#目录)\n\n### 列表方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回列表中指定元素的索引|`索引`,item不存在返回`error`|\n|`insert(index,item)`|在列表指定位置插入元素，此位置后的元素右移|`None`|\n|`append(item)`|在列表末尾添加元素|`None`|\n|`extend(list)`|在列表末尾添加列表元素|`None`|\n|`del list[index]`|删除列表指定位置的元素|`None`|\n|`pop(index)`|删除列表指定位置的元素，并返回该元素|`元素`|\n|`remove(item)`|删除列表中指定元素的第一个匹配项|`None`|\n|`clear()`|清空列表|`None`|\n|`count(item)`|返回列表中指定元素的个数|`个数`|\n|`len(list)`|返回列表的长度|`长度`|\n|`reverse()`|列表倒序|`None`|\n|**`list[begin:end:step]`**|切片，返回列表指定范围的元素|`列表`|\n\n</div>\n\n\n## 元组 tuple\n\n[返回目录](#目录)\n\n### 元组方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回元组中指定元素的索引|`索引`,item不存在返回`error`|\n|`count(item)`|返回元组中指定元素的个数|`个数`|\n|`len(tuple)`|返回元组的长度|`长度`|\n|**`tuple[begin:end:step]`**|切片，返回元组指定范围的元素|`元组`|\n\n</div>\n\n\n### 注意事项\n1. 元组不可变，不能添加、删除、修改元素\n2. 元组中的列表仍然可变，原因在于元组中的列表属于引用类型，列表属于对象，对象都是引用类型\n\n\n## 字符串 string\n\n[返回目录](#目录)\n\n### 字符串方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回字符串中指定元素起始位置的索引|`索引`,item不存在返回`error`|\n|`replace(old,new)`|替换字符串中指定元素，原字符串不变|`替换后的字符串`|\n|`split(sep)`|将字符串按指定分隔符分隔，返回列表|`列表`|\n|`strip([chars])`|去除字符串头尾的指定字符，默认参数为`空格`|`字符串`|\n|`count(item)`|返回字符串中指定元素的个数|`个数`|\n|`len(string)`|返回字符串的长度|`长度`|\n|**`string[begin:end:step]`**|切片，返回字符串指定范围的元素|`字符串`|\n\n</div>\n\n\n### 注意事项\n1. 字符串不可变，不能添加、删除、修改元素\n\n## 集合 set\n\n[返回目录](#目录)\n\n### 集合方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`add(item)`|添加元素|`None`|\n|`remove(item)`|删除元素|`None`|\n|`pop()`|删除并返回集合中的第一个元素|`元素`|\n|`clear()`|清空集合|`None`|\n|`difference(set)`|返回两个集合的差集，即主类有而参数类没有的元素|`集合`|\n|`difference_update(set)`|删除两个集合的交集元素，主类改变而参数类不变|`None`|\n|`union(set)`|返回两个集合的并集，该并集是新集合，原集合不变|`集合`|\n|`len(set)`|返回集合的长度|`长度`|\n\n</div>\n\n### 注意事项\n1. 集合中的元素不能重复\n2. 集合是无序的，不能通过索引访问元素\n\n## 字典 dict\n\n[返回目录](#目录)\n\n### 字典方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`dict[key] = value`|添加元素，若key已存在，则更新value|`None`|\n|`pop(key)`|删除指定key的元素，并返回该元素|`元素`|\n|`clear()`|清空字典|`None`|\n|`keys()`|返回字典中所有key的列表|`列表`|\n|`len(dict)`|返回字典的长度|`长度`|\n\n</div>\n\n## 容器 container\n\n[返回目录](#目录)\n\nlist,tuple,string,set,dict都是容器\n\n### 容器通用方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`len(container)`|返回容器的长度|`长度`|\n|`max(container)`|返回容器中的最大值|`最大值`|\n|`min(container)`|返回容器中的最小值|`最小值`|\n|`sorted(container, [reverse=False])`|返回容器中的排序后的元素，reverse为True时，返回排序后的元素逆序|`排序后的元素list`|\n\n</div>\n\n### 容器类型转换\n1. 转`list`：字典中的**key值**转为list元素；字符串的每个**字符**转为list元素\n2. 转`tuple`：字典中的**key值**转为tuple元素；字符串的每个**字符**转为tuple元素\n3. 转`set`：字典中的**key值**转为set元素；字符串的每个**字符**转为set元素\n\n\n## 文件\n\n[返回目录](#目录)\n\n### 文件的读取\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`open(filename, mode='<r>', encoding='<utf-8>')`|打开文件|`文件对象`|filename: 文件名或文件路径 <br> mode: 文件打开模式 <br> encoding: 文件编码 <br> `r`: 只读模式 <br> `w`: 只写模式，同名文件存在则覆盖，不存在则创建 <br> `a`: 追加模式，同名文件存在则追加，不存在则创建|\n|`with open(filename, mode='<r>', encoding='<utf-8>') as f:`|打开文件，在运行完此语句块时自动关闭文件|`None`|f: `open()`返回的对象|\n|`file.read([size])`|读取文件内容|`文件内容`|size: 读取指定字节数，默认为-1，表示读取所有内容|\n|`file.readline()`|读取文件的一行内容|`行内容`|\n|`file.readlines()`|读取文件所有行内容|`行内容list`|\n|`for line in file:`|循环读取文件内容|`None`|\n|`file.close()`|关闭文件|`None`|\n\n### 文件的写入\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`file.write(string)`|写入文件内容，并不会立刻写入文件，而是先写入缓冲区|`None`|`string`: 要写入的内容|\n|`file.flush()`|将缓冲区中的内容写入文件，`close()`函数包含`flush()`功能|`None`|\n\n\n## 正则表达式\n\n[返回目录](#目录)\n\n### 常用元符号\n|正则表达式符号|含义|\n|---|---|\n|`.`|匹配任意字符，除了换行符|\n|`*`|匹配0个或多个前面的字符|\n|`+`|匹配1个或多个前面的字符|\n|`?`|匹配0个或1个前面的字符|\n|`^`|匹配字符串的开头|\n|`$`|匹配字符串的结尾|\n|`{n}`|匹配前一个字符n次|\n|`{n,m}`|匹配前一个字符n到m次|\n|`{n,}`|匹配前一个字符n次以上|\n\n### 字符类\n|字符类|含义|\n|---|---|\n|`[abc]`|匹配a或b或c|\n|`[^abc]`|匹配除了a或b或c之外的字符|\n|`[a-z]`|匹配a到z之间的任意字符|\n|`[A-Z]`|匹配A到Z之间的任意字符|\n|`[0-9]`|匹配0到9之间的任意字符|\n|`\\d`|匹配数字|\n|`\\w`|匹配字母、数字、下划线|\n|`\\s`|匹配空白字符|\n\n\n## 异常 Exception\n\n[返回目录](#目录)\n\n### 捕获异常\n~~~python\ntry:\n    # 有可能抛出异常的代码段\nexcept [(NameError, ZeroDivisionError, ...) as e]:\n    # 捕获对应类型的异常，默认所有异常\n    # 异常处理代码段\n[else:\n    \"\"\"\n    没有异常时执行代码段\n    \"\"\"\n]\n[finally:\n    \"\"\"\n     finally代码段，无论是否有异常，都会执行\n    \"\"\"\n]\n~~~\n\n### 异常的类型\n> 详细请查阅官方文档：[Python异常处理](https://docs.python.org/3/library/exceptions.html#Exception)\n\n\n|异常类型|描述|父类|\n|---|---|---|\n|`Exception`|所有异常的基类|`object`|\n|`ArithmeticError`|数学运算异常|`Exception`|\n|`OverflowError`|算术运算溢出异常|`ArithmeticError`|\n|`ZeroDivisionError`|除数为0异常|`ArithmeticError`|\n|`FloatingPointError`|浮点数异常|`ArithmeticError`|\n|`AssertionError`|断言异常|`Exception`|\n|`AttributeError`|属性异常|`Exception`|\n|`BufferError`|缓冲区异常|`Exception`|\n|`EOFError`|文件结束异常|`Exception`|\n|`ImportError`|导入异常|`Exception`|\n|`ModuleNotFoundError`|模块未找到异常|`ImportError`|\n|`IndexError`|索引异常，下标超出范围|`Exception`|\n|`KeyError`|键异常，键集中找不到映射|`Exception`|\n|`LookupError`|查找异常|`Exception`|\n|`MemoryError`|内存异常|`Exception`|\n|`NameError`|名称异常，变量未定义|`Exception`|\n|`NotImplementedError`|未实现异常|`Exception`|\n|`OSError`|操作系统异常|`Exception`|\n|`OverflowError`|算术运算溢出异常|`ArithmeticError`|\n\n\n## 模块 module\n\n[返回目录](#目录)\n\n模块是Python代码文件，模块名就是文件名，其中定义了模块的变量、函数、类等，也可以包含可执行的代码\n\n### 导入模块\n~~~python\n# from 模块名 import 变量名 后续可以直接使用变量名\n# import 模块名 后续必须使用模块名.变量名\n[from 模块名] import <模块变量|模块函数|模块类|*> [as 别名]\n~~~\n\n### 注意事项\n1. 不同模块的同名函数，后导入的会覆盖先导入的\n2. `__main__`变量在模块中可以直接运行，测试函数功能，但在导入模块中，`__main__`变量会失效\n3. `__all__`变量，在模块或**__init__.py**中定义，用于指定模块的成员，只有被指定成员导入时，才会被`*`导入，未被指定只能使用变量名导入\n~~~python\n# __all__变量指定的语法\n__all__ = ['变量名', '函数名', '类名']\n~~~\n\n### Python 包 package\n包是模块的集合，包名就是文件夹名，包中的模块名就是文件夹中的文件名\n#### 创建包\n1. 创建文件夹，文件夹名就是包名\n2. 在文件夹中创建**__init__.py__**文件\n\n### 第三方包\n|语法|描述|\n|---|---|\n|`pip install 包名`|安装包|\n\n\n## json\n[返回目录](#目录)\n\n本质上是能在不同编程语言中互操作的数据格式，在python中为字符串\n~~~python\nimport json\n~~~\n### json相关操作\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`json.dumps(obj, ensure_ascii=False, indent=4)`|将Python对象转换为json字符串|`json字符串`|obj: 要转换的Python对象，可以是**字典**和嵌套字典的**列表** <br> ensure_ascii: 是否转义非ASCII字符，中文显示需要设置False <br> indent: 缩进级别|\n|`json.loads(json_str)`|将json字符串转换为Python对象|`Python对象`|json_str: 要转换的json字符串|\n\n## pyecharts\n[返回目录](#目录)\n\n[官方文档](https://gallery.pyecharts.org/#/Line/README)\n\n~~~bash\npip install pyecharts\n~~~\n\n~~~python\nfrom pyecharts[.<选项>] import <包名> [as <别名>]\n~~~\n\n### 全局配置选项\n[官方文档](https://pyecharts.org/#/zh-cn/global_options)\n~~~python\nline.set_global_opts(\n  title_opts=opts.TitleOpts(title=\"GDP\"),\n  ...\n)\n~~~\n|参数|描述|构造参数|参数说明|\n|---|---|---|---|\n|`title_opts`|标题配置项|opts.TitleOpts(title=\"GDP\")|title: 标题名称|\n|`legend_opts`|图例配置项|opts.LegendOpts(is_show=False)|is_show: 是否显示图例|\n|`tooltip_opts`|提示框配置项|opts.TooltipOpts(is_show=True)|is_show: 是否显示提示框|\n|`toolbox_opts`|工具箱配置项|opts.ToolboxOpts(is_show=True)|is_show: 是否显示工具箱|\n|`visualmap_opts`|视觉映射配置项|opts.VisualMapOpts(is_show=True)|is_show: 是否显示视觉映射|\n\n\n\n### 基础折线图\n\n~~~python\n# 绘制基础折线图\n\n## 导包\nfrom pyecharts.charts import Line\n\n## 得到折线图对象\nline = Line()\n\n## 添加数据\n### x轴数据\nline.add_xaxis([\"中国\", \"美国\", \"日本\", \"印度\", \"法国\", \"英国\", \"俄罗斯\", \"意大利\", \"德国\", \"西班牙\"])\n### y轴数据\nline.add_yaxis(\"GDP\", [30, 25, 20, 15, 10, 5, 2, 1, 0.5, 0.1])\n\n## 设置全局配置选项\nline.set_global_opts(\n    title_opts=opts.TitleOpts(title=\"GDP\"),\n    tooltip_opts=opts.TooltipOpts(is_show=True),\n    legend_opts=opts.LegendOpts(is_show=True),\n    toolbox_opts=opts.ToolboxOpts(is_show=True),\n    visualmap_opts=opts.VisualMapOpts(is_show=True)\n)\n\n## 生成图表\nline.render()\n~~~\n\n\n## 面向对象\n[返回目录](#目录)\n\n### 类\n基本结构：\n~~~python\nclass Student:\n    # 成员变量\n    name = None\n    age = None\n    gender = None\n    \n    # 成员方法，必须有self参数，表示当前对象\n    def showname(self):\n        print(self.name)\n~~~\n构造方法：\n~~~python\n# 构造方法\n    def __init__(self, name, gender, age):\n        self.name = name\n        self.gender = gender\n        self.age = age\n        print(\"创建一个学生对象\")\n~~~\n魔术方法：\n|方法|描述|参数列表|返回值|\n|---|---|---|---|\n|`__init__(self, *args, **kwargs)`|构造方法|`self`: 当前对象 <br> `*args`: 可变参数 <br> `**kwargs`: 关键字参数|无|\n|`__str__(self)`|对象转字符串|`self`: 当前对象|字符串|\n|`__lt__(self, other)`|重写小于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n|`__le__(self, other)`|重写小于等于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n|`__eq__(self, other)`|重写等于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n\n~~~python\n    # 魔术方法\n    ## __str__(): 返回对象的字符串表示\n    def __str__(self):\n        return \"name=%s,gender=%s,age=%s\" % (self.name, self.gender, self.age)\n    \n    ## __lt__(): 用于类对象的小于比较(less than)\n    def __lt__(self, other):\n        return self.age < other.age\n    \n    ## __le__(): 用于类对象的小于等于比较(less than or equal)\n    def __le__(self, other):\n        return self.age <= other.age\n    \n    ## __eq__(): 用于类对象的等于比较(equal)，默认\"==\"比较的是内存地址\n    def __eq__(self, other):\n        return self.age == other.age\n~~~\n\n### 类的封装\n**封装**：封装就是将**属性或方法私有化**，属性或方法私有化后，外部无法直接访问属性或方法，只能通过方法访问属性或方法\n\n语法：\n属性私有化：`__属性名`\n方法私有化：`__方法名()`\n受保护属性：`_属性名`\n受保护方法：`_方法名()`\n\n~~~python\nclass Student:\n    # 私有成员变量\n    __name = None\n    __age = None\n    __sex = None\n    \n    def __init__(self, name, age, sex):\n        self.__name = name\n        self.__age = age\n        self.__sex = sex\n    \n    def show(self):\n        print(\"姓名：%s, 年龄：%d, 性别：%s\" % (self.__name, self.__age, self.__sex))\n    \n    def getName(self):\n        return self.__name\n    \n    def getAge(self):\n        return self.__age\n    \n    def getSex(self):\n        return self.__sex\n    \n    # 私有成员方法\n    def __setName(self, name):\n        self.__name = name\n    \n    def __setAge(self, age):\n        self.__age = age\n        \n    def __setSex(self, sex):\n        self.__sex = sex\n~~~\n\n### 类的继承\n继承：子类继承父类的属性和方法，并添加新的属性和方法\n1. 不同于Java语言，Python语言支持多继承\n2. 多继承时，父类同名属性或方法，会按照从左到右的顺序进行覆盖，即左边优先级更大\n3. 子类只继承父类的**公有**或**受保护**属性和方法，不会继承父类的私有属性或方法\n4. 父类的私有属性或方法，子类无法直接访问，需通过父类方法进行访问\n5. 子类可以**重写**父类的同名方法\n\n语法：\n1. 继承：`class 子类名(父类名1[, 父类名2, ...]):`\n\n2. 调用：`super().[属性或方法名(参数)]`或`父类名.方法名(self, 参数)`\n\n### 类的多态\n* 子类继承父类，并重写父类的同名方法\n* 函数参数可以指定父类对象，调用时传入子类对象\n* 通过调用不同子类的同名方法，实现多态\n* 父类可以声明一个抽象方法，子类必须实现该抽象方法\n~~~python\n# 多态\nclass Animal:\n    def cry(self):\n        print(\"动物叫\")\n    \n    # 父类可以定义抽象方法 子类必须实现抽象方法\n    def eat(self):\n        pass\n        \nclass Dog(Animal):\n    # 重写父类的方法\n    def cry(self):\n        print(\"汪汪汪\")\n    \n    # 重写父类抽象方法\n    def eat(self):\n        print(\"大狗嚼嚼嚼\")\n        \nclass Cat(Animal):\n    # 重写父类方法\n    def cry(self):\n        print(\"喵喵喵\")\n        \n    # 重写父类抽象方法\n    def eat(self):\n        print(\"吃吃吃\")\n        \n# 定义一个方法 接收一个父类对象\ndef print_cry(animal: Animal):\n    animal.cry()\n    \ndef print_eat(animal: Animal):\n    animal.eat()\n        \n        \ndog = Dog()\ncat = Cat()\n\n# 传入不同子类 调用不同的方法\nprint_cry(dog)\nprint_cry(cat)\n\nprint_eat(dog)\nprint_eat(cat)\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/PythonTips.md","raw":"---\ntitle: \"Python笔记(持续更新中)\"\ndate: 2025/09/06 19:56:00\ntags: Python\nupdated:\ncover: https://kei-blog.oss-cn-beijing.aliyuncs.com/asset/130997637_p0-cut.jpg\ncategories:\n  - 编程语言\n---\n\n<style>\n.table-container {\n  overflow-x: auto;\n  margin: 1em 0;\n}\n\ntable {\n  min-width: 100%;\n  display: block;\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\nth, td {\n  padding: 8px 12px;\n  text-align: left;\n  white-space: nowrap;\n}\n</style>\n\n# Python 笔记\n\n## 目录\n> 1. [列表 list](#列表-list)\n> 2. [元组 tuple](#元组-tuple)\n> 3. [字符串 string](#字符串-string)\n> 4. [集合 set](#集合-set)\n> 5. [字典 dict](#字典-dict)\n> 6. [容器 container](#容器-container)\n> 7. [文件 file](#文件)\n> 8. [正则表达式](#正则表达式)\n> 9. [异常 Exception](#异常-exception)\n> 10. [模块 module](#模块-module)\n> 11. [json](#json)\n> 12. [pyecharts](#pyecharts)\n> 13. [面向对象 OOP](#面向对象)\n\n\n## 列表 list\n\n[返回目录](#目录)\n\n### 列表方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回列表中指定元素的索引|`索引`,item不存在返回`error`|\n|`insert(index,item)`|在列表指定位置插入元素，此位置后的元素右移|`None`|\n|`append(item)`|在列表末尾添加元素|`None`|\n|`extend(list)`|在列表末尾添加列表元素|`None`|\n|`del list[index]`|删除列表指定位置的元素|`None`|\n|`pop(index)`|删除列表指定位置的元素，并返回该元素|`元素`|\n|`remove(item)`|删除列表中指定元素的第一个匹配项|`None`|\n|`clear()`|清空列表|`None`|\n|`count(item)`|返回列表中指定元素的个数|`个数`|\n|`len(list)`|返回列表的长度|`长度`|\n|`reverse()`|列表倒序|`None`|\n|**`list[begin:end:step]`**|切片，返回列表指定范围的元素|`列表`|\n\n</div>\n\n\n## 元组 tuple\n\n[返回目录](#目录)\n\n### 元组方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回元组中指定元素的索引|`索引`,item不存在返回`error`|\n|`count(item)`|返回元组中指定元素的个数|`个数`|\n|`len(tuple)`|返回元组的长度|`长度`|\n|**`tuple[begin:end:step]`**|切片，返回元组指定范围的元素|`元组`|\n\n</div>\n\n\n### 注意事项\n1. 元组不可变，不能添加、删除、修改元素\n2. 元组中的列表仍然可变，原因在于元组中的列表属于引用类型，列表属于对象，对象都是引用类型\n\n\n## 字符串 string\n\n[返回目录](#目录)\n\n### 字符串方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`index(item)`|返回字符串中指定元素起始位置的索引|`索引`,item不存在返回`error`|\n|`replace(old,new)`|替换字符串中指定元素，原字符串不变|`替换后的字符串`|\n|`split(sep)`|将字符串按指定分隔符分隔，返回列表|`列表`|\n|`strip([chars])`|去除字符串头尾的指定字符，默认参数为`空格`|`字符串`|\n|`count(item)`|返回字符串中指定元素的个数|`个数`|\n|`len(string)`|返回字符串的长度|`长度`|\n|**`string[begin:end:step]`**|切片，返回字符串指定范围的元素|`字符串`|\n\n</div>\n\n\n### 注意事项\n1. 字符串不可变，不能添加、删除、修改元素\n\n## 集合 set\n\n[返回目录](#目录)\n\n### 集合方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`add(item)`|添加元素|`None`|\n|`remove(item)`|删除元素|`None`|\n|`pop()`|删除并返回集合中的第一个元素|`元素`|\n|`clear()`|清空集合|`None`|\n|`difference(set)`|返回两个集合的差集，即主类有而参数类没有的元素|`集合`|\n|`difference_update(set)`|删除两个集合的交集元素，主类改变而参数类不变|`None`|\n|`union(set)`|返回两个集合的并集，该并集是新集合，原集合不变|`集合`|\n|`len(set)`|返回集合的长度|`长度`|\n\n</div>\n\n### 注意事项\n1. 集合中的元素不能重复\n2. 集合是无序的，不能通过索引访问元素\n\n## 字典 dict\n\n[返回目录](#目录)\n\n### 字典方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`dict[key] = value`|添加元素，若key已存在，则更新value|`None`|\n|`pop(key)`|删除指定key的元素，并返回该元素|`元素`|\n|`clear()`|清空字典|`None`|\n|`keys()`|返回字典中所有key的列表|`列表`|\n|`len(dict)`|返回字典的长度|`长度`|\n\n</div>\n\n## 容器 container\n\n[返回目录](#目录)\n\nlist,tuple,string,set,dict都是容器\n\n### 容器通用方法\n<div class=\"table-container\">\n\n|方法|描述|返回值|\n|---|---|---|\n|`len(container)`|返回容器的长度|`长度`|\n|`max(container)`|返回容器中的最大值|`最大值`|\n|`min(container)`|返回容器中的最小值|`最小值`|\n|`sorted(container, [reverse=False])`|返回容器中的排序后的元素，reverse为True时，返回排序后的元素逆序|`排序后的元素list`|\n\n</div>\n\n### 容器类型转换\n1. 转`list`：字典中的**key值**转为list元素；字符串的每个**字符**转为list元素\n2. 转`tuple`：字典中的**key值**转为tuple元素；字符串的每个**字符**转为tuple元素\n3. 转`set`：字典中的**key值**转为set元素；字符串的每个**字符**转为set元素\n\n\n## 文件\n\n[返回目录](#目录)\n\n### 文件的读取\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`open(filename, mode='<r>', encoding='<utf-8>')`|打开文件|`文件对象`|filename: 文件名或文件路径 <br> mode: 文件打开模式 <br> encoding: 文件编码 <br> `r`: 只读模式 <br> `w`: 只写模式，同名文件存在则覆盖，不存在则创建 <br> `a`: 追加模式，同名文件存在则追加，不存在则创建|\n|`with open(filename, mode='<r>', encoding='<utf-8>') as f:`|打开文件，在运行完此语句块时自动关闭文件|`None`|f: `open()`返回的对象|\n|`file.read([size])`|读取文件内容|`文件内容`|size: 读取指定字节数，默认为-1，表示读取所有内容|\n|`file.readline()`|读取文件的一行内容|`行内容`|\n|`file.readlines()`|读取文件所有行内容|`行内容list`|\n|`for line in file:`|循环读取文件内容|`None`|\n|`file.close()`|关闭文件|`None`|\n\n### 文件的写入\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`file.write(string)`|写入文件内容，并不会立刻写入文件，而是先写入缓冲区|`None`|`string`: 要写入的内容|\n|`file.flush()`|将缓冲区中的内容写入文件，`close()`函数包含`flush()`功能|`None`|\n\n\n## 正则表达式\n\n[返回目录](#目录)\n\n### 常用元符号\n|正则表达式符号|含义|\n|---|---|\n|`.`|匹配任意字符，除了换行符|\n|`*`|匹配0个或多个前面的字符|\n|`+`|匹配1个或多个前面的字符|\n|`?`|匹配0个或1个前面的字符|\n|`^`|匹配字符串的开头|\n|`$`|匹配字符串的结尾|\n|`{n}`|匹配前一个字符n次|\n|`{n,m}`|匹配前一个字符n到m次|\n|`{n,}`|匹配前一个字符n次以上|\n\n### 字符类\n|字符类|含义|\n|---|---|\n|`[abc]`|匹配a或b或c|\n|`[^abc]`|匹配除了a或b或c之外的字符|\n|`[a-z]`|匹配a到z之间的任意字符|\n|`[A-Z]`|匹配A到Z之间的任意字符|\n|`[0-9]`|匹配0到9之间的任意字符|\n|`\\d`|匹配数字|\n|`\\w`|匹配字母、数字、下划线|\n|`\\s`|匹配空白字符|\n\n\n## 异常 Exception\n\n[返回目录](#目录)\n\n### 捕获异常\n~~~python\ntry:\n    # 有可能抛出异常的代码段\nexcept [(NameError, ZeroDivisionError, ...) as e]:\n    # 捕获对应类型的异常，默认所有异常\n    # 异常处理代码段\n[else:\n    \"\"\"\n    没有异常时执行代码段\n    \"\"\"\n]\n[finally:\n    \"\"\"\n     finally代码段，无论是否有异常，都会执行\n    \"\"\"\n]\n~~~\n\n### 异常的类型\n> 详细请查阅官方文档：[Python异常处理](https://docs.python.org/3/library/exceptions.html#Exception)\n\n\n|异常类型|描述|父类|\n|---|---|---|\n|`Exception`|所有异常的基类|`object`|\n|`ArithmeticError`|数学运算异常|`Exception`|\n|`OverflowError`|算术运算溢出异常|`ArithmeticError`|\n|`ZeroDivisionError`|除数为0异常|`ArithmeticError`|\n|`FloatingPointError`|浮点数异常|`ArithmeticError`|\n|`AssertionError`|断言异常|`Exception`|\n|`AttributeError`|属性异常|`Exception`|\n|`BufferError`|缓冲区异常|`Exception`|\n|`EOFError`|文件结束异常|`Exception`|\n|`ImportError`|导入异常|`Exception`|\n|`ModuleNotFoundError`|模块未找到异常|`ImportError`|\n|`IndexError`|索引异常，下标超出范围|`Exception`|\n|`KeyError`|键异常，键集中找不到映射|`Exception`|\n|`LookupError`|查找异常|`Exception`|\n|`MemoryError`|内存异常|`Exception`|\n|`NameError`|名称异常，变量未定义|`Exception`|\n|`NotImplementedError`|未实现异常|`Exception`|\n|`OSError`|操作系统异常|`Exception`|\n|`OverflowError`|算术运算溢出异常|`ArithmeticError`|\n\n\n## 模块 module\n\n[返回目录](#目录)\n\n模块是Python代码文件，模块名就是文件名，其中定义了模块的变量、函数、类等，也可以包含可执行的代码\n\n### 导入模块\n~~~python\n# from 模块名 import 变量名 后续可以直接使用变量名\n# import 模块名 后续必须使用模块名.变量名\n[from 模块名] import <模块变量|模块函数|模块类|*> [as 别名]\n~~~\n\n### 注意事项\n1. 不同模块的同名函数，后导入的会覆盖先导入的\n2. `__main__`变量在模块中可以直接运行，测试函数功能，但在导入模块中，`__main__`变量会失效\n3. `__all__`变量，在模块或**__init__.py**中定义，用于指定模块的成员，只有被指定成员导入时，才会被`*`导入，未被指定只能使用变量名导入\n~~~python\n# __all__变量指定的语法\n__all__ = ['变量名', '函数名', '类名']\n~~~\n\n### Python 包 package\n包是模块的集合，包名就是文件夹名，包中的模块名就是文件夹中的文件名\n#### 创建包\n1. 创建文件夹，文件夹名就是包名\n2. 在文件夹中创建**__init__.py__**文件\n\n### 第三方包\n|语法|描述|\n|---|---|\n|`pip install 包名`|安装包|\n\n\n## json\n[返回目录](#目录)\n\n本质上是能在不同编程语言中互操作的数据格式，在python中为字符串\n~~~python\nimport json\n~~~\n### json相关操作\n|方法|描述|返回值|参数说明|\n|---|---|---|---|\n|`json.dumps(obj, ensure_ascii=False, indent=4)`|将Python对象转换为json字符串|`json字符串`|obj: 要转换的Python对象，可以是**字典**和嵌套字典的**列表** <br> ensure_ascii: 是否转义非ASCII字符，中文显示需要设置False <br> indent: 缩进级别|\n|`json.loads(json_str)`|将json字符串转换为Python对象|`Python对象`|json_str: 要转换的json字符串|\n\n## pyecharts\n[返回目录](#目录)\n\n[官方文档](https://gallery.pyecharts.org/#/Line/README)\n\n~~~bash\npip install pyecharts\n~~~\n\n~~~python\nfrom pyecharts[.<选项>] import <包名> [as <别名>]\n~~~\n\n### 全局配置选项\n[官方文档](https://pyecharts.org/#/zh-cn/global_options)\n~~~python\nline.set_global_opts(\n  title_opts=opts.TitleOpts(title=\"GDP\"),\n  ...\n)\n~~~\n|参数|描述|构造参数|参数说明|\n|---|---|---|---|\n|`title_opts`|标题配置项|opts.TitleOpts(title=\"GDP\")|title: 标题名称|\n|`legend_opts`|图例配置项|opts.LegendOpts(is_show=False)|is_show: 是否显示图例|\n|`tooltip_opts`|提示框配置项|opts.TooltipOpts(is_show=True)|is_show: 是否显示提示框|\n|`toolbox_opts`|工具箱配置项|opts.ToolboxOpts(is_show=True)|is_show: 是否显示工具箱|\n|`visualmap_opts`|视觉映射配置项|opts.VisualMapOpts(is_show=True)|is_show: 是否显示视觉映射|\n\n\n\n### 基础折线图\n\n~~~python\n# 绘制基础折线图\n\n## 导包\nfrom pyecharts.charts import Line\n\n## 得到折线图对象\nline = Line()\n\n## 添加数据\n### x轴数据\nline.add_xaxis([\"中国\", \"美国\", \"日本\", \"印度\", \"法国\", \"英国\", \"俄罗斯\", \"意大利\", \"德国\", \"西班牙\"])\n### y轴数据\nline.add_yaxis(\"GDP\", [30, 25, 20, 15, 10, 5, 2, 1, 0.5, 0.1])\n\n## 设置全局配置选项\nline.set_global_opts(\n    title_opts=opts.TitleOpts(title=\"GDP\"),\n    tooltip_opts=opts.TooltipOpts(is_show=True),\n    legend_opts=opts.LegendOpts(is_show=True),\n    toolbox_opts=opts.ToolboxOpts(is_show=True),\n    visualmap_opts=opts.VisualMapOpts(is_show=True)\n)\n\n## 生成图表\nline.render()\n~~~\n\n\n## 面向对象\n[返回目录](#目录)\n\n### 类\n基本结构：\n~~~python\nclass Student:\n    # 成员变量\n    name = None\n    age = None\n    gender = None\n    \n    # 成员方法，必须有self参数，表示当前对象\n    def showname(self):\n        print(self.name)\n~~~\n构造方法：\n~~~python\n# 构造方法\n    def __init__(self, name, gender, age):\n        self.name = name\n        self.gender = gender\n        self.age = age\n        print(\"创建一个学生对象\")\n~~~\n魔术方法：\n|方法|描述|参数列表|返回值|\n|---|---|---|---|\n|`__init__(self, *args, **kwargs)`|构造方法|`self`: 当前对象 <br> `*args`: 可变参数 <br> `**kwargs`: 关键字参数|无|\n|`__str__(self)`|对象转字符串|`self`: 当前对象|字符串|\n|`__lt__(self, other)`|重写小于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n|`__le__(self, other)`|重写小于等于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n|`__eq__(self, other)`|重写等于，用于对象某一规则的比较|`self`: 当前对象 <br> `other`: 其他对象|布尔值|\n\n~~~python\n    # 魔术方法\n    ## __str__(): 返回对象的字符串表示\n    def __str__(self):\n        return \"name=%s,gender=%s,age=%s\" % (self.name, self.gender, self.age)\n    \n    ## __lt__(): 用于类对象的小于比较(less than)\n    def __lt__(self, other):\n        return self.age < other.age\n    \n    ## __le__(): 用于类对象的小于等于比较(less than or equal)\n    def __le__(self, other):\n        return self.age <= other.age\n    \n    ## __eq__(): 用于类对象的等于比较(equal)，默认\"==\"比较的是内存地址\n    def __eq__(self, other):\n        return self.age == other.age\n~~~\n\n### 类的封装\n**封装**：封装就是将**属性或方法私有化**，属性或方法私有化后，外部无法直接访问属性或方法，只能通过方法访问属性或方法\n\n语法：\n属性私有化：`__属性名`\n方法私有化：`__方法名()`\n受保护属性：`_属性名`\n受保护方法：`_方法名()`\n\n~~~python\nclass Student:\n    # 私有成员变量\n    __name = None\n    __age = None\n    __sex = None\n    \n    def __init__(self, name, age, sex):\n        self.__name = name\n        self.__age = age\n        self.__sex = sex\n    \n    def show(self):\n        print(\"姓名：%s, 年龄：%d, 性别：%s\" % (self.__name, self.__age, self.__sex))\n    \n    def getName(self):\n        return self.__name\n    \n    def getAge(self):\n        return self.__age\n    \n    def getSex(self):\n        return self.__sex\n    \n    # 私有成员方法\n    def __setName(self, name):\n        self.__name = name\n    \n    def __setAge(self, age):\n        self.__age = age\n        \n    def __setSex(self, sex):\n        self.__sex = sex\n~~~\n\n### 类的继承\n继承：子类继承父类的属性和方法，并添加新的属性和方法\n1. 不同于Java语言，Python语言支持多继承\n2. 多继承时，父类同名属性或方法，会按照从左到右的顺序进行覆盖，即左边优先级更大\n3. 子类只继承父类的**公有**或**受保护**属性和方法，不会继承父类的私有属性或方法\n4. 父类的私有属性或方法，子类无法直接访问，需通过父类方法进行访问\n5. 子类可以**重写**父类的同名方法\n\n语法：\n1. 继承：`class 子类名(父类名1[, 父类名2, ...]):`\n\n2. 调用：`super().[属性或方法名(参数)]`或`父类名.方法名(self, 参数)`\n\n### 类的多态\n* 子类继承父类，并重写父类的同名方法\n* 函数参数可以指定父类对象，调用时传入子类对象\n* 通过调用不同子类的同名方法，实现多态\n* 父类可以声明一个抽象方法，子类必须实现该抽象方法\n~~~python\n# 多态\nclass Animal:\n    def cry(self):\n        print(\"动物叫\")\n    \n    # 父类可以定义抽象方法 子类必须实现抽象方法\n    def eat(self):\n        pass\n        \nclass Dog(Animal):\n    # 重写父类的方法\n    def cry(self):\n        print(\"汪汪汪\")\n    \n    # 重写父类抽象方法\n    def eat(self):\n        print(\"大狗嚼嚼嚼\")\n        \nclass Cat(Animal):\n    # 重写父类方法\n    def cry(self):\n        print(\"喵喵喵\")\n        \n    # 重写父类抽象方法\n    def eat(self):\n        print(\"吃吃吃\")\n        \n# 定义一个方法 接收一个父类对象\ndef print_cry(animal: Animal):\n    animal.cry()\n    \ndef print_eat(animal: Animal):\n    animal.eat()\n        \n        \ndog = Dog()\ncat = Cat()\n\n# 传入不同子类 调用不同的方法\nprint_cry(dog)\nprint_cry(cat)\n\nprint_eat(dog)\nprint_eat(cat)\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"PythonTips","published":1,"_id":"cmf88q04a0003c4tl7ruk57xr","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head><style>\n.table-container {\n  overflow-x: auto;\n  margin: 1em 0;\n}\n\ntable {\n  min-width: 100%;\n  display: block;\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\nth, td {\n  padding: 8px 12px;\n  text-align: left;\n  white-space: nowrap;\n}\n</style>\n\n</head><body><h1><span id=\"python-%E7%AC%94%E8%AE%B0\">Python 笔记</span></h1><h2><span id=\"%E7%9B%AE%E5%BD%95\">目录</span></h2><blockquote>\n<ol>\n<li><a href=\"#%E5%88%97%E8%A1%A8-list\">列表 list</a></li>\n<li><a href=\"#%E5%85%83%E7%BB%84-tuple\">元组 tuple</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2-string\">字符串 string</a></li>\n<li><a href=\"#%E9%9B%86%E5%90%88-set\">集合 set</a></li>\n<li><a href=\"#%E5%AD%97%E5%85%B8-dict\">字典 dict</a></li>\n<li><a href=\"#%E5%AE%B9%E5%99%A8-container\">容器 container</a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6\">文件 file</a></li>\n<li><a href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">正则表达式</a></li>\n<li><a href=\"#%E5%BC%82%E5%B8%B8-exception\">异常 Exception</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-module\">模块 module</a></li>\n<li><a href=\"#json\">json</a></li>\n<li><a href=\"#pyecharts\">pyecharts</a></li>\n<li><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">面向对象 OOP</a></li>\n</ol>\n</blockquote>\n<h2><span id=\"%E5%88%97%E8%A1%A8-list\">列表 list</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95\">列表方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回列表中指定元素的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>insert(index,item)</code></td>\n<td>在列表指定位置插入元素，此位置后的元素右移</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>append(item)</code></td>\n<td>在列表末尾添加元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>extend(list)</code></td>\n<td>在列表末尾添加列表元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>del list[index]</code></td>\n<td>删除列表指定位置的元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop(index)</code></td>\n<td>删除列表指定位置的元素，并返回该元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>remove(item)</code></td>\n<td>删除列表中指定元素的第一个匹配项</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空列表</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回列表中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(list)</code></td>\n<td>返回列表的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><code>reverse()</code></td>\n<td>列表倒序</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><strong><code>list[begin:end:step]</code></strong></td>\n<td>切片，返回列表指定范围的元素</td>\n<td><code>列表</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h2><span id=\"%E5%85%83%E7%BB%84-tuple\">元组 tuple</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%85%83%E7%BB%84%E6%96%B9%E6%B3%95\">元组方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回元组中指定元素的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回元组中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(tuple)</code></td>\n<td>返回元组的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><strong><code>tuple[begin:end:step]</code></strong></td>\n<td>切片，返回元组指定范围的元素</td>\n<td><code>元组</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li>元组不可变，不能添加、删除、修改元素</li>\n<li>元组中的列表仍然可变，原因在于元组中的列表属于引用类型，列表属于对象，对象都是引用类型</li>\n</ol>\n<h2><span id=\"%E5%AD%97%E7%AC%A6%E4%B8%B2-string\">字符串 string</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95\">字符串方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回字符串中指定元素起始位置的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>replace(old,new)</code></td>\n<td>替换字符串中指定元素，原字符串不变</td>\n<td><code>替换后的字符串</code></td>\n</tr>\n<tr>\n<td><code>split(sep)</code></td>\n<td>将字符串按指定分隔符分隔，返回列表</td>\n<td><code>列表</code></td>\n</tr>\n<tr>\n<td><code>strip([chars])</code></td>\n<td>去除字符串头尾的指定字符，默认参数为<code>空格</code></td>\n<td><code>字符串</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回字符串中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(string)</code></td>\n<td>返回字符串的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><strong><code>string[begin:end:step]</code></strong></td>\n<td>切片，返回字符串指定范围的元素</td>\n<td><code>字符串</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li>字符串不可变，不能添加、删除、修改元素</li>\n</ol>\n<h2><span id=\"%E9%9B%86%E5%90%88-set\">集合 set</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95\">集合方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>add(item)</code></td>\n<td>添加元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>remove(item)</code></td>\n<td>删除元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop()</code></td>\n<td>删除并返回集合中的第一个元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空集合</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>difference(set)</code></td>\n<td>返回两个集合的差集，即主类有而参数类没有的元素</td>\n<td><code>集合</code></td>\n</tr>\n<tr>\n<td><code>difference_update(set)</code></td>\n<td>删除两个集合的交集元素，主类改变而参数类不变</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>union(set)</code></td>\n<td>返回两个集合的并集，该并集是新集合，原集合不变</td>\n<td><code>集合</code></td>\n</tr>\n<tr>\n<td><code>len(set)</code></td>\n<td>返回集合的长度</td>\n<td><code>长度</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li>集合中的元素不能重复</li>\n<li>集合是无序的，不能通过索引访问元素</li>\n</ol>\n<h2><span id=\"%E5%AD%97%E5%85%B8-dict\">字典 dict</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95\">字典方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dict[key] = value</code></td>\n<td>添加元素，若key已存在，则更新value</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop(key)</code></td>\n<td>删除指定key的元素，并返回该元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空字典</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>keys()</code></td>\n<td>返回字典中所有key的列表</td>\n<td><code>列表</code></td>\n</tr>\n<tr>\n<td><code>len(dict)</code></td>\n<td>返回字典的长度</td>\n<td><code>长度</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h2><span id=\"%E5%AE%B9%E5%99%A8-container\">容器 container</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>list,tuple,string,set,dict都是容器</p>\n<h3><span id=\"%E5%AE%B9%E5%99%A8%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95\">容器通用方法</span></h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>len(container)</code></td>\n<td>返回容器的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><code>max(container)</code></td>\n<td>返回容器中的最大值</td>\n<td><code>最大值</code></td>\n</tr>\n<tr>\n<td><code>min(container)</code></td>\n<td>返回容器中的最小值</td>\n<td><code>最小值</code></td>\n</tr>\n<tr>\n<td><code>sorted(container, [reverse=False])</code></td>\n<td>返回容器中的排序后的元素，reverse为True时，返回排序后的元素逆序</td>\n<td><code>排序后的元素list</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h3><span id=\"%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\">容器类型转换</span></h3><ol>\n<li>转<code>list</code>：字典中的<strong>key值</strong>转为list元素；字符串的每个<strong>字符</strong>转为list元素</li>\n<li>转<code>tuple</code>：字典中的<strong>key值</strong>转为tuple元素；字符串的每个<strong>字符</strong>转为tuple元素</li>\n<li>转<code>set</code>：字典中的<strong>key值</strong>转为set元素；字符串的每个<strong>字符</strong>转为set元素</li>\n</ol>\n<h2><span id=\"%E6%96%87%E4%BB%B6\">文件</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96\">文件的读取</span></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>open(filename, mode='&lt;r&gt;', encoding='&lt;utf-8&gt;')</code></td>\n<td>打开文件</td>\n<td><code>文件对象</code></td>\n<td>filename: 文件名或文件路径 <br> mode: 文件打开模式 <br> encoding: 文件编码 <br> <code>r</code>: 只读模式 <br> <code>w</code>: 只写模式，同名文件存在则覆盖，不存在则创建 <br> <code>a</code>: 追加模式，同名文件存在则追加，不存在则创建</td>\n</tr>\n<tr>\n<td><code>with open(filename, mode='&lt;r&gt;', encoding='&lt;utf-8&gt;') as f:</code></td>\n<td>打开文件，在运行完此语句块时自动关闭文件</td>\n<td><code>None</code></td>\n<td>f: <code>open()</code>返回的对象</td>\n</tr>\n<tr>\n<td><code>file.read([size])</code></td>\n<td>读取文件内容</td>\n<td><code>文件内容</code></td>\n<td>size: 读取指定字节数，默认为-1，表示读取所有内容</td>\n</tr>\n<tr>\n<td><code>file.readline()</code></td>\n<td>读取文件的一行内容</td>\n<td><code>行内容</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>file.readlines()</code></td>\n<td>读取文件所有行内容</td>\n<td><code>行内容list</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>for line in file:</code></td>\n<td>循环读取文件内容</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>file.close()</code></td>\n<td>关闭文件</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3><span id=\"%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5\">文件的写入</span></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file.write(string)</code></td>\n<td>写入文件内容，并不会立刻写入文件，而是先写入缓冲区</td>\n<td><code>None</code></td>\n<td><code>string</code>: 要写入的内容</td>\n</tr>\n<tr>\n<td><code>file.flush()</code></td>\n<td>将缓冲区中的内容写入文件，<code>close()</code>函数包含<code>flush()</code>功能</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2><span id=\"%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">正则表达式</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E5%B8%B8%E7%94%A8%E5%85%83%E7%AC%A6%E5%8F%B7\">常用元符号</span></h3><table>\n<thead>\n<tr>\n<th>正则表达式符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.</code></td>\n<td>匹配任意字符，除了换行符</td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>匹配0个或多个前面的字符</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>匹配1个或多个前面的字符</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>匹配0个或1个前面的字符</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配字符串的开头</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配字符串的结尾</td>\n</tr>\n<tr>\n<td><code>{n}</code></td>\n<td>匹配前一个字符n次</td>\n</tr>\n<tr>\n<td><code>{n,m}</code></td>\n<td>匹配前一个字符n到m次</td>\n</tr>\n<tr>\n<td><code>{n,}</code></td>\n<td>匹配前一个字符n次以上</td>\n</tr>\n</tbody></table>\n<h3><span id=\"%E5%AD%97%E7%AC%A6%E7%B1%BB\">字符类</span></h3><table>\n<thead>\n<tr>\n<th>字符类</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[abc]</code></td>\n<td>匹配a或b或c</td>\n</tr>\n<tr>\n<td><code>[^abc]</code></td>\n<td>匹配除了a或b或c之外的字符</td>\n</tr>\n<tr>\n<td><code>[a-z]</code></td>\n<td>匹配a到z之间的任意字符</td>\n</tr>\n<tr>\n<td><code>[A-Z]</code></td>\n<td>匹配A到Z之间的任意字符</td>\n</tr>\n<tr>\n<td><code>[0-9]</code></td>\n<td>匹配0到9之间的任意字符</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>匹配字母、数字、下划线</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>匹配空白字符</td>\n</tr>\n</tbody></table>\n<h2><span id=\"%E5%BC%82%E5%B8%B8-exception\">异常 Exception</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8\">捕获异常</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    <span class=\"hljs-comment\"># 有可能抛出异常的代码段</span><br><span class=\"hljs-keyword\">except</span> [(NameError, ZeroDivisionError, ...) <span class=\"hljs-keyword\">as</span> e]:<br>    <span class=\"hljs-comment\"># 捕获对应类型的异常，默认所有异常</span><br>    <span class=\"hljs-comment\"># 异常处理代码段</span><br>[<span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">    没有异常时执行代码段</span><br><span class=\"hljs-string\">    \"\"\"</span><br>]<br>[<span class=\"hljs-keyword\">finally</span>:<br>    <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">     finally代码段，无论是否有异常，都会执行</span><br><span class=\"hljs-string\">    \"\"\"</span><br>]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%9E%8B\">异常的类型</span></h3><blockquote>\n<p>详细请查阅官方文档：<a href=\"https://docs.python.org/3/library/exceptions.html#Exception\">Python异常处理</a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>异常类型</th>\n<th>描述</th>\n<th>父类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Exception</code></td>\n<td>所有异常的基类</td>\n<td><code>object</code></td>\n</tr>\n<tr>\n<td><code>ArithmeticError</code></td>\n<td>数学运算异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OverflowError</code></td>\n<td>算术运算溢出异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>ZeroDivisionError</code></td>\n<td>除数为0异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>FloatingPointError</code></td>\n<td>浮点数异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>AssertionError</code></td>\n<td>断言异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>AttributeError</code></td>\n<td>属性异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>BufferError</code></td>\n<td>缓冲区异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>EOFError</code></td>\n<td>文件结束异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>ImportError</code></td>\n<td>导入异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>ModuleNotFoundError</code></td>\n<td>模块未找到异常</td>\n<td><code>ImportError</code></td>\n</tr>\n<tr>\n<td><code>IndexError</code></td>\n<td>索引异常，下标超出范围</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>KeyError</code></td>\n<td>键异常，键集中找不到映射</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>LookupError</code></td>\n<td>查找异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>MemoryError</code></td>\n<td>内存异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>NameError</code></td>\n<td>名称异常，变量未定义</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>NotImplementedError</code></td>\n<td>未实现异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OSError</code></td>\n<td>操作系统异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OverflowError</code></td>\n<td>算术运算溢出异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n</tbody></table>\n<h2><span id=\"%E6%A8%A1%E5%9D%97-module\">模块 module</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>模块是Python代码文件，模块名就是文件名，其中定义了模块的变量、函数、类等，也可以包含可执行的代码</p>\n<h3><span id=\"%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97\">导入模块</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># from 模块名 import 变量名 后续可以直接使用变量名</span><br><span class=\"hljs-comment\"># import 模块名 后续必须使用模块名.变量名</span><br>[<span class=\"hljs-keyword\">from</span> 模块名] <span class=\"hljs-keyword\">import</span> &lt;模块变量|模块函数|模块类|*&gt; [<span class=\"hljs-keyword\">as</span> 别名]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</span></h3><ol>\n<li>不同模块的同名函数，后导入的会覆盖先导入的</li>\n<li><code>__main__</code>变量在模块中可以直接运行，测试函数功能，但在导入模块中，<code>__main__</code>变量会失效</li>\n<li><code>__all__</code>变量，在模块或**<strong>init</strong>.py**中定义，用于指定模块的成员，只有被指定成员导入时，才会被<code>*</code>导入，未被指定只能使用变量名导入<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># __all__变量指定的语法</span><br>__all__ = [<span class=\"hljs-string\">'变量名'</span>, <span class=\"hljs-string\">'函数名'</span>, <span class=\"hljs-string\">'类名'</span>]<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3><span id=\"python-%E5%8C%85-package\">Python 包 package</span></h3><p>包是模块的集合，包名就是文件夹名，包中的模块名就是文件夹中的文件名</p>\n<h4><span id=\"%E5%88%9B%E5%BB%BA%E5%8C%85\">创建包</span></h4><ol>\n<li>创建文件夹，文件夹名就是包名</li>\n<li>在文件夹中创建**<strong>init</strong>.py__**文件</li>\n</ol>\n<h3><span id=\"%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85\">第三方包</span></h3><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pip install 包名</code></td>\n<td>安装包</td>\n</tr>\n</tbody></table>\n<h2><span id=\"json\">json</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>本质上是能在不同编程语言中互操作的数据格式，在python中为字符串</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> json<br></code></pre></td></tr></tbody></table></figure>\n<h3><span id=\"json%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C\">json相关操作</span></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>json.dumps(obj, ensure_ascii=False, indent=4)</code></td>\n<td>将Python对象转换为json字符串</td>\n<td><code>json字符串</code></td>\n<td>obj: 要转换的Python对象，可以是<strong>字典</strong>和嵌套字典的<strong>列表</strong> <br> ensure_ascii: 是否转义非ASCII字符，中文显示需要设置False <br> indent: 缩进级别</td>\n</tr>\n<tr>\n<td><code>json.loads(json_str)</code></td>\n<td>将json字符串转换为Python对象</td>\n<td><code>Python对象</code></td>\n<td>json_str: 要转换的json字符串</td>\n</tr>\n</tbody></table>\n<h2><span id=\"pyecharts\">pyecharts</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p><a href=\"https://gallery.pyecharts.org/#/Line/README\">官方文档</a></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pyecharts<br></code></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> pyecharts[.&lt;选项&gt;] <span class=\"hljs-keyword\">import</span> &lt;包名&gt; [<span class=\"hljs-keyword\">as</span> &lt;别名&gt;]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9\">全局配置选项</span></h3><p><a href=\"https://pyecharts.org/#/zh-cn/global_options\">官方文档</a></p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">line.set_global_opts(<br>  title_opts=opts.TitleOpts(title=<span class=\"hljs-string\">\"GDP\"</span>),<br>  ...<br>)<br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>构造参数</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>title_opts</code></td>\n<td>标题配置项</td>\n<td>opts.TitleOpts(title=\"GDP\")</td>\n<td>title: 标题名称</td>\n</tr>\n<tr>\n<td><code>legend_opts</code></td>\n<td>图例配置项</td>\n<td>opts.LegendOpts(is_show=False)</td>\n<td>is_show: 是否显示图例</td>\n</tr>\n<tr>\n<td><code>tooltip_opts</code></td>\n<td>提示框配置项</td>\n<td>opts.TooltipOpts(is_show=True)</td>\n<td>is_show: 是否显示提示框</td>\n</tr>\n<tr>\n<td><code>toolbox_opts</code></td>\n<td>工具箱配置项</td>\n<td>opts.ToolboxOpts(is_show=True)</td>\n<td>is_show: 是否显示工具箱</td>\n</tr>\n<tr>\n<td><code>visualmap_opts</code></td>\n<td>视觉映射配置项</td>\n<td>opts.VisualMapOpts(is_show=True)</td>\n<td>is_show: 是否显示视觉映射</td>\n</tr>\n</tbody></table>\n<h3><span id=\"%E5%9F%BA%E7%A1%80%E6%8A%98%E7%BA%BF%E5%9B%BE\">基础折线图</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 绘制基础折线图</span><br><br><span class=\"hljs-comment\">## 导包</span><br><span class=\"hljs-keyword\">from</span> pyecharts.charts <span class=\"hljs-keyword\">import</span> Line<br><br><span class=\"hljs-comment\">## 得到折线图对象</span><br>line = Line()<br><br><span class=\"hljs-comment\">## 添加数据</span><br><span class=\"hljs-comment\">### x轴数据</span><br>line.add_xaxis([<span class=\"hljs-string\">\"中国\"</span>, <span class=\"hljs-string\">\"美国\"</span>, <span class=\"hljs-string\">\"日本\"</span>, <span class=\"hljs-string\">\"印度\"</span>, <span class=\"hljs-string\">\"法国\"</span>, <span class=\"hljs-string\">\"英国\"</span>, <span class=\"hljs-string\">\"俄罗斯\"</span>, <span class=\"hljs-string\">\"意大利\"</span>, <span class=\"hljs-string\">\"德国\"</span>, <span class=\"hljs-string\">\"西班牙\"</span>])<br><span class=\"hljs-comment\">### y轴数据</span><br>line.add_yaxis(<span class=\"hljs-string\">\"GDP\"</span>, [<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.1</span>])<br><br><span class=\"hljs-comment\">## 设置全局配置选项</span><br>line.set_global_opts(<br>    title_opts=opts.TitleOpts(title=<span class=\"hljs-string\">\"GDP\"</span>),<br>    tooltip_opts=opts.TooltipOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    legend_opts=opts.LegendOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    toolbox_opts=opts.ToolboxOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    visualmap_opts=opts.VisualMapOpts(is_show=<span class=\"hljs-literal\">True</span>)<br>)<br><br><span class=\"hljs-comment\">## 生成图表</span><br>line.render()<br></code></pre></td></tr></tbody></table></figure>\n\n\n<h2><span id=\"%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">面向对象</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E7%B1%BB\">类</span></h3><p>基本结构：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>:<br>    <span class=\"hljs-comment\"># 成员变量</span><br>    name = <span class=\"hljs-literal\">None</span><br>    age = <span class=\"hljs-literal\">None</span><br>    gender = <span class=\"hljs-literal\">None</span><br>    <br>    <span class=\"hljs-comment\"># 成员方法，必须有self参数，表示当前对象</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">showname</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-variable language_\">self</span>.name)<br></code></pre></td></tr></tbody></table></figure>\n<p>构造方法：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, gender, age</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.gender = gender<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"创建一个学生对象\"</span>)<br></code></pre></td></tr></tbody></table></figure>\n<p>魔术方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数列表</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__init__(self, *args, **kwargs)</code></td>\n<td>构造方法</td>\n<td><code>self</code>: 当前对象 <br> <code>*args</code>: 可变参数 <br> <code>**kwargs</code>: 关键字参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>__str__(self)</code></td>\n<td>对象转字符串</td>\n<td><code>self</code>: 当前对象</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td><code>__lt__(self, other)</code></td>\n<td>重写小于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td><code>__le__(self, other)</code></td>\n<td>重写小于等于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td><code>__eq__(self, other)</code></td>\n<td>重写等于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 魔术方法</span><br><span class=\"hljs-comment\">## __str__(): 返回对象的字符串表示</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"name=%s,gender=%s,age=%s\"</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.gender, <span class=\"hljs-variable language_\">self</span>.age)<br><br><span class=\"hljs-comment\">## __lt__(): 用于类对象的小于比较(less than)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__lt__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age &lt; other.age<br><br><span class=\"hljs-comment\">## __le__(): 用于类对象的小于等于比较(less than or equal)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__le__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age &lt;= other.age<br><br><span class=\"hljs-comment\">## __eq__(): 用于类对象的等于比较(equal)，默认\"==\"比较的是内存地址</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__eq__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age == other.age<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85\">类的封装</span></h3><p><strong>封装</strong>：封装就是将<strong>属性或方法私有化</strong>，属性或方法私有化后，外部无法直接访问属性或方法，只能通过方法访问属性或方法</p>\n<p>语法：<br>属性私有化：<code>__属性名</code><br>方法私有化：<code>__方法名()</code><br>受保护属性：<code>_属性名</code><br>受保护方法：<code>_方法名()</code></p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>:<br>    <span class=\"hljs-comment\"># 私有成员变量</span><br>    __name = <span class=\"hljs-literal\">None</span><br>    __age = <span class=\"hljs-literal\">None</span><br>    __sex = <span class=\"hljs-literal\">None</span><br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>        <span class=\"hljs-variable language_\">self</span>.__age = age<br>        <span class=\"hljs-variable language_\">self</span>.__sex = sex<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">show</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"姓名：%s, 年龄：%d, 性别：%s\"</span> % (<span class=\"hljs-variable language_\">self</span>.__name, <span class=\"hljs-variable language_\">self</span>.__age, <span class=\"hljs-variable language_\">self</span>.__sex))<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getName</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__name<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getAge</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__age<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getSex</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__sex<br>    <br>    <span class=\"hljs-comment\"># 私有成员方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setName</span>(<span class=\"hljs-params\">self, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setAge</span>(<span class=\"hljs-params\">self, age</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__age = age<br>        <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setSex</span>(<span class=\"hljs-params\">self, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__sex = sex<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF\">类的继承</span></h3><p>继承：子类继承父类的属性和方法，并添加新的属性和方法</p>\n<ol>\n<li>不同于Java语言，Python语言支持多继承</li>\n<li>多继承时，父类同名属性或方法，会按照从左到右的顺序进行覆盖，即左边优先级更大</li>\n<li>子类只继承父类的<strong>公有</strong>或<strong>受保护</strong>属性和方法，不会继承父类的私有属性或方法</li>\n<li>父类的私有属性或方法，子类无法直接访问，需通过父类方法进行访问</li>\n<li>子类可以<strong>重写</strong>父类的同名方法</li>\n</ol>\n<p>语法：</p>\n<ol>\n<li><p>继承：<code>class 子类名(父类名1[, 父类名2, ...]):</code></p>\n</li>\n<li><p>调用：<code>super().[属性或方法名(参数)]</code>或<code>父类名.方法名(self, 参数)</code></p>\n</li>\n</ol>\n<h3><span id=\"%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81\">类的多态</span></h3><ul>\n<li>子类继承父类，并重写父类的同名方法</li>\n<li>函数参数可以指定父类对象，调用时传入子类对象</li>\n<li>通过调用不同子类的同名方法，实现多态</li>\n<li>父类可以声明一个抽象方法，子类必须实现该抽象方法<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 多态</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"动物叫\"</span>)<br>    <br>    <span class=\"hljs-comment\"># 父类可以定义抽象方法 子类必须实现抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">pass</span><br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span>(<span class=\"hljs-title class_ inherited__\">Animal</span>):<br>    <span class=\"hljs-comment\"># 重写父类的方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"汪汪汪\"</span>)<br>    <br>    <span class=\"hljs-comment\"># 重写父类抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"大狗嚼嚼嚼\"</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-title class_ inherited__\">Animal</span>):<br>    <span class=\"hljs-comment\"># 重写父类方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"喵喵喵\"</span>)<br>        <br>    <span class=\"hljs-comment\"># 重写父类抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"吃吃吃\"</span>)<br>        <br><span class=\"hljs-comment\"># 定义一个方法 接收一个父类对象</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_cry</span>(<span class=\"hljs-params\">animal: Animal</span>):<br>    animal.cry()<br>    <br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_eat</span>(<span class=\"hljs-params\">animal: Animal</span>):<br>    animal.eat()<br>        <br>        <br>dog = Dog()<br>cat = Cat()<br><br><span class=\"hljs-comment\"># 传入不同子类 调用不同的方法</span><br>print_cry(dog)<br>print_cry(cat)<br><br>print_eat(dog)<br>print_eat(cat)<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</body></html>","excerpt":"","more":"<style>\n.table-container {\n  overflow-x: auto;\n  margin: 1em 0;\n}\n\ntable {\n  min-width: 100%;\n  display: block;\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\nth, td {\n  padding: 8px 12px;\n  text-align: left;\n  white-space: nowrap;\n}\n</style>\n\n<h1 id=\"Python-笔记\"><a href=\"#Python-笔记\" class=\"headerlink\" title=\"Python 笔记\"></a>Python 笔记</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><blockquote>\n<ol>\n<li><a href=\"#%E5%88%97%E8%A1%A8-list\">列表 list</a></li>\n<li><a href=\"#%E5%85%83%E7%BB%84-tuple\">元组 tuple</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2-string\">字符串 string</a></li>\n<li><a href=\"#%E9%9B%86%E5%90%88-set\">集合 set</a></li>\n<li><a href=\"#%E5%AD%97%E5%85%B8-dict\">字典 dict</a></li>\n<li><a href=\"#%E5%AE%B9%E5%99%A8-container\">容器 container</a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6\">文件 file</a></li>\n<li><a href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">正则表达式</a></li>\n<li><a href=\"#%E5%BC%82%E5%B8%B8-exception\">异常 Exception</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-module\">模块 module</a></li>\n<li><a href=\"#json\">json</a></li>\n<li><a href=\"#pyecharts\">pyecharts</a></li>\n<li><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">面向对象 OOP</a></li>\n</ol>\n</blockquote>\n<h2 id=\"列表-list\"><a href=\"#列表-list\" class=\"headerlink\" title=\"列表 list\"></a>列表 list</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"列表方法\"><a href=\"#列表方法\" class=\"headerlink\" title=\"列表方法\"></a>列表方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回列表中指定元素的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>insert(index,item)</code></td>\n<td>在列表指定位置插入元素，此位置后的元素右移</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>append(item)</code></td>\n<td>在列表末尾添加元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>extend(list)</code></td>\n<td>在列表末尾添加列表元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>del list[index]</code></td>\n<td>删除列表指定位置的元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop(index)</code></td>\n<td>删除列表指定位置的元素，并返回该元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>remove(item)</code></td>\n<td>删除列表中指定元素的第一个匹配项</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空列表</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回列表中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(list)</code></td>\n<td>返回列表的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><code>reverse()</code></td>\n<td>列表倒序</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><strong><code>list[begin:end:step]</code></strong></td>\n<td>切片，返回列表指定范围的元素</td>\n<td><code>列表</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h2 id=\"元组-tuple\"><a href=\"#元组-tuple\" class=\"headerlink\" title=\"元组 tuple\"></a>元组 tuple</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"元组方法\"><a href=\"#元组方法\" class=\"headerlink\" title=\"元组方法\"></a>元组方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回元组中指定元素的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回元组中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(tuple)</code></td>\n<td>返回元组的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><strong><code>tuple[begin:end:step]</code></strong></td>\n<td>切片，返回元组指定范围的元素</td>\n<td><code>元组</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>元组不可变，不能添加、删除、修改元素</li>\n<li>元组中的列表仍然可变，原因在于元组中的列表属于引用类型，列表属于对象，对象都是引用类型</li>\n</ol>\n<h2 id=\"字符串-string\"><a href=\"#字符串-string\" class=\"headerlink\" title=\"字符串 string\"></a>字符串 string</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a>字符串方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>index(item)</code></td>\n<td>返回字符串中指定元素起始位置的索引</td>\n<td><code>索引</code>,item不存在返回<code>error</code></td>\n</tr>\n<tr>\n<td><code>replace(old,new)</code></td>\n<td>替换字符串中指定元素，原字符串不变</td>\n<td><code>替换后的字符串</code></td>\n</tr>\n<tr>\n<td><code>split(sep)</code></td>\n<td>将字符串按指定分隔符分隔，返回列表</td>\n<td><code>列表</code></td>\n</tr>\n<tr>\n<td><code>strip([chars])</code></td>\n<td>去除字符串头尾的指定字符，默认参数为<code>空格</code></td>\n<td><code>字符串</code></td>\n</tr>\n<tr>\n<td><code>count(item)</code></td>\n<td>返回字符串中指定元素的个数</td>\n<td><code>个数</code></td>\n</tr>\n<tr>\n<td><code>len(string)</code></td>\n<td>返回字符串的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><strong><code>string[begin:end:step]</code></strong></td>\n<td>切片，返回字符串指定范围的元素</td>\n<td><code>字符串</code></td>\n</tr>\n</tbody></table>\n</div>\n\n\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>字符串不可变，不能添加、删除、修改元素</li>\n</ol>\n<h2 id=\"集合-set\"><a href=\"#集合-set\" class=\"headerlink\" title=\"集合 set\"></a>集合 set</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"集合方法\"><a href=\"#集合方法\" class=\"headerlink\" title=\"集合方法\"></a>集合方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>add(item)</code></td>\n<td>添加元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>remove(item)</code></td>\n<td>删除元素</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop()</code></td>\n<td>删除并返回集合中的第一个元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空集合</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>difference(set)</code></td>\n<td>返回两个集合的差集，即主类有而参数类没有的元素</td>\n<td><code>集合</code></td>\n</tr>\n<tr>\n<td><code>difference_update(set)</code></td>\n<td>删除两个集合的交集元素，主类改变而参数类不变</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>union(set)</code></td>\n<td>返回两个集合的并集，该并集是新集合，原集合不变</td>\n<td><code>集合</code></td>\n</tr>\n<tr>\n<td><code>len(set)</code></td>\n<td>返回集合的长度</td>\n<td><code>长度</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h3 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>集合中的元素不能重复</li>\n<li>集合是无序的，不能通过索引访问元素</li>\n</ol>\n<h2 id=\"字典-dict\"><a href=\"#字典-dict\" class=\"headerlink\" title=\"字典 dict\"></a>字典 dict</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"字典方法\"><a href=\"#字典方法\" class=\"headerlink\" title=\"字典方法\"></a>字典方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dict[key] = value</code></td>\n<td>添加元素，若key已存在，则更新value</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>pop(key)</code></td>\n<td>删除指定key的元素，并返回该元素</td>\n<td><code>元素</code></td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空字典</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>keys()</code></td>\n<td>返回字典中所有key的列表</td>\n<td><code>列表</code></td>\n</tr>\n<tr>\n<td><code>len(dict)</code></td>\n<td>返回字典的长度</td>\n<td><code>长度</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h2 id=\"容器-container\"><a href=\"#容器-container\" class=\"headerlink\" title=\"容器 container\"></a>容器 container</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>list,tuple,string,set,dict都是容器</p>\n<h3 id=\"容器通用方法\"><a href=\"#容器通用方法\" class=\"headerlink\" title=\"容器通用方法\"></a>容器通用方法</h3><div class=\"table-container\">\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>len(container)</code></td>\n<td>返回容器的长度</td>\n<td><code>长度</code></td>\n</tr>\n<tr>\n<td><code>max(container)</code></td>\n<td>返回容器中的最大值</td>\n<td><code>最大值</code></td>\n</tr>\n<tr>\n<td><code>min(container)</code></td>\n<td>返回容器中的最小值</td>\n<td><code>最小值</code></td>\n</tr>\n<tr>\n<td><code>sorted(container, [reverse=False])</code></td>\n<td>返回容器中的排序后的元素，reverse为True时，返回排序后的元素逆序</td>\n<td><code>排序后的元素list</code></td>\n</tr>\n</tbody></table>\n</div>\n\n<h3 id=\"容器类型转换\"><a href=\"#容器类型转换\" class=\"headerlink\" title=\"容器类型转换\"></a>容器类型转换</h3><ol>\n<li>转<code>list</code>：字典中的<strong>key值</strong>转为list元素；字符串的每个<strong>字符</strong>转为list元素</li>\n<li>转<code>tuple</code>：字典中的<strong>key值</strong>转为tuple元素；字符串的每个<strong>字符</strong>转为tuple元素</li>\n<li>转<code>set</code>：字典中的<strong>key值</strong>转为set元素；字符串的每个<strong>字符</strong>转为set元素</li>\n</ol>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"文件的读取\"><a href=\"#文件的读取\" class=\"headerlink\" title=\"文件的读取\"></a>文件的读取</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>open(filename, mode=&#39;&lt;r&gt;&#39;, encoding=&#39;&lt;utf-8&gt;&#39;)</code></td>\n<td>打开文件</td>\n<td><code>文件对象</code></td>\n<td>filename: 文件名或文件路径 <br> mode: 文件打开模式 <br> encoding: 文件编码 <br> <code>r</code>: 只读模式 <br> <code>w</code>: 只写模式，同名文件存在则覆盖，不存在则创建 <br> <code>a</code>: 追加模式，同名文件存在则追加，不存在则创建</td>\n</tr>\n<tr>\n<td><code>with open(filename, mode=&#39;&lt;r&gt;&#39;, encoding=&#39;&lt;utf-8&gt;&#39;) as f:</code></td>\n<td>打开文件，在运行完此语句块时自动关闭文件</td>\n<td><code>None</code></td>\n<td>f: <code>open()</code>返回的对象</td>\n</tr>\n<tr>\n<td><code>file.read([size])</code></td>\n<td>读取文件内容</td>\n<td><code>文件内容</code></td>\n<td>size: 读取指定字节数，默认为-1，表示读取所有内容</td>\n</tr>\n<tr>\n<td><code>file.readline()</code></td>\n<td>读取文件的一行内容</td>\n<td><code>行内容</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>file.readlines()</code></td>\n<td>读取文件所有行内容</td>\n<td><code>行内容list</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>for line in file:</code></td>\n<td>循环读取文件内容</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>file.close()</code></td>\n<td>关闭文件</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"文件的写入\"><a href=\"#文件的写入\" class=\"headerlink\" title=\"文件的写入\"></a>文件的写入</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file.write(string)</code></td>\n<td>写入文件内容，并不会立刻写入文件，而是先写入缓冲区</td>\n<td><code>None</code></td>\n<td><code>string</code>: 要写入的内容</td>\n</tr>\n<tr>\n<td><code>file.flush()</code></td>\n<td>将缓冲区中的内容写入文件，<code>close()</code>函数包含<code>flush()</code>功能</td>\n<td><code>None</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"常用元符号\"><a href=\"#常用元符号\" class=\"headerlink\" title=\"常用元符号\"></a>常用元符号</h3><table>\n<thead>\n<tr>\n<th>正则表达式符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.</code></td>\n<td>匹配任意字符，除了换行符</td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>匹配0个或多个前面的字符</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>匹配1个或多个前面的字符</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>匹配0个或1个前面的字符</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配字符串的开头</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配字符串的结尾</td>\n</tr>\n<tr>\n<td><code>&#123;n&#125;</code></td>\n<td>匹配前一个字符n次</td>\n</tr>\n<tr>\n<td><code>&#123;n,m&#125;</code></td>\n<td>匹配前一个字符n到m次</td>\n</tr>\n<tr>\n<td><code>&#123;n,&#125;</code></td>\n<td>匹配前一个字符n次以上</td>\n</tr>\n</tbody></table>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><table>\n<thead>\n<tr>\n<th>字符类</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[abc]</code></td>\n<td>匹配a或b或c</td>\n</tr>\n<tr>\n<td><code>[^abc]</code></td>\n<td>匹配除了a或b或c之外的字符</td>\n</tr>\n<tr>\n<td><code>[a-z]</code></td>\n<td>匹配a到z之间的任意字符</td>\n</tr>\n<tr>\n<td><code>[A-Z]</code></td>\n<td>匹配A到Z之间的任意字符</td>\n</tr>\n<tr>\n<td><code>[0-9]</code></td>\n<td>匹配0到9之间的任意字符</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>匹配字母、数字、下划线</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>匹配空白字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"异常-Exception\"><a href=\"#异常-Exception\" class=\"headerlink\" title=\"异常 Exception\"></a>异常 Exception</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    <span class=\"hljs-comment\"># 有可能抛出异常的代码段</span><br><span class=\"hljs-keyword\">except</span> [(NameError, ZeroDivisionError, ...) <span class=\"hljs-keyword\">as</span> e]:<br>    <span class=\"hljs-comment\"># 捕获对应类型的异常，默认所有异常</span><br>    <span class=\"hljs-comment\"># 异常处理代码段</span><br>[<span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    没有异常时执行代码段</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>]<br>[<span class=\"hljs-keyword\">finally</span>:<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">     finally代码段，无论是否有异常，都会执行</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"异常的类型\"><a href=\"#异常的类型\" class=\"headerlink\" title=\"异常的类型\"></a>异常的类型</h3><blockquote>\n<p>详细请查阅官方文档：<a href=\"https://docs.python.org/3/library/exceptions.html#Exception\">Python异常处理</a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>异常类型</th>\n<th>描述</th>\n<th>父类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Exception</code></td>\n<td>所有异常的基类</td>\n<td><code>object</code></td>\n</tr>\n<tr>\n<td><code>ArithmeticError</code></td>\n<td>数学运算异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OverflowError</code></td>\n<td>算术运算溢出异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>ZeroDivisionError</code></td>\n<td>除数为0异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>FloatingPointError</code></td>\n<td>浮点数异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n<tr>\n<td><code>AssertionError</code></td>\n<td>断言异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>AttributeError</code></td>\n<td>属性异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>BufferError</code></td>\n<td>缓冲区异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>EOFError</code></td>\n<td>文件结束异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>ImportError</code></td>\n<td>导入异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>ModuleNotFoundError</code></td>\n<td>模块未找到异常</td>\n<td><code>ImportError</code></td>\n</tr>\n<tr>\n<td><code>IndexError</code></td>\n<td>索引异常，下标超出范围</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>KeyError</code></td>\n<td>键异常，键集中找不到映射</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>LookupError</code></td>\n<td>查找异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>MemoryError</code></td>\n<td>内存异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>NameError</code></td>\n<td>名称异常，变量未定义</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>NotImplementedError</code></td>\n<td>未实现异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OSError</code></td>\n<td>操作系统异常</td>\n<td><code>Exception</code></td>\n</tr>\n<tr>\n<td><code>OverflowError</code></td>\n<td>算术运算溢出异常</td>\n<td><code>ArithmeticError</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"模块-module\"><a href=\"#模块-module\" class=\"headerlink\" title=\"模块 module\"></a>模块 module</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>模块是Python代码文件，模块名就是文件名，其中定义了模块的变量、函数、类等，也可以包含可执行的代码</p>\n<h3 id=\"导入模块\"><a href=\"#导入模块\" class=\"headerlink\" title=\"导入模块\"></a>导入模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># from 模块名 import 变量名 后续可以直接使用变量名</span><br><span class=\"hljs-comment\"># import 模块名 后续必须使用模块名.变量名</span><br>[<span class=\"hljs-keyword\">from</span> 模块名] <span class=\"hljs-keyword\">import</span> &lt;模块变量|模块函数|模块类|*&gt; [<span class=\"hljs-keyword\">as</span> 别名]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项-3\"><a href=\"#注意事项-3\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>不同模块的同名函数，后导入的会覆盖先导入的</li>\n<li><code>__main__</code>变量在模块中可以直接运行，测试函数功能，但在导入模块中，<code>__main__</code>变量会失效</li>\n<li><code>__all__</code>变量，在模块或**<strong>init</strong>.py**中定义，用于指定模块的成员，只有被指定成员导入时，才会被<code>*</code>导入，未被指定只能使用变量名导入<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># __all__变量指定的语法</span><br>__all__ = [<span class=\"hljs-string\">&#x27;变量名&#x27;</span>, <span class=\"hljs-string\">&#x27;函数名&#x27;</span>, <span class=\"hljs-string\">&#x27;类名&#x27;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Python-包-package\"><a href=\"#Python-包-package\" class=\"headerlink\" title=\"Python 包 package\"></a>Python 包 package</h3><p>包是模块的集合，包名就是文件夹名，包中的模块名就是文件夹中的文件名</p>\n<h4 id=\"创建包\"><a href=\"#创建包\" class=\"headerlink\" title=\"创建包\"></a>创建包</h4><ol>\n<li>创建文件夹，文件夹名就是包名</li>\n<li>在文件夹中创建**<strong>init</strong>.py__**文件</li>\n</ol>\n<h3 id=\"第三方包\"><a href=\"#第三方包\" class=\"headerlink\" title=\"第三方包\"></a>第三方包</h3><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pip install 包名</code></td>\n<td>安装包</td>\n</tr>\n</tbody></table>\n<h2 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json\"></a>json</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p>本质上是能在不同编程语言中互操作的数据格式，在python中为字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> json<br></code></pre></td></tr></table></figure>\n<h3 id=\"json相关操作\"><a href=\"#json相关操作\" class=\"headerlink\" title=\"json相关操作\"></a>json相关操作</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>json.dumps(obj, ensure_ascii=False, indent=4)</code></td>\n<td>将Python对象转换为json字符串</td>\n<td><code>json字符串</code></td>\n<td>obj: 要转换的Python对象，可以是<strong>字典</strong>和嵌套字典的<strong>列表</strong> <br> ensure_ascii: 是否转义非ASCII字符，中文显示需要设置False <br> indent: 缩进级别</td>\n</tr>\n<tr>\n<td><code>json.loads(json_str)</code></td>\n<td>将json字符串转换为Python对象</td>\n<td><code>Python对象</code></td>\n<td>json_str: 要转换的json字符串</td>\n</tr>\n</tbody></table>\n<h2 id=\"pyecharts\"><a href=\"#pyecharts\" class=\"headerlink\" title=\"pyecharts\"></a>pyecharts</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<p><a href=\"https://gallery.pyecharts.org/#/Line/README\">官方文档</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pyecharts<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> pyecharts[.&lt;选项&gt;] <span class=\"hljs-keyword\">import</span> &lt;包名&gt; [<span class=\"hljs-keyword\">as</span> &lt;别名&gt;]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"全局配置选项\"><a href=\"#全局配置选项\" class=\"headerlink\" title=\"全局配置选项\"></a>全局配置选项</h3><p><a href=\"https://pyecharts.org/#/zh-cn/global_options\">官方文档</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">line.set_global_opts(<br>  title_opts=opts.TitleOpts(title=<span class=\"hljs-string\">&quot;GDP&quot;</span>),<br>  ...<br>)<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>构造参数</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>title_opts</code></td>\n<td>标题配置项</td>\n<td>opts.TitleOpts(title&#x3D;&quot;GDP&quot;)</td>\n<td>title: 标题名称</td>\n</tr>\n<tr>\n<td><code>legend_opts</code></td>\n<td>图例配置项</td>\n<td>opts.LegendOpts(is_show&#x3D;False)</td>\n<td>is_show: 是否显示图例</td>\n</tr>\n<tr>\n<td><code>tooltip_opts</code></td>\n<td>提示框配置项</td>\n<td>opts.TooltipOpts(is_show&#x3D;True)</td>\n<td>is_show: 是否显示提示框</td>\n</tr>\n<tr>\n<td><code>toolbox_opts</code></td>\n<td>工具箱配置项</td>\n<td>opts.ToolboxOpts(is_show&#x3D;True)</td>\n<td>is_show: 是否显示工具箱</td>\n</tr>\n<tr>\n<td><code>visualmap_opts</code></td>\n<td>视觉映射配置项</td>\n<td>opts.VisualMapOpts(is_show&#x3D;True)</td>\n<td>is_show: 是否显示视觉映射</td>\n</tr>\n</tbody></table>\n<h3 id=\"基础折线图\"><a href=\"#基础折线图\" class=\"headerlink\" title=\"基础折线图\"></a>基础折线图</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 绘制基础折线图</span><br><br><span class=\"hljs-comment\">## 导包</span><br><span class=\"hljs-keyword\">from</span> pyecharts.charts <span class=\"hljs-keyword\">import</span> Line<br><br><span class=\"hljs-comment\">## 得到折线图对象</span><br>line = Line()<br><br><span class=\"hljs-comment\">## 添加数据</span><br><span class=\"hljs-comment\">### x轴数据</span><br>line.add_xaxis([<span class=\"hljs-string\">&quot;中国&quot;</span>, <span class=\"hljs-string\">&quot;美国&quot;</span>, <span class=\"hljs-string\">&quot;日本&quot;</span>, <span class=\"hljs-string\">&quot;印度&quot;</span>, <span class=\"hljs-string\">&quot;法国&quot;</span>, <span class=\"hljs-string\">&quot;英国&quot;</span>, <span class=\"hljs-string\">&quot;俄罗斯&quot;</span>, <span class=\"hljs-string\">&quot;意大利&quot;</span>, <span class=\"hljs-string\">&quot;德国&quot;</span>, <span class=\"hljs-string\">&quot;西班牙&quot;</span>])<br><span class=\"hljs-comment\">### y轴数据</span><br>line.add_yaxis(<span class=\"hljs-string\">&quot;GDP&quot;</span>, [<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.1</span>])<br><br><span class=\"hljs-comment\">## 设置全局配置选项</span><br>line.set_global_opts(<br>    title_opts=opts.TitleOpts(title=<span class=\"hljs-string\">&quot;GDP&quot;</span>),<br>    tooltip_opts=opts.TooltipOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    legend_opts=opts.LegendOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    toolbox_opts=opts.ToolboxOpts(is_show=<span class=\"hljs-literal\">True</span>),<br>    visualmap_opts=opts.VisualMapOpts(is_show=<span class=\"hljs-literal\">True</span>)<br>)<br><br><span class=\"hljs-comment\">## 生成图表</span><br>line.render()<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>基本结构：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>:<br>    <span class=\"hljs-comment\"># 成员变量</span><br>    name = <span class=\"hljs-literal\">None</span><br>    age = <span class=\"hljs-literal\">None</span><br>    gender = <span class=\"hljs-literal\">None</span><br>    <br>    <span class=\"hljs-comment\"># 成员方法，必须有self参数，表示当前对象</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">showname</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-variable language_\">self</span>.name)<br></code></pre></td></tr></table></figure>\n<p>构造方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 构造方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, gender, age</span>):<br>        <span class=\"hljs-variable language_\">self</span>.name = name<br>        <span class=\"hljs-variable language_\">self</span>.gender = gender<br>        <span class=\"hljs-variable language_\">self</span>.age = age<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;创建一个学生对象&quot;</span>)<br></code></pre></td></tr></table></figure>\n<p>魔术方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数列表</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__init__(self, *args, **kwargs)</code></td>\n<td>构造方法</td>\n<td><code>self</code>: 当前对象 <br> <code>*args</code>: 可变参数 <br> <code>**kwargs</code>: 关键字参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>__str__(self)</code></td>\n<td>对象转字符串</td>\n<td><code>self</code>: 当前对象</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td><code>__lt__(self, other)</code></td>\n<td>重写小于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td><code>__le__(self, other)</code></td>\n<td>重写小于等于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td><code>__eq__(self, other)</code></td>\n<td>重写等于，用于对象某一规则的比较</td>\n<td><code>self</code>: 当前对象 <br> <code>other</code>: 其他对象</td>\n<td>布尔值</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 魔术方法</span><br><span class=\"hljs-comment\">## __str__(): 返回对象的字符串表示</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;name=%s,gender=%s,age=%s&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.name, <span class=\"hljs-variable language_\">self</span>.gender, <span class=\"hljs-variable language_\">self</span>.age)<br><br><span class=\"hljs-comment\">## __lt__(): 用于类对象的小于比较(less than)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__lt__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age &lt; other.age<br><br><span class=\"hljs-comment\">## __le__(): 用于类对象的小于等于比较(less than or equal)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__le__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age &lt;= other.age<br><br><span class=\"hljs-comment\">## __eq__(): 用于类对象的等于比较(equal)，默认&quot;==&quot;比较的是内存地址</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__eq__</span>(<span class=\"hljs-params\">self, other</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.age == other.age<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类的封装\"><a href=\"#类的封装\" class=\"headerlink\" title=\"类的封装\"></a>类的封装</h3><p><strong>封装</strong>：封装就是将<strong>属性或方法私有化</strong>，属性或方法私有化后，外部无法直接访问属性或方法，只能通过方法访问属性或方法</p>\n<p>语法：<br>属性私有化：<code>__属性名</code><br>方法私有化：<code>__方法名()</code><br>受保护属性：<code>_属性名</code><br>受保护方法：<code>_方法名()</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>:<br>    <span class=\"hljs-comment\"># 私有成员变量</span><br>    __name = <span class=\"hljs-literal\">None</span><br>    __age = <span class=\"hljs-literal\">None</span><br>    __sex = <span class=\"hljs-literal\">None</span><br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>        <span class=\"hljs-variable language_\">self</span>.__age = age<br>        <span class=\"hljs-variable language_\">self</span>.__sex = sex<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">show</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;姓名：%s, 年龄：%d, 性别：%s&quot;</span> % (<span class=\"hljs-variable language_\">self</span>.__name, <span class=\"hljs-variable language_\">self</span>.__age, <span class=\"hljs-variable language_\">self</span>.__sex))<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getName</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__name<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getAge</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__age<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getSex</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">self</span>.__sex<br>    <br>    <span class=\"hljs-comment\"># 私有成员方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setName</span>(<span class=\"hljs-params\">self, name</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__name = name<br>    <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setAge</span>(<span class=\"hljs-params\">self, age</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__age = age<br>        <br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__setSex</span>(<span class=\"hljs-params\">self, sex</span>):<br>        <span class=\"hljs-variable language_\">self</span>.__sex = sex<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>继承：子类继承父类的属性和方法，并添加新的属性和方法</p>\n<ol>\n<li>不同于Java语言，Python语言支持多继承</li>\n<li>多继承时，父类同名属性或方法，会按照从左到右的顺序进行覆盖，即左边优先级更大</li>\n<li>子类只继承父类的<strong>公有</strong>或<strong>受保护</strong>属性和方法，不会继承父类的私有属性或方法</li>\n<li>父类的私有属性或方法，子类无法直接访问，需通过父类方法进行访问</li>\n<li>子类可以<strong>重写</strong>父类的同名方法</li>\n</ol>\n<p>语法：</p>\n<ol>\n<li><p>继承：<code>class 子类名(父类名1[, 父类名2, ...]):</code></p>\n</li>\n<li><p>调用：<code>super().[属性或方法名(参数)]</code>或<code>父类名.方法名(self, 参数)</code></p>\n</li>\n</ol>\n<h3 id=\"类的多态\"><a href=\"#类的多态\" class=\"headerlink\" title=\"类的多态\"></a>类的多态</h3><ul>\n<li>子类继承父类，并重写父类的同名方法</li>\n<li>函数参数可以指定父类对象，调用时传入子类对象</li>\n<li>通过调用不同子类的同名方法，实现多态</li>\n<li>父类可以声明一个抽象方法，子类必须实现该抽象方法<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 多态</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;动物叫&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 父类可以定义抽象方法 子类必须实现抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">pass</span><br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span>(<span class=\"hljs-title class_ inherited__\">Animal</span>):<br>    <span class=\"hljs-comment\"># 重写父类的方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;汪汪汪&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 重写父类抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;大狗嚼嚼嚼&quot;</span>)<br>        <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-title class_ inherited__\">Animal</span>):<br>    <span class=\"hljs-comment\"># 重写父类方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cry</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;喵喵喵&quot;</span>)<br>        <br>    <span class=\"hljs-comment\"># 重写父类抽象方法</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;吃吃吃&quot;</span>)<br>        <br><span class=\"hljs-comment\"># 定义一个方法 接收一个父类对象</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_cry</span>(<span class=\"hljs-params\">animal: Animal</span>):<br>    animal.cry()<br>    <br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_eat</span>(<span class=\"hljs-params\">animal: Animal</span>):<br>    animal.eat()<br>        <br>        <br>dog = Dog()<br>cat = Cat()<br><br><span class=\"hljs-comment\"># 传入不同子类 调用不同的方法</span><br>print_cry(dog)<br>print_cry(cat)<br><br>print_eat(dog)<br>print_eat(cat)<br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"爬楼梯问题","date":"2025-09-14T08:32:00.000Z","_content":"\n# 爬楼梯问题\n\n## 问题描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n \n\n示例 1：\n\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\n示例 2：\n\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n## 递归解法\n> 思路：\n> n = 1 时，只有一种方法，即爬 1 阶；\n> n = 2 时，有两种方法，即爬 1 阶 + 1 阶和 2 阶；\n> n = 3 时，若在n=1，则有两种方法，即爬 1 阶 + 1 阶和 2 阶；若在n=2，则只有一种方法，即爬一阶；\n> 而n = 1和n = 2结果已知，由此，可以退出递推公式\n> 即递推公式为：f(n) = f(n-1) + f(n-2)\n\n### 代码实现\n~~~python\ndef climbStairs(n):\n    # 处理边界条件\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    # 递归调用\n    return climbStairs(n-1) + climbStairs(n-2)\n~~~\n### 复杂度分析\n从递归树中可以看出，调用的次数为**2^n^**\n所以：时间复杂度：**O(2^n^)** 空间复杂度：**O(n)**\n![递归树](../assert/微信图片_20250914151010_28_9.png \"递归树\")\n这种方法存在重复计算，递归树中，节点2就被计算了两次，导致效率较低\n我们可以引入一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算，于是得到**记忆化递归解法**\n\n## 记忆化递归解法\n> 思路：\n> 在原有的递归解法中，添加一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算\n\n### 代码实现\n~~~python\ndef climb(n):\n    memo = []\n    # 初始化数组\n    for i in range(n + 1):\n        memo.append(0)\n    return climbStairsMemo(n, memo)\n\ndef climbStairsMemo(n, memo):\n    # 计算过的直接返回\n    if memo[n] > 0:\n        return memo[n]\n    \n    # 处理边界条件\n    if n == 1:\n        memo[n] = 1\n    elif n == 2:\n        memo[n] = 2\n    else:\n        memo[n] = climbStairsMemo(n-1, memo) + climbStairsMemo(n-2, memo)\n    return memo[n]\n~~~\n\n### 复杂度分析\n由于每个节点只被计算一次，所以共n个节点，计算n次\n时间复杂度：**O(n)** 空间复杂度：**O(n)**\n\n## 动态规划解法\n> 思路：\n> 与递归类似，通过状态转移方程即递推式，计算出结果\n> 状态转移方程：f(n) = f(n-1) + f(n-2)\n\n### 代码实现\n~~~python\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        # 初始化数组\n        dp = []\n        for i in range(0, n + 1):\n            dp.append(0)\n        dp[1] = 1\n        dp[2] = 2\n\n        # 状态转移方程递推\n        for i in range(3,n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** 空间复杂度：**O(n)**\n我们可以将数组优化成三个状态量，将空间复杂度降低到常数级别\n\n## 优化动态规划算法\n\n### 代码实现\n~~~python\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n\n        # 初始化三个变量\n        num1 = 1\n        num2 = 2\n\n        # 状态转移方程递推\n        for i in range(3,n + 1):\n            num3 = num1 + num2\n            num1 = num2\n            num2 = num3\n        \n        # num2 为最终状态\n        return num2\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** 空间复杂度：**O(1)**\n\n","source":"_posts/climb_stairs.md","raw":"---\ntitle: \"爬楼梯问题\"\ndate: 2025/09/14 16:32:00\ntags: \n    - \"算法\"\n    - \"动态规划\"\n    - \"递归\"\ncategories:\n    - \"算法笔记\"\n---\n\n# 爬楼梯问题\n\n## 问题描述\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n \n\n示例 1：\n\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\n示例 2：\n\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n## 递归解法\n> 思路：\n> n = 1 时，只有一种方法，即爬 1 阶；\n> n = 2 时，有两种方法，即爬 1 阶 + 1 阶和 2 阶；\n> n = 3 时，若在n=1，则有两种方法，即爬 1 阶 + 1 阶和 2 阶；若在n=2，则只有一种方法，即爬一阶；\n> 而n = 1和n = 2结果已知，由此，可以退出递推公式\n> 即递推公式为：f(n) = f(n-1) + f(n-2)\n\n### 代码实现\n~~~python\ndef climbStairs(n):\n    # 处理边界条件\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    # 递归调用\n    return climbStairs(n-1) + climbStairs(n-2)\n~~~\n### 复杂度分析\n从递归树中可以看出，调用的次数为**2^n^**\n所以：时间复杂度：**O(2^n^)** 空间复杂度：**O(n)**\n![递归树](../assert/微信图片_20250914151010_28_9.png \"递归树\")\n这种方法存在重复计算，递归树中，节点2就被计算了两次，导致效率较低\n我们可以引入一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算，于是得到**记忆化递归解法**\n\n## 记忆化递归解法\n> 思路：\n> 在原有的递归解法中，添加一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算\n\n### 代码实现\n~~~python\ndef climb(n):\n    memo = []\n    # 初始化数组\n    for i in range(n + 1):\n        memo.append(0)\n    return climbStairsMemo(n, memo)\n\ndef climbStairsMemo(n, memo):\n    # 计算过的直接返回\n    if memo[n] > 0:\n        return memo[n]\n    \n    # 处理边界条件\n    if n == 1:\n        memo[n] = 1\n    elif n == 2:\n        memo[n] = 2\n    else:\n        memo[n] = climbStairsMemo(n-1, memo) + climbStairsMemo(n-2, memo)\n    return memo[n]\n~~~\n\n### 复杂度分析\n由于每个节点只被计算一次，所以共n个节点，计算n次\n时间复杂度：**O(n)** 空间复杂度：**O(n)**\n\n## 动态规划解法\n> 思路：\n> 与递归类似，通过状态转移方程即递推式，计算出结果\n> 状态转移方程：f(n) = f(n-1) + f(n-2)\n\n### 代码实现\n~~~python\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        # 初始化数组\n        dp = []\n        for i in range(0, n + 1):\n            dp.append(0)\n        dp[1] = 1\n        dp[2] = 2\n\n        # 状态转移方程递推\n        for i in range(3,n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** 空间复杂度：**O(n)**\n我们可以将数组优化成三个状态量，将空间复杂度降低到常数级别\n\n## 优化动态规划算法\n\n### 代码实现\n~~~python\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n\n        # 初始化三个变量\n        num1 = 1\n        num2 = 2\n\n        # 状态转移方程递推\n        for i in range(3,n + 1):\n            num3 = num1 + num2\n            num1 = num2\n            num2 = num3\n        \n        # num2 为最终状态\n        return num2\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** 空间复杂度：**O(1)**\n\n","slug":"climb_stairs","published":1,"updated":"2025-09-23T15:25:25.829Z","_id":"cmfs3zg9r0000gwtl2q1j32rk","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98\">爬楼梯问题</span></h1><h2><span id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\">问题描述</span></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶</li>\n</ol>\n<p>示例 2：</p>\n<p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n</ol>\n<h2><span id=\"%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95\">递归解法</span></h2><blockquote>\n<p>思路：<br>n = 1 时，只有一种方法，即爬 1 阶；<br>n = 2 时，有两种方法，即爬 1 阶 + 1 阶和 2 阶；<br>n = 3 时，若在n=1，则有两种方法，即爬 1 阶 + 1 阶和 2 阶；若在n=2，则只有一种方法，即爬一阶；<br>而n = 1和n = 2结果已知，由此，可以退出递推公式<br>即递推公式为：f(n) = f(n-1) + f(n-2)</p>\n</blockquote>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-comment\"># 处理边界条件</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">2</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-comment\"># 递归调用</span><br>    <span class=\"hljs-keyword\">return</span> climbStairs(n-<span class=\"hljs-number\">1</span>) + climbStairs(n-<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>从递归树中可以看出，调用的次数为<strong>2^n^</strong><br>所以：时间复杂度：<strong>O(2^n^)</strong> 空间复杂度：<strong>O(n)</strong><br><img src=\"/../assert/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250914151010_28_9.png\" alt=\"递归树\" title=\"递归树\"><br>这种方法存在重复计算，递归树中，节点2就被计算了两次，导致效率较低<br>我们可以引入一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算，于是得到<strong>记忆化递归解法</strong></p>\n<h2><span id=\"%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95\">记忆化递归解法</span></h2><blockquote>\n<p>思路：<br>在原有的递归解法中，添加一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算</p>\n</blockquote>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climb</span>(<span class=\"hljs-params\">n</span>):<br>    memo = []<br>    <span class=\"hljs-comment\"># 初始化数组</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n + <span class=\"hljs-number\">1</span>):<br>        memo.append(<span class=\"hljs-number\">0</span>)<br>    <span class=\"hljs-keyword\">return</span> climbStairsMemo(n, memo)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairsMemo</span>(<span class=\"hljs-params\">n, memo</span>):<br>    <span class=\"hljs-comment\"># 计算过的直接返回</span><br>    <span class=\"hljs-keyword\">if</span> memo[n] &gt; <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">return</span> memo[n]<br>    <br>    <span class=\"hljs-comment\"># 处理边界条件</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>        memo[n] = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">elif</span> n == <span class=\"hljs-number\">2</span>:<br>        memo[n] = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">else</span>:<br>        memo[n] = climbStairsMemo(n-<span class=\"hljs-number\">1</span>, memo) + climbStairsMemo(n-<span class=\"hljs-number\">2</span>, memo)<br>    <span class=\"hljs-keyword\">return</span> memo[n]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>由于每个节点只被计算一次，所以共n个节点，计算n次<br>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(n)</strong></p>\n<h2><span id=\"%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95\">动态规划解法</span></h2><blockquote>\n<p>思路：<br>与递归类似，通过状态转移方程即递推式，计算出结果<br>状态转移方程：f(n) = f(n-1) + f(n-2)</p>\n</blockquote>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n</span>):<br>        <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">        :type n: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        \"\"\"</span><br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>        <span class=\"hljs-comment\"># 初始化数组</span><br>        dp = []<br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, n + <span class=\"hljs-number\">1</span>):<br>            dp.append(<span class=\"hljs-number\">0</span>)<br>        dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span><br>        dp[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span><br><br>        <span class=\"hljs-comment\"># 状态转移方程递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>,n + <span class=\"hljs-number\">1</span>):<br>            dp[i] = dp[i - <span class=\"hljs-number\">1</span>] + dp[i - <span class=\"hljs-number\">2</span>]<br>        <span class=\"hljs-keyword\">return</span> dp[n]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(n)</strong><br>我们可以将数组优化成三个状态量，将空间复杂度降低到常数级别</p>\n<h2><span id=\"%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95\">优化动态规划算法</span></h2><h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n</span>):<br>        <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">        :type n: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        \"\"\"</span><br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br><br>        <span class=\"hljs-comment\"># 初始化三个变量</span><br>        num1 = <span class=\"hljs-number\">1</span><br>        num2 = <span class=\"hljs-number\">2</span><br><br>        <span class=\"hljs-comment\"># 状态转移方程递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>,n + <span class=\"hljs-number\">1</span>):<br>            num3 = num1 + num2<br>            num1 = num2<br>            num2 = num3<br>        <br>        <span class=\"hljs-comment\"># num2 为最终状态</span><br>        <span class=\"hljs-keyword\">return</span> num2<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(1)</strong></p>\n</body></html>","excerpt":"","more":"<h1 id=\"爬楼梯问题\"><a href=\"#爬楼梯问题\" class=\"headerlink\" title=\"爬楼梯问题\"></a>爬楼梯问题</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>示例 1：</p>\n<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶</li>\n</ol>\n<p>示例 2：</p>\n<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n</ol>\n<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><blockquote>\n<p>思路：<br>n &#x3D; 1 时，只有一种方法，即爬 1 阶；<br>n &#x3D; 2 时，有两种方法，即爬 1 阶 + 1 阶和 2 阶；<br>n &#x3D; 3 时，若在n&#x3D;1，则有两种方法，即爬 1 阶 + 1 阶和 2 阶；若在n&#x3D;2，则只有一种方法，即爬一阶；<br>而n &#x3D; 1和n &#x3D; 2结果已知，由此，可以退出递推公式<br>即递推公式为：f(n) &#x3D; f(n-1) + f(n-2)</p>\n</blockquote>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-comment\"># 处理边界条件</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">2</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-comment\"># 递归调用</span><br>    <span class=\"hljs-keyword\">return</span> climbStairs(n-<span class=\"hljs-number\">1</span>) + climbStairs(n-<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>从递归树中可以看出，调用的次数为<strong>2^n^</strong><br>所以：时间复杂度：<strong>O(2^n^)</strong> 空间复杂度：<strong>O(n)</strong><br><img src=\"/../assert/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250914151010_28_9.png\" alt=\"递归树\" title=\"递归树\"><br>这种方法存在重复计算，递归树中，节点2就被计算了两次，导致效率较低<br>我们可以引入一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算，于是得到<strong>记忆化递归解法</strong></p>\n<h2 id=\"记忆化递归解法\"><a href=\"#记忆化递归解法\" class=\"headerlink\" title=\"记忆化递归解法\"></a>记忆化递归解法</h2><blockquote>\n<p>思路：<br>在原有的递归解法中，添加一个数组，保存计算结果，当遇到相同的参数时，直接返回结果，避免重复计算</p>\n</blockquote>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climb</span>(<span class=\"hljs-params\">n</span>):<br>    memo = []<br>    <span class=\"hljs-comment\"># 初始化数组</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n + <span class=\"hljs-number\">1</span>):<br>        memo.append(<span class=\"hljs-number\">0</span>)<br>    <span class=\"hljs-keyword\">return</span> climbStairsMemo(n, memo)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairsMemo</span>(<span class=\"hljs-params\">n, memo</span>):<br>    <span class=\"hljs-comment\"># 计算过的直接返回</span><br>    <span class=\"hljs-keyword\">if</span> memo[n] &gt; <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">return</span> memo[n]<br>    <br>    <span class=\"hljs-comment\"># 处理边界条件</span><br>    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>        memo[n] = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">elif</span> n == <span class=\"hljs-number\">2</span>:<br>        memo[n] = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">else</span>:<br>        memo[n] = climbStairsMemo(n-<span class=\"hljs-number\">1</span>, memo) + climbStairsMemo(n-<span class=\"hljs-number\">2</span>, memo)<br>    <span class=\"hljs-keyword\">return</span> memo[n]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>由于每个节点只被计算一次，所以共n个节点，计算n次<br>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(n)</strong></p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><blockquote>\n<p>思路：<br>与递归类似，通过状态转移方程即递推式，计算出结果<br>状态转移方程：f(n) &#x3D; f(n-1) + f(n-2)</p>\n</blockquote>\n<h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        :type n: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>        <span class=\"hljs-comment\"># 初始化数组</span><br>        dp = []<br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, n + <span class=\"hljs-number\">1</span>):<br>            dp.append(<span class=\"hljs-number\">0</span>)<br>        dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span><br>        dp[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span><br><br>        <span class=\"hljs-comment\"># 状态转移方程递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>,n + <span class=\"hljs-number\">1</span>):<br>            dp[i] = dp[i - <span class=\"hljs-number\">1</span>] + dp[i - <span class=\"hljs-number\">2</span>]<br>        <span class=\"hljs-keyword\">return</span> dp[n]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(n)</strong><br>我们可以将数组优化成三个状态量，将空间复杂度降低到常数级别</p>\n<h2 id=\"优化动态规划算法\"><a href=\"#优化动态规划算法\" class=\"headerlink\" title=\"优化动态规划算法\"></a>优化动态规划算法</h2><h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">climbStairs</span>(<span class=\"hljs-params\">self, n</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        :type n: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">1</span>:<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br><br>        <span class=\"hljs-comment\"># 初始化三个变量</span><br>        num1 = <span class=\"hljs-number\">1</span><br>        num2 = <span class=\"hljs-number\">2</span><br><br>        <span class=\"hljs-comment\"># 状态转移方程递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>,n + <span class=\"hljs-number\">1</span>):<br>            num3 = num1 + num2<br>            num1 = num2<br>            num2 = num3<br>        <br>        <span class=\"hljs-comment\"># num2 为最终状态</span><br>        <span class=\"hljs-keyword\">return</span> num2<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析-3\"><a href=\"#复杂度分析-3\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度：<strong>O(n)</strong> 空间复杂度：<strong>O(1)</strong></p>\n"},{"title":"组合总和问题","_content":"\n# 组合总和问题\n\n## 问题描述\n给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n\n题目数据保证答案符合 32 位整数范围。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3], target = 4\n输出：7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n\n示例 2：\n\n输入：nums = [9], target = 3\n输出：0\n\n \n\n提示：\n1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nnums 中的所有元素 互不相同\n1 <= target <= 1000\n\n## 思路\n1. 我们可以将此问题看作爬楼梯问题，如果可以到达某一个target，则最后加的一个数必在nums中\n2. 于是，我们可以定义一个数组dp来记录到达每一个小于等于target的数的方法数\n3. 将当前状态记为`dp[i]`，即到达i的方法数，而`dp[0] = 1`，因为只有什么都不选一种方法\n4. `1 <= i <= target`，只有 `num <= i`，才能判定为可达\n5. 因此我们可以递推从 `1 ~ target`，遍历nums判断nums中是否有可达的数，如果有则加上`dp[i - num]`\n6. 到此我们可以得到状态转移方程：`dp[i] += dp[i - num]`(每当有num<=i时)，其中num为nums中的数\n\n## 代码实现\n根据上述思路，我们可以得到如下代码：\n~~~python\nclass Solution(object):\n    def combinationSum4(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # 定义数组，记录可达的方法数，初始化\n        dp = [1] + [0] * target\n        # 从1开始递推\n        for i in range(1, target + 1):\n            # 遍历nums\n            for num in nums:\n                # 若num可达\n                if num <= i:\n                    # 累加方法数\n                    dp[i] += dp[i - num]\n\n        # 返回可达target的方法数\n        return dp[target]\n~~~\n","source":"_posts/combined_sum.md","raw":"---\ntitle: \"组合总和问题\"\ntags:\n    - \"算法\"\n    - \"动态规划\"\ncategories:\n    - \"算法笔记\"\n---\n\n# 组合总和问题\n\n## 问题描述\n给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n\n题目数据保证答案符合 32 位整数范围。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3], target = 4\n输出：7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n\n示例 2：\n\n输入：nums = [9], target = 3\n输出：0\n\n \n\n提示：\n1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nnums 中的所有元素 互不相同\n1 <= target <= 1000\n\n## 思路\n1. 我们可以将此问题看作爬楼梯问题，如果可以到达某一个target，则最后加的一个数必在nums中\n2. 于是，我们可以定义一个数组dp来记录到达每一个小于等于target的数的方法数\n3. 将当前状态记为`dp[i]`，即到达i的方法数，而`dp[0] = 1`，因为只有什么都不选一种方法\n4. `1 <= i <= target`，只有 `num <= i`，才能判定为可达\n5. 因此我们可以递推从 `1 ~ target`，遍历nums判断nums中是否有可达的数，如果有则加上`dp[i - num]`\n6. 到此我们可以得到状态转移方程：`dp[i] += dp[i - num]`(每当有num<=i时)，其中num为nums中的数\n\n## 代码实现\n根据上述思路，我们可以得到如下代码：\n~~~python\nclass Solution(object):\n    def combinationSum4(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # 定义数组，记录可达的方法数，初始化\n        dp = [1] + [0] * target\n        # 从1开始递推\n        for i in range(1, target + 1):\n            # 遍历nums\n            for num in nums:\n                # 若num可达\n                if num <= i:\n                    # 累加方法数\n                    dp[i] += dp[i - num]\n\n        # 返回可达target的方法数\n        return dp[target]\n~~~\n","slug":"combined_sum","published":1,"date":"2025-09-16T15:04:20.939Z","updated":"2025-09-24T02:48:25.105Z","_id":"cmfs3zg9u0002gwtlhb459op3","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98\">组合总和问题</span></h1><h2><span id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\">问题描述</span></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>\n<p>题目数据保证答案符合 32 位整数范围。</p>\n<p>示例 1：</p>\n<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>\n<p>示例 2：</p>\n<p>输入：nums = [9], target = 3<br>输出：0</p>\n<p>提示：<br>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 1000<br>nums 中的所有元素 互不相同<br>1 &lt;= target &lt;= 1000</p>\n<h2><span id=\"%E6%80%9D%E8%B7%AF\">思路</span></h2><ol>\n<li>我们可以将此问题看作爬楼梯问题，如果可以到达某一个target，则最后加的一个数必在nums中</li>\n<li>于是，我们可以定义一个数组dp来记录到达每一个小于等于target的数的方法数</li>\n<li>将当前状态记为<code>dp[i]</code>，即到达i的方法数，而<code>dp[0] = 1</code>，因为只有什么都不选一种方法</li>\n<li><code>1 &lt;= i &lt;= target</code>，只有 <code>num &lt;= i</code>，才能判定为可达</li>\n<li>因此我们可以递推从 <code>1 ~ target</code>，遍历nums判断nums中是否有可达的数，如果有则加上<code>dp[i - num]</code></li>\n<li>到此我们可以得到状态转移方程：<code>dp[i] += dp[i - num]</code>(每当有num&lt;=i时)，其中num为nums中的数</li>\n</ol>\n<h2><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h2><p>根据上述思路，我们可以得到如下代码：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">combinationSum4</span>(<span class=\"hljs-params\">self, nums, target</span>):<br>        <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">        :type nums: List[int]</span><br><span class=\"hljs-string\">        :type target: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        \"\"\"</span><br>        <span class=\"hljs-comment\"># 定义数组，记录可达的方法数，初始化</span><br>        dp = [<span class=\"hljs-number\">1</span>] + [<span class=\"hljs-number\">0</span>] * target<br>        <span class=\"hljs-comment\"># 从1开始递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, target + <span class=\"hljs-number\">1</span>):<br>            <span class=\"hljs-comment\"># 遍历nums</span><br>            <span class=\"hljs-keyword\">for</span> num <span class=\"hljs-keyword\">in</span> nums:<br>                <span class=\"hljs-comment\"># 若num可达</span><br>                <span class=\"hljs-keyword\">if</span> num &lt;= i:<br>                    <span class=\"hljs-comment\"># 累加方法数</span><br>                    dp[i] += dp[i - num]<br><br>        <span class=\"hljs-comment\"># 返回可达target的方法数</span><br>        <span class=\"hljs-keyword\">return</span> dp[target]<br></code></pre></td></tr></tbody></table></figure>\n</body></html>","excerpt":"","more":"<h1 id=\"组合总和问题\"><a href=\"#组合总和问题\" class=\"headerlink\" title=\"组合总和问题\"></a>组合总和问题</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>\n<p>题目数据保证答案符合 32 位整数范围。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,2,3], target &#x3D; 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [9], target &#x3D; 3<br>输出：0</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums 中的所有元素 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 1000</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ol>\n<li>我们可以将此问题看作爬楼梯问题，如果可以到达某一个target，则最后加的一个数必在nums中</li>\n<li>于是，我们可以定义一个数组dp来记录到达每一个小于等于target的数的方法数</li>\n<li>将当前状态记为<code>dp[i]</code>，即到达i的方法数，而<code>dp[0] = 1</code>，因为只有什么都不选一种方法</li>\n<li><code>1 &lt;= i &lt;= target</code>，只有 <code>num &lt;= i</code>，才能判定为可达</li>\n<li>因此我们可以递推从 <code>1 ~ target</code>，遍历nums判断nums中是否有可达的数，如果有则加上<code>dp[i - num]</code></li>\n<li>到此我们可以得到状态转移方程：<code>dp[i] += dp[i - num]</code>(每当有num&lt;&#x3D;i时)，其中num为nums中的数</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>根据上述思路，我们可以得到如下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>(<span class=\"hljs-title class_ inherited__\">object</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">combinationSum4</span>(<span class=\"hljs-params\">self, nums, target</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        :type nums: List[int]</span><br><span class=\"hljs-string\">        :type target: int</span><br><span class=\"hljs-string\">        :rtype: int</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-comment\"># 定义数组，记录可达的方法数，初始化</span><br>        dp = [<span class=\"hljs-number\">1</span>] + [<span class=\"hljs-number\">0</span>] * target<br>        <span class=\"hljs-comment\"># 从1开始递推</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, target + <span class=\"hljs-number\">1</span>):<br>            <span class=\"hljs-comment\"># 遍历nums</span><br>            <span class=\"hljs-keyword\">for</span> num <span class=\"hljs-keyword\">in</span> nums:<br>                <span class=\"hljs-comment\"># 若num可达</span><br>                <span class=\"hljs-keyword\">if</span> num &lt;= i:<br>                    <span class=\"hljs-comment\"># 累加方法数</span><br>                    dp[i] += dp[i - num]<br><br>        <span class=\"hljs-comment\"># 返回可达target的方法数</span><br>        <span class=\"hljs-keyword\">return</span> dp[target]<br></code></pre></td></tr></table></figure>\n"},{"title":"定长滑窗问题","date":"2025-09-18T12:18:52.685Z","_content":"\n# 定长滑窗问题\n\n## 定长子串中元音的最大数目\n\n### 题目描述\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n \n\n示例 1：\n\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n\n示例 2：\n\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n\n示例 3：\n\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n\n示例 4：\n\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n\n示例 5：\n\n输入：s = \"tryhard\", k = 4\n输出：1\n\n### 思路\n1. 我们假定一个长度为k的窗口\n2. 若窗口右端为i，则窗口左端为 **i-k+1**，如[2,3,4,5]长度为4，左端即5 - 4 + 1 = 2\n3. 窗口向右滑动，若右边为元音字母，则统计数加1，若左边为元音字母，则统计数减1\n4. 每次移动窗口更新最大值\n5. 循环结束后，返回最大值，即为所求\n\n### 代码实现\n~~~python\n# @灵茶山艾府\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        ans = vowel = 0\n        for i, c in enumerate(s):  # 枚举窗口右端点 i\n            # 1. 右端点进入窗口\n            if c in \"aeiou\":\n                vowel += 1\n\n            left = i - k + 1  # 窗口左端点\n            # 窗口大小不足 k，尚未形成第一个窗口\n            if left < 0:  \n                continue\n\n            # 2. 更新答案\n            ans = max(ans, vowel)\n\n            # 3. 左端点离开窗口，为下一个循环做准备\n            if s[left] in \"aeiou\":\n                vowel -= 1\n        return ans\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** ，其中 n 为字符串的长度\n空间复杂度：**O(1)**\n\n## 半径为 k 的子数组平均值\n\n### 题目描述\n给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。\n\n半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。\n\n构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。\n\nx 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。\n\n例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。\n\n示例 1：\n![示例](../assert/eg1.png)\n\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释：\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n\n示例 2：\n\n输入：nums = [100000], k = 0\n输出：[100000]\n解释：\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n\n示例 3：\n\n输入：nums = [8], k = 100000\n输出：[-1]\n解释：\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n\n### 思路\n1. 与上一题类似，但窗口长度更改为2k+1\n2. 假设窗口右端为i，则窗口左端变为 **(i-2k-1)+1** 即 **i-2k**\n3. 观察可得，中点位置为 **i-k** ，在中点位置即是需要算平均值的元素\n4. 窗口向右移动，添加右侧，减去左侧，更新平均值\n\n### 代码实现\n~~~python\nclass Solution:\n\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\n\n        avgs = [-1] * len(nums)\n\n        s = 0  # 维护窗口元素和\n\n        for i, x in enumerate(nums):\n\n            # 1. 进入窗口\n\n            s += x\n\n            if i < k * 2:  # 窗口大小不足 2k+1\n\n                continue\n\n            # 2. 记录答案\n\n            avgs[i - k] = s // (k * 2 + 1)\n\n            # 3. 离开窗口\n\n            s -= nums[i - k * 2]\n\n        return avgs\n\n# @灵茶山艾府\n~~~\n \n### 复杂度分析\n时间复杂度：**O(n)** ，其中 n 为数组的长度\n空间复杂度：**O(1)** ，返回值不计入\n","source":"_posts/fixed_length_slide_window_problem.md","raw":"---\ntitle: \"定长滑窗问题\"\ntags:\n  - 算法\ndate: \ncategories: \n    - 算法笔记\n---\n\n# 定长滑窗问题\n\n## 定长子串中元音的最大数目\n\n### 题目描述\n给你字符串 s 和整数 k 。\n\n请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n\n英文中的 元音字母 为（a, e, i, o, u）。\n\n \n\n示例 1：\n\n输入：s = \"abciiidef\", k = 3\n输出：3\n解释：子字符串 \"iii\" 包含 3 个元音字母。\n\n示例 2：\n\n输入：s = \"aeiou\", k = 2\n输出：2\n解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n\n示例 3：\n\n输入：s = \"leetcode\", k = 3\n输出：2\n解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n\n示例 4：\n\n输入：s = \"rhythms\", k = 4\n输出：0\n解释：字符串 s 中不含任何元音字母。\n\n示例 5：\n\n输入：s = \"tryhard\", k = 4\n输出：1\n\n### 思路\n1. 我们假定一个长度为k的窗口\n2. 若窗口右端为i，则窗口左端为 **i-k+1**，如[2,3,4,5]长度为4，左端即5 - 4 + 1 = 2\n3. 窗口向右滑动，若右边为元音字母，则统计数加1，若左边为元音字母，则统计数减1\n4. 每次移动窗口更新最大值\n5. 循环结束后，返回最大值，即为所求\n\n### 代码实现\n~~~python\n# @灵茶山艾府\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        ans = vowel = 0\n        for i, c in enumerate(s):  # 枚举窗口右端点 i\n            # 1. 右端点进入窗口\n            if c in \"aeiou\":\n                vowel += 1\n\n            left = i - k + 1  # 窗口左端点\n            # 窗口大小不足 k，尚未形成第一个窗口\n            if left < 0:  \n                continue\n\n            # 2. 更新答案\n            ans = max(ans, vowel)\n\n            # 3. 左端点离开窗口，为下一个循环做准备\n            if s[left] in \"aeiou\":\n                vowel -= 1\n        return ans\n~~~\n\n### 复杂度分析\n时间复杂度：**O(n)** ，其中 n 为字符串的长度\n空间复杂度：**O(1)**\n\n## 半径为 k 的子数组平均值\n\n### 题目描述\n给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。\n\n半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。\n\n构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。\n\nx 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。\n\n例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。\n\n示例 1：\n![示例](../assert/eg1.png)\n\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释：\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n\n示例 2：\n\n输入：nums = [100000], k = 0\n输出：[100000]\n解释：\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n\n示例 3：\n\n输入：nums = [8], k = 100000\n输出：[-1]\n解释：\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n\n### 思路\n1. 与上一题类似，但窗口长度更改为2k+1\n2. 假设窗口右端为i，则窗口左端变为 **(i-2k-1)+1** 即 **i-2k**\n3. 观察可得，中点位置为 **i-k** ，在中点位置即是需要算平均值的元素\n4. 窗口向右移动，添加右侧，减去左侧，更新平均值\n\n### 代码实现\n~~~python\nclass Solution:\n\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\n\n        avgs = [-1] * len(nums)\n\n        s = 0  # 维护窗口元素和\n\n        for i, x in enumerate(nums):\n\n            # 1. 进入窗口\n\n            s += x\n\n            if i < k * 2:  # 窗口大小不足 2k+1\n\n                continue\n\n            # 2. 记录答案\n\n            avgs[i - k] = s // (k * 2 + 1)\n\n            # 3. 离开窗口\n\n            s -= nums[i - k * 2]\n\n        return avgs\n\n# @灵茶山艾府\n~~~\n \n### 复杂度分析\n时间复杂度：**O(n)** ，其中 n 为数组的长度\n空间复杂度：**O(1)** ，返回值不计入\n","slug":"fixed_length_slide_window_problem","published":1,"updated":"2025-09-23T15:26:10.714Z","_id":"cmfs3zg9x000cgwtl34b2ghyq","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E5%AE%9A%E9%95%BF%E6%BB%91%E7%AA%97%E9%97%AE%E9%A2%98\">定长滑窗问题</span></h1><h2><span id=\"%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE\">定长子串中元音的最大数目</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">题目描述</span></h3><p>给你字符串 s 和整数 k 。</p>\n<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>\n<p>英文中的 元音字母 为（a, e, i, o, u）。</p>\n<p>示例 1：</p>\n<p>输入：s = \"abciiidef\", k = 3<br>输出：3<br>解释：子字符串 \"iii\" 包含 3 个元音字母。</p>\n<p>示例 2：</p>\n<p>输入：s = \"aeiou\", k = 2<br>输出：2<br>解释：任意长度为 2 的子字符串都包含 2 个元音字母。</p>\n<p>示例 3：</p>\n<p>输入：s = \"leetcode\", k = 3<br>输出：2<br>解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。</p>\n<p>示例 4：</p>\n<p>输入：s = \"rhythms\", k = 4<br>输出：0<br>解释：字符串 s 中不含任何元音字母。</p>\n<p>示例 5：</p>\n<p>输入：s = \"tryhard\", k = 4<br>输出：1</p>\n<h3><span id=\"%E6%80%9D%E8%B7%AF\">思路</span></h3><ol>\n<li>我们假定一个长度为k的窗口</li>\n<li>若窗口右端为i，则窗口左端为 <strong>i-k+1</strong>，如[2,3,4,5]长度为4，左端即5 - 4 + 1 = 2</li>\n<li>窗口向右滑动，若右边为元音字母，则统计数加1，若左边为元音字母，则统计数减1</li>\n<li>每次移动窗口更新最大值</li>\n<li>循环结束后，返回最大值，即为所求</li>\n</ol>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># @灵茶山艾府</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxVowels</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>        ans = vowel = <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> i, c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):  <span class=\"hljs-comment\"># 枚举窗口右端点 i</span><br>            <span class=\"hljs-comment\"># 1. 右端点进入窗口</span><br>            <span class=\"hljs-keyword\">if</span> c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">\"aeiou\"</span>:<br>                vowel += <span class=\"hljs-number\">1</span><br><br>            left = i - k + <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 窗口左端点</span><br>            <span class=\"hljs-comment\"># 窗口大小不足 k，尚未形成第一个窗口</span><br>            <span class=\"hljs-keyword\">if</span> left &lt; <span class=\"hljs-number\">0</span>:  <br>                <span class=\"hljs-keyword\">continue</span><br><br>            <span class=\"hljs-comment\"># 2. 更新答案</span><br>            ans = <span class=\"hljs-built_in\">max</span>(ans, vowel)<br><br>            <span class=\"hljs-comment\"># 3. 左端点离开窗口，为下一个循环做准备</span><br>            <span class=\"hljs-keyword\">if</span> s[left] <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">\"aeiou\"</span>:<br>                vowel -= <span class=\"hljs-number\">1</span><br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>时间复杂度：<strong>O(n)</strong> ，其中 n 为字符串的长度<br>空间复杂度：<strong>O(1)</strong></p>\n<h2><span id=\"%E5%8D%8A%E5%BE%84%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC\">半径为 k 的子数组平均值</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">题目描述</span></h3><p>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。</p>\n<p>半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p>\n<p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p>\n<p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p>\n<p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。</p>\n<p>示例 1：<br><img src=\"/../assert/eg1.png\" alt=\"示例\"></p>\n<p>输入：nums = [7,4,3,9,1,8,5,2,6], k = 3<br>输出：[-1,-1,-1,5,4,4,-1,-1,-1]<br>解释：</p>\n<ul>\n<li>avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。</li>\n<li>中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。<br>使用截断式 整数除法，avg[3] = 37 / 7 = 5 。</li>\n<li>中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。</li>\n<li>中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。</li>\n<li>avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</li>\n</ul>\n<p>示例 2：</p>\n<p>输入：nums = [100000], k = 0<br>输出：[100000]<br>解释：</p>\n<ul>\n<li>中心为下标 0 且半径 0 的子数组的元素总和是：100000 。<br>avg[0] = 100000 / 1 = 100000 。</li>\n</ul>\n<p>示例 3：</p>\n<p>输入：nums = [8], k = 100000<br>输出：[-1]<br>解释：</p>\n<ul>\n<li>avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</li>\n</ul>\n<h3><span id=\"%E6%80%9D%E8%B7%AF\">思路</span></h3><ol>\n<li>与上一题类似，但窗口长度更改为2k+1</li>\n<li>假设窗口右端为i，则窗口左端变为 <strong>(i-2k-1)+1</strong> 即 <strong>i-2k</strong></li>\n<li>观察可得，中点位置为 <strong>i-k</strong> ，在中点位置即是需要算平均值的元素</li>\n<li>窗口向右移动，添加右侧，减去左侧，更新平均值</li>\n</ol>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getAverages</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br><br>        avgs = [-<span class=\"hljs-number\">1</span>] * <span class=\"hljs-built_in\">len</span>(nums)<br><br>        s = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># 维护窗口元素和</span><br><br>        <span class=\"hljs-keyword\">for</span> i, x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):<br><br>            <span class=\"hljs-comment\"># 1. 进入窗口</span><br><br>            s += x<br><br>            <span class=\"hljs-keyword\">if</span> i &lt; k * <span class=\"hljs-number\">2</span>:  <span class=\"hljs-comment\"># 窗口大小不足 2k+1</span><br><br>                <span class=\"hljs-keyword\">continue</span><br><br>            <span class=\"hljs-comment\"># 2. 记录答案</span><br><br>            avgs[i - k] = s // (k * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)<br><br>            <span class=\"hljs-comment\"># 3. 离开窗口</span><br><br>            s -= nums[i - k * <span class=\"hljs-number\">2</span>]<br><br>        <span class=\"hljs-keyword\">return</span> avgs<br><br><span class=\"hljs-comment\"># @灵茶山艾府</span><br></code></pre></td></tr></tbody></table></figure>\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>时间复杂度：<strong>O(n)</strong> ，其中 n 为数组的长度<br>空间复杂度：<strong>O(1)</strong> ，返回值不计入</p>\n</body></html>","excerpt":"","more":"<h1 id=\"定长滑窗问题\"><a href=\"#定长滑窗问题\" class=\"headerlink\" title=\"定长滑窗问题\"></a>定长滑窗问题</h1><h2 id=\"定长子串中元音的最大数目\"><a href=\"#定长子串中元音的最大数目\" class=\"headerlink\" title=\"定长子串中元音的最大数目\"></a>定长子串中元音的最大数目</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给你字符串 s 和整数 k 。</p>\n<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>\n<p>英文中的 元音字母 为（a, e, i, o, u）。</p>\n<p>示例 1：</p>\n<p>输入：s &#x3D; &quot;abciiidef&quot;, k &#x3D; 3<br>输出：3<br>解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</p>\n<p>示例 2：</p>\n<p>输入：s &#x3D; &quot;aeiou&quot;, k &#x3D; 2<br>输出：2<br>解释：任意长度为 2 的子字符串都包含 2 个元音字母。</p>\n<p>示例 3：</p>\n<p>输入：s &#x3D; &quot;leetcode&quot;, k &#x3D; 3<br>输出：2<br>解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。</p>\n<p>示例 4：</p>\n<p>输入：s &#x3D; &quot;rhythms&quot;, k &#x3D; 4<br>输出：0<br>解释：字符串 s 中不含任何元音字母。</p>\n<p>示例 5：</p>\n<p>输入：s &#x3D; &quot;tryhard&quot;, k &#x3D; 4<br>输出：1</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>我们假定一个长度为k的窗口</li>\n<li>若窗口右端为i，则窗口左端为 <strong>i-k+1</strong>，如[2,3,4,5]长度为4，左端即5 - 4 + 1 &#x3D; 2</li>\n<li>窗口向右滑动，若右边为元音字母，则统计数加1，若左边为元音字母，则统计数减1</li>\n<li>每次移动窗口更新最大值</li>\n<li>循环结束后，返回最大值，即为所求</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># @灵茶山艾府</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxVowels</span>(<span class=\"hljs-params\">self, s: <span class=\"hljs-built_in\">str</span>, k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>        ans = vowel = <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-keyword\">for</span> i, c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(s):  <span class=\"hljs-comment\"># 枚举窗口右端点 i</span><br>            <span class=\"hljs-comment\"># 1. 右端点进入窗口</span><br>            <span class=\"hljs-keyword\">if</span> c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;aeiou&quot;</span>:<br>                vowel += <span class=\"hljs-number\">1</span><br><br>            left = i - k + <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 窗口左端点</span><br>            <span class=\"hljs-comment\"># 窗口大小不足 k，尚未形成第一个窗口</span><br>            <span class=\"hljs-keyword\">if</span> left &lt; <span class=\"hljs-number\">0</span>:  <br>                <span class=\"hljs-keyword\">continue</span><br><br>            <span class=\"hljs-comment\"># 2. 更新答案</span><br>            ans = <span class=\"hljs-built_in\">max</span>(ans, vowel)<br><br>            <span class=\"hljs-comment\"># 3. 左端点离开窗口，为下一个循环做准备</span><br>            <span class=\"hljs-keyword\">if</span> s[left] <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;aeiou&quot;</span>:<br>                vowel -= <span class=\"hljs-number\">1</span><br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度：<strong>O(n)</strong> ，其中 n 为字符串的长度<br>空间复杂度：<strong>O(1)</strong></p>\n<h2 id=\"半径为-k-的子数组平均值\"><a href=\"#半径为-k-的子数组平均值\" class=\"headerlink\" title=\"半径为 k 的子数组平均值\"></a>半径为 k 的子数组平均值</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。</p>\n<p>半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p>\n<p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p>\n<p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p>\n<p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) &#x2F; 4 &#x3D; 11 &#x2F; 4 &#x3D; 2.75，截断后得到 2 。</p>\n<p>示例 1：<br><img src=\"/../assert/eg1.png\" alt=\"示例\"></p>\n<p>输入：nums &#x3D; [7,4,3,9,1,8,5,2,6], k &#x3D; 3<br>输出：[-1,-1,-1,5,4,4,-1,-1,-1]<br>解释：</p>\n<ul>\n<li>avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。</li>\n<li>中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 &#x3D; 37 。<br>使用截断式 整数除法，avg[3] &#x3D; 37 &#x2F; 7 &#x3D; 5 。</li>\n<li>中心为下标 4 的子数组，avg[4] &#x3D; (4 + 3 + 9 + 1 + 8 + 5 + 2) &#x2F; 7 &#x3D; 4 。</li>\n<li>中心为下标 5 的子数组，avg[5] &#x3D; (3 + 9 + 1 + 8 + 5 + 2 + 6) &#x2F; 7 &#x3D; 4 。</li>\n<li>avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</li>\n</ul>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [100000], k &#x3D; 0<br>输出：[100000]<br>解释：</p>\n<ul>\n<li>中心为下标 0 且半径 0 的子数组的元素总和是：100000 。<br>avg[0] &#x3D; 100000 &#x2F; 1 &#x3D; 100000 。</li>\n</ul>\n<p>示例 3：</p>\n<p>输入：nums &#x3D; [8], k &#x3D; 100000<br>输出：[-1]<br>解释：</p>\n<ul>\n<li>avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</li>\n</ul>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>与上一题类似，但窗口长度更改为2k+1</li>\n<li>假设窗口右端为i，则窗口左端变为 <strong>(i-2k-1)+1</strong> 即 <strong>i-2k</strong></li>\n<li>观察可得，中点位置为 <strong>i-k</strong> ，在中点位置即是需要算平均值的元素</li>\n<li>窗口向右移动，添加右侧，减去左侧，更新平均值</li>\n</ol>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">getAverages</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], k: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br><br>        avgs = [-<span class=\"hljs-number\">1</span>] * <span class=\"hljs-built_in\">len</span>(nums)<br><br>        s = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># 维护窗口元素和</span><br><br>        <span class=\"hljs-keyword\">for</span> i, x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(nums):<br><br>            <span class=\"hljs-comment\"># 1. 进入窗口</span><br><br>            s += x<br><br>            <span class=\"hljs-keyword\">if</span> i &lt; k * <span class=\"hljs-number\">2</span>:  <span class=\"hljs-comment\"># 窗口大小不足 2k+1</span><br><br>                <span class=\"hljs-keyword\">continue</span><br><br>            <span class=\"hljs-comment\"># 2. 记录答案</span><br><br>            avgs[i - k] = s // (k * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)<br><br>            <span class=\"hljs-comment\"># 3. 离开窗口</span><br><br>            s -= nums[i - k * <span class=\"hljs-number\">2</span>]<br><br>        <span class=\"hljs-keyword\">return</span> avgs<br><br><span class=\"hljs-comment\"># @灵茶山艾府</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度：<strong>O(n)</strong> ，其中 n 为数组的长度<br>空间复杂度：<strong>O(1)</strong> ，返回值不计入</p>\n"},{"title":"机器学习笔记","date":"2025-09-20T15:11:13.564Z","_content":"  \n  \n  \n  \n  \n  \n  \n  \n# 机器学习\n  \n## 目录\n- [机器学习](#机器学习)\n  - [目录](#目录)\n  - [线性回归](#线性回归)\n    - [一元线性回归](#一元线性回归)\n      - [算法思想](#算法思想)\n      - [评价指标](#评价指标)\n      - [python中的实现](#python中的实现)\n      - [输出结果解读](#输出结果解读)\n    - [多项式回归](#多项式回归)\n      - [算法思想](#算法思想-1)\n      - [代码实现](#代码实现)\n    - [多元线性回归](#多元线性回归)\n      - [算法思想](#算法思想-2)\n      - [模型选择](#模型选择)\n      - [代码实现](#代码实现-1)\n  \n  \n  \n## 线性回归\n  \n[返回目录](#目录 )\n  \n### 一元线性回归\n  \n#### 算法思想\n1. 找到一条曲线 **y = wx + b** ，使得能够根据自变量x 尽可能准确地预测因变量y\n2. 模型最优解为\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?(w^*,%20b^*)%20=%20arg\\min_{i=0}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n即调整w和b使得预测误差平方和最小\n  \n#### 评价指标\n1. 均方误差：误差越小，模型预测效果越好\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?MSE%20=%20\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n2. 均方根误差：误差越小，模型预测效果越好\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?RMSE%20=%20\\sqrt{MSE}%20=%20\\sqrt{\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2}\"/></p>  \n  \n3. 回归平方和：衡量​​回归模型“解释”的因变量变异程度​​（即模型通过自变量预测后，预测值与均值的差异）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSR%20=%20\\sum_{i=1}^m%20(\\hat{y_i}%20-%20\\bar{y})^2\"/></p>  \n  \n4. 残差平方和：衡量​​回归模型“未解释”的因变量变异程度​​（即预测值与实际值的误差）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSE%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n5. 总平方和：衡量​​因变量 y自身的总变异程度​​（即数据自然波动的大小）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SST%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\bar{y})^2%20=%20SSE%20+%20SSR\"/></p>  \n  \n6. 决定系数R^2^: 衡量​​回归模型对因变量变异的解释比例​​（取值范围 [0,1]）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2%20=%20\\frac{SSR}{SST}%20=%201%20-%20\\frac{SSE}{SST}\"/></p>  \n  \n实际中，R2越接近1，说明模型解释的变异越多，拟合效果越好\n<br>\n  \n7. 调整后的决定系数R^2^~d~：在 R2基础上，​​惩罚“无意义的自变量加入”​​，更适合比较不同复杂度的模型\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2_d%20=%201%20-%20\\frac{m-1}{m-d-1}%20\\cdot%20\\frac{SSE}{SST}\"/></p>  \n  \n其中，m为样本量，d为自变量个数，本质是对自由度的惩罚\n  \n#### python中的实现\n\n[回到目录](#目录)\n\n1. 引入pandas模块，读取数据\n  \n~~~python\nimport pandas as pd\ndataframe = pd.read_csv('data.csv')\n~~~\n  \n| 方法 | 描述 | 参数说明 | 返回值 |\n| --- | --- | --- | --- |\n|`pandas.read_csv(filename)` | 读取csv文件 | 文件名或文件路径 | DataFrame |\n|`dataframe.iloc[行索引器，列索引器]` | 获取行和列 | 行索引器(切片)：表示为 `start:stop` 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 `start:stop` 即列的选择范围，当都为空时，默认选择所有列 | DataFrame |\n|`dataframe.loc[行索引器，列索引器]`|获取行和列 | 行索引器(切片)：表示为 `start:stop` 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 `start:stop` 即列的选择范围，当都为空时，默认选择所有列 | DataFrame |\n  \n2. 引入matplotlib模块，绘制图像，其中散点图为pyplot模块中的scatter()方法\n  \n~~~python\nimport matplotlib.pyplot as plt\n# 绘制散点图\nplt.scatter(dataframe['x'], dataframe['y'], color='red')\n# 显示图像\nplt.show()\n~~~\n  \n| 方法 | 描述 | 参数说明 | 返回值 |\n| --- | --- | --- | --- |\n|`matplotlib.pyplot.scatter()` | 绘制数据点 | x: 数据点的横坐标列表<br> y: 数据点的纵坐标列表<br> s: 数据点的大小列表<br> c: 数据点的颜色列表<br> marker: 数据点的标记列表<br> cmap: 颜色映射对象<br> norm: 颜色映射对象<br> vmin: 颜色映射对象<br> vmax: 颜色映射对象<br> alpha: 数据点的透明度列表<br> linewidths: 数据点的线宽列表<br> verts: 数据点的标记列表<br> edgecolors: 数据点的边框颜色列表<br> plotnon | 无 |\n|`matplotlib.pyplot.show()`|显示图|无|无|\n|`matplotlib.pyplot.figure()`|创建一个新图|无|无|\n  \n3. 引入statsmodels模块，增加截距项，进行数据预处理\n  \n~~~python\nimport statsmodels.api as sm\n# 增加截距项，即在原数据最右侧新增一列全为1的列'const'\ndf_const = sm.add_constant(dataframe)\n# 将数据集X和y分别提取出来\nX = df_const.iloc[:, :-1] # 选取除了截距项的所有列作为自变量矩阵\ny = df_const['y'] # 提取因变量列作为因变量向量\n~~~\n  \n|方法|描述|参数说明|返回值|\n|---|---|---|---|\n|`statsmodels.api.add_constant(dataframe)`|增加截距项，即在原数据最右侧新增一列全为1的列'const'|dataframe|增加截距项后的数据集dataframe|\n|`statsmodels.api.OLS(y, X)`|建立OLS模型|y: 因变量向量<br>X: 自变量矩阵|OLS模型对象|\n|`statsmodels.api.qqplot()`|绘制QQ图|data（必选参数）:待检验的样本数据（一维数据）<br> dist（可选参数）:检验分布，默认为正态分布 <br>line（可选参数）: 绘制的参考线，默认为45度线 's'：绘制标准化分位数的参考线（适用于非标准分布）'r--'：自定义直线样式（如红色虚线）<br> ax（可选参数）: 绘图对象 <br>kwargs（可选参数）:绘图参数|无|\n|`statsmodels.api.graphics.plot_regress_exog()`|绘制自变量和因变量的回归图|model: OLS模型对象<br>exog_idx: 自变量索引<br>fig（可选参数）: 绘图对象<br>ax（可选参数）: 绘图对象<br>kwargs（可选参数）:绘图参数|无|\n|`model.fit()`|训练模型|无|无|\n|`model.predict(X)`|预测|X: 自变量矩阵|预测结果向量|\n|`model.summary()`|查看模型报告|无|无|\n  \n4. 建立OLS模型，并训练模型，得到训练结果\n  \n~~~python\n# 建立OLS模型，并训练模型\nmodel = sm.OLS(y, X).fit()\n# 预测\ny_pred = model.predict(X)\n# 查看模型报告\nmodel.summary()\n~~~\nOLS即普通最小二乘法，即最小化残差平方和\n实现步骤：\n* RSS\n![RSS](../assert/machine_learining/1.png )\n* 对所有的参数β求偏导\n![偏导](../assert/machine_learining/2.png )\n* 令导数等于0，联立公式求解，得到所有的参数β\n![联立](../assert/machine_learining/3.png )\n* 解方程组，得到参数β\n![求解](../assert/machine_learining/4.png )\n  \n5. 绘制QQ图\n~~~python\n# 绘制QQ图，用于检验残差是否服从正态分布\nsm.qqplot(model.resid, line='r')\nplt.show()\n~~~\n* 理想情况（完全拟合）\n  \n数据点​​严格沿参考线（如45°线）分布​​，说明样本分位数与理论分位数几乎一致，数据完全服从理论分布。\n* 轻微偏离（可接受）\n  \n数据点整体沿参考线分布，但存在​​局部小幅偏离​​（如在尾部或中间位置有少量点偏离），可能是随机误差导致，通常认为数据近似服从理论分布。\n* 显著偏离（不拟合）\n  \n数据点明显偏离参考线，呈现以下模式时，提示数据与理论分布存在显著差异：\n  \n* 尾部偏离​​：数据点在两端（低分位数或高分位数）偏离参考线（如右偏数据的右尾上翘），说明数据存在厚尾或偏态；\n* ​整体偏移​​：数据点整体平行于参考线但不重合（如整体高于或低于参考线），说明数据分布的位置参数（如均值）与理论分布不同；\n* ​曲线偏离​​：数据点呈曲线形态偏离参考线，说明数据分布的形状参数（如方差、峰度）与理论分布不同。\n  \n6. 残差分析\n~~~python\n# 残差分析\nfig = plt.figure(figsize=(12, 8))\n# 绘制残差图\nfig = sm.graphics.plot_regress_exog(model, 'x', fig=fig)\n~~~\n\n#### 输出结果解读\n\n[回到目录](#目录)\n\n| 参数 | 描述 |\n| --- | --- |\n| Prob (F-statistic) | 模型F统计量的p值，用于判断整个回归模型是否显著。值越小（通常小于0.05），说明模型整体越显著，即至少有一个自变量对因变量有显著影响 |\n| R-squared | 决定系数，表示模型能够解释的因变量总变异的比例。值越接近1，说明模型拟合效果越好 |\n| Adj. R-squared | 调整后的决定系数，在R-squared基础上考虑了自变量个数的影响，惩罚了无意义的变量加入。值越接近1，模型越好，更适合用于比较不同复杂度的模型 |\n| Skew | 残差分布的偏度，衡量残差分布的对称性。值越接近0，说明残差分布越对称，越接近正态分布。正值表示右偏，负值表示左偏。 |\n| Kurtosis | 残差分布的峰度，衡量残差分布的尖锐程度。值越接近3（正态分布的峰度），说明残差分布越接近正态分布。大于3表示分布更尖锐，小于3表示分布更平坦 |\n| P > \\|t\\| | 每个回归系数的t检验p值，用于判断单个自变量是否对因变量有显著影响。值越小（通常小于0.05），说明该自变量对因变量的影响越显著 |\n| coef | 回归系数，表示自变量对因变量的影响程度和方向。系数的绝对值越大，影响越强；系数为正表示正相关，为负表示负相关。 |\n\n### 多项式回归\n\n[回到目录](#目录)\n\n#### 算法思想\n若有一条抛物线隐藏在数据集中，那么在模型中引入二次项或许会得到更好的拟合效果\n\n#### 代码实现\n在[第三步](#python中的实现)增加截距项那一步改进代码\n~~~python\nimport statsmodels.api as sm\n# 增加二次项\ndf_const = sm.add_constant(dataframe)\ndf_const['x_2'] = df_const['x'] ** 2\n# 将数据集X和y分别提取出来 \nX = df_const.loc[:, df_const.columns != 'y'] #自变量\ny = df_const.loc[:, df_const.columns == 'y'] #因变量\n~~~\n\n### 多元线性回归\n\n\n#### 算法思想\n对于p值小于0.05的变量，我们可以认为它对于因变量具有显著影响，但我们无法排除其他因变量也有预测能力的可能，因此需考虑多个变量的组合对因变量的贡献。\n\n#### 模型选择\n* AIC(Akaike Information Criterion,赤池信息准则)\n    * 定义: AIC是一种模型选择准则，用于在多个候选模型中选择最优模型\n    * 计算公式: AIC = 2k - 2ln(L) 其中k是模型参数个数，L是模型的最大似然值\n    * 特点:AIC在模型拟合度和复杂度之间寻求平衡值越小表示模型越好，相比于只考虑拟合优度的指标，AIC引入了对模型复杂度的惩罚项\n* BIC(Bayesian Information Criterion,贝叶斯信息准则)\n    * 定义: BIC是另一种模型选择准则，基于贝叶斯理论\n    * 计算公式: BIC = k×ln(n) - 2ln(L)其中k是模型参数个数，n是样本量，L是模型的最大似然值\n    * 特点:BIC对模型复杂度的惩罚比AIC更严格，当样本量较大时，BIC倾向于选择更简单的模型，值越小表示模型越好\n* 区别\n    * 惩罚程度: BIC对复杂模型的惩罚更重，特别是当样本量较大时\n    * 理论基础: AIC基于信息论，BIC基于贝叶斯理论\n    * 模型选择倾向: AIC可能选择较复杂的模型，BIC倾向于选择较简单的模型\n    * 一致性: BIC具有一致性，当样本量趋于无穷时能选出真实模型；AIC则不具备此性质\n#### 代码实现\n\n* 引入多元线性回归api\n~~~python\nfrom statsmodels.formula.api import ols\n~~~\n* 构建模型\n~~~python\nmodel = ols('y ~ x1 + x2 + x3 + ...', data=dataframe).fit()\n~~~\n* 模型输出\n~~~python\nmodel.summary()\n~~~\n* 注意事项：不同于前两种线性回归，多元线性回归无需在数据集中添加截距项\n* 交互项语法\n~~~python\n# 完整写法\nmodel = ols('y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3', data=dataframe).fit()\n# 等价简写形式\nmodel = ols('y ~ x1 * x2 * x3', data=dataframe).fit()\n~~~\n* 多重共线性可以根据相关系数矩阵和方差膨胀因子(VIF)判断\n~~~python\n# 相关系数矩阵\n\"\"\"corr()\n- args:\n  method: 计算方式\n    - 'pearson':皮尔逊相关系数(默认)\n    - 'kendall':肯德尔相关系数\n    - 'spearman':斯皮尔曼相关系数\n  min_periods: 最小样本数，默认为5\n- return:\n  返回一个DataFrame对象，包含相关系数矩阵\n    相关系数值范围为[-1, 1]\n      1: 完全正相关\n      0: 无线性相关\n      -1: 完全负相关\n\"\"\"\ncorr = dataframe.corr()\n# 方差膨胀因子\nimport statsmodels.stats.outliers_influence as oi\n\"\"\"variance_inflation_factor()\n- args:\n  exog: 输入矩阵\n  exog_idx: 输入矩阵的列索引\n- tips:\n  一般来说，VIF大于4，即认为存在多重共线性。\n\"\"\"\nvif = oi.variance_inflation_factor()\n~~~","source":"_posts/machine_learning_.md","raw":"---\ntitle: 机器学习笔记\ndate: null\ntags:\n  - 算法\n---  \n  \n  \n  \n  \n  \n  \n  \n# 机器学习\n  \n## 目录\n- [机器学习](#机器学习)\n  - [目录](#目录)\n  - [线性回归](#线性回归)\n    - [一元线性回归](#一元线性回归)\n      - [算法思想](#算法思想)\n      - [评价指标](#评价指标)\n      - [python中的实现](#python中的实现)\n      - [输出结果解读](#输出结果解读)\n    - [多项式回归](#多项式回归)\n      - [算法思想](#算法思想-1)\n      - [代码实现](#代码实现)\n    - [多元线性回归](#多元线性回归)\n      - [算法思想](#算法思想-2)\n      - [模型选择](#模型选择)\n      - [代码实现](#代码实现-1)\n  \n  \n  \n## 线性回归\n  \n[返回目录](#目录 )\n  \n### 一元线性回归\n  \n#### 算法思想\n1. 找到一条曲线 **y = wx + b** ，使得能够根据自变量x 尽可能准确地预测因变量y\n2. 模型最优解为\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?(w^*,%20b^*)%20=%20arg\\min_{i=0}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n即调整w和b使得预测误差平方和最小\n  \n#### 评价指标\n1. 均方误差：误差越小，模型预测效果越好\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?MSE%20=%20\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n2. 均方根误差：误差越小，模型预测效果越好\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?RMSE%20=%20\\sqrt{MSE}%20=%20\\sqrt{\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2}\"/></p>  \n  \n3. 回归平方和：衡量​​回归模型“解释”的因变量变异程度​​（即模型通过自变量预测后，预测值与均值的差异）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSR%20=%20\\sum_{i=1}^m%20(\\hat{y_i}%20-%20\\bar{y})^2\"/></p>  \n  \n4. 残差平方和：衡量​​回归模型“未解释”的因变量变异程度​​（即预测值与实际值的误差）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSE%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n  \n5. 总平方和：衡量​​因变量 y自身的总变异程度​​（即数据自然波动的大小）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SST%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\bar{y})^2%20=%20SSE%20+%20SSR\"/></p>  \n  \n6. 决定系数R^2^: 衡量​​回归模型对因变量变异的解释比例​​（取值范围 [0,1]）\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2%20=%20\\frac{SSR}{SST}%20=%201%20-%20\\frac{SSE}{SST}\"/></p>  \n  \n实际中，R2越接近1，说明模型解释的变异越多，拟合效果越好\n<br>\n  \n7. 调整后的决定系数R^2^~d~：在 R2基础上，​​惩罚“无意义的自变量加入”​​，更适合比较不同复杂度的模型\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2_d%20=%201%20-%20\\frac{m-1}{m-d-1}%20\\cdot%20\\frac{SSE}{SST}\"/></p>  \n  \n其中，m为样本量，d为自变量个数，本质是对自由度的惩罚\n  \n#### python中的实现\n\n[回到目录](#目录)\n\n1. 引入pandas模块，读取数据\n  \n~~~python\nimport pandas as pd\ndataframe = pd.read_csv('data.csv')\n~~~\n  \n| 方法 | 描述 | 参数说明 | 返回值 |\n| --- | --- | --- | --- |\n|`pandas.read_csv(filename)` | 读取csv文件 | 文件名或文件路径 | DataFrame |\n|`dataframe.iloc[行索引器，列索引器]` | 获取行和列 | 行索引器(切片)：表示为 `start:stop` 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 `start:stop` 即列的选择范围，当都为空时，默认选择所有列 | DataFrame |\n|`dataframe.loc[行索引器，列索引器]`|获取行和列 | 行索引器(切片)：表示为 `start:stop` 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 `start:stop` 即列的选择范围，当都为空时，默认选择所有列 | DataFrame |\n  \n2. 引入matplotlib模块，绘制图像，其中散点图为pyplot模块中的scatter()方法\n  \n~~~python\nimport matplotlib.pyplot as plt\n# 绘制散点图\nplt.scatter(dataframe['x'], dataframe['y'], color='red')\n# 显示图像\nplt.show()\n~~~\n  \n| 方法 | 描述 | 参数说明 | 返回值 |\n| --- | --- | --- | --- |\n|`matplotlib.pyplot.scatter()` | 绘制数据点 | x: 数据点的横坐标列表<br> y: 数据点的纵坐标列表<br> s: 数据点的大小列表<br> c: 数据点的颜色列表<br> marker: 数据点的标记列表<br> cmap: 颜色映射对象<br> norm: 颜色映射对象<br> vmin: 颜色映射对象<br> vmax: 颜色映射对象<br> alpha: 数据点的透明度列表<br> linewidths: 数据点的线宽列表<br> verts: 数据点的标记列表<br> edgecolors: 数据点的边框颜色列表<br> plotnon | 无 |\n|`matplotlib.pyplot.show()`|显示图|无|无|\n|`matplotlib.pyplot.figure()`|创建一个新图|无|无|\n  \n3. 引入statsmodels模块，增加截距项，进行数据预处理\n  \n~~~python\nimport statsmodels.api as sm\n# 增加截距项，即在原数据最右侧新增一列全为1的列'const'\ndf_const = sm.add_constant(dataframe)\n# 将数据集X和y分别提取出来\nX = df_const.iloc[:, :-1] # 选取除了截距项的所有列作为自变量矩阵\ny = df_const['y'] # 提取因变量列作为因变量向量\n~~~\n  \n|方法|描述|参数说明|返回值|\n|---|---|---|---|\n|`statsmodels.api.add_constant(dataframe)`|增加截距项，即在原数据最右侧新增一列全为1的列'const'|dataframe|增加截距项后的数据集dataframe|\n|`statsmodels.api.OLS(y, X)`|建立OLS模型|y: 因变量向量<br>X: 自变量矩阵|OLS模型对象|\n|`statsmodels.api.qqplot()`|绘制QQ图|data（必选参数）:待检验的样本数据（一维数据）<br> dist（可选参数）:检验分布，默认为正态分布 <br>line（可选参数）: 绘制的参考线，默认为45度线 's'：绘制标准化分位数的参考线（适用于非标准分布）'r--'：自定义直线样式（如红色虚线）<br> ax（可选参数）: 绘图对象 <br>kwargs（可选参数）:绘图参数|无|\n|`statsmodels.api.graphics.plot_regress_exog()`|绘制自变量和因变量的回归图|model: OLS模型对象<br>exog_idx: 自变量索引<br>fig（可选参数）: 绘图对象<br>ax（可选参数）: 绘图对象<br>kwargs（可选参数）:绘图参数|无|\n|`model.fit()`|训练模型|无|无|\n|`model.predict(X)`|预测|X: 自变量矩阵|预测结果向量|\n|`model.summary()`|查看模型报告|无|无|\n  \n4. 建立OLS模型，并训练模型，得到训练结果\n  \n~~~python\n# 建立OLS模型，并训练模型\nmodel = sm.OLS(y, X).fit()\n# 预测\ny_pred = model.predict(X)\n# 查看模型报告\nmodel.summary()\n~~~\nOLS即普通最小二乘法，即最小化残差平方和\n实现步骤：\n* RSS\n![RSS](../assert/machine_learining/1.png )\n* 对所有的参数β求偏导\n![偏导](../assert/machine_learining/2.png )\n* 令导数等于0，联立公式求解，得到所有的参数β\n![联立](../assert/machine_learining/3.png )\n* 解方程组，得到参数β\n![求解](../assert/machine_learining/4.png )\n  \n5. 绘制QQ图\n~~~python\n# 绘制QQ图，用于检验残差是否服从正态分布\nsm.qqplot(model.resid, line='r')\nplt.show()\n~~~\n* 理想情况（完全拟合）\n  \n数据点​​严格沿参考线（如45°线）分布​​，说明样本分位数与理论分位数几乎一致，数据完全服从理论分布。\n* 轻微偏离（可接受）\n  \n数据点整体沿参考线分布，但存在​​局部小幅偏离​​（如在尾部或中间位置有少量点偏离），可能是随机误差导致，通常认为数据近似服从理论分布。\n* 显著偏离（不拟合）\n  \n数据点明显偏离参考线，呈现以下模式时，提示数据与理论分布存在显著差异：\n  \n* 尾部偏离​​：数据点在两端（低分位数或高分位数）偏离参考线（如右偏数据的右尾上翘），说明数据存在厚尾或偏态；\n* ​整体偏移​​：数据点整体平行于参考线但不重合（如整体高于或低于参考线），说明数据分布的位置参数（如均值）与理论分布不同；\n* ​曲线偏离​​：数据点呈曲线形态偏离参考线，说明数据分布的形状参数（如方差、峰度）与理论分布不同。\n  \n6. 残差分析\n~~~python\n# 残差分析\nfig = plt.figure(figsize=(12, 8))\n# 绘制残差图\nfig = sm.graphics.plot_regress_exog(model, 'x', fig=fig)\n~~~\n\n#### 输出结果解读\n\n[回到目录](#目录)\n\n| 参数 | 描述 |\n| --- | --- |\n| Prob (F-statistic) | 模型F统计量的p值，用于判断整个回归模型是否显著。值越小（通常小于0.05），说明模型整体越显著，即至少有一个自变量对因变量有显著影响 |\n| R-squared | 决定系数，表示模型能够解释的因变量总变异的比例。值越接近1，说明模型拟合效果越好 |\n| Adj. R-squared | 调整后的决定系数，在R-squared基础上考虑了自变量个数的影响，惩罚了无意义的变量加入。值越接近1，模型越好，更适合用于比较不同复杂度的模型 |\n| Skew | 残差分布的偏度，衡量残差分布的对称性。值越接近0，说明残差分布越对称，越接近正态分布。正值表示右偏，负值表示左偏。 |\n| Kurtosis | 残差分布的峰度，衡量残差分布的尖锐程度。值越接近3（正态分布的峰度），说明残差分布越接近正态分布。大于3表示分布更尖锐，小于3表示分布更平坦 |\n| P > \\|t\\| | 每个回归系数的t检验p值，用于判断单个自变量是否对因变量有显著影响。值越小（通常小于0.05），说明该自变量对因变量的影响越显著 |\n| coef | 回归系数，表示自变量对因变量的影响程度和方向。系数的绝对值越大，影响越强；系数为正表示正相关，为负表示负相关。 |\n\n### 多项式回归\n\n[回到目录](#目录)\n\n#### 算法思想\n若有一条抛物线隐藏在数据集中，那么在模型中引入二次项或许会得到更好的拟合效果\n\n#### 代码实现\n在[第三步](#python中的实现)增加截距项那一步改进代码\n~~~python\nimport statsmodels.api as sm\n# 增加二次项\ndf_const = sm.add_constant(dataframe)\ndf_const['x_2'] = df_const['x'] ** 2\n# 将数据集X和y分别提取出来 \nX = df_const.loc[:, df_const.columns != 'y'] #自变量\ny = df_const.loc[:, df_const.columns == 'y'] #因变量\n~~~\n\n### 多元线性回归\n\n\n#### 算法思想\n对于p值小于0.05的变量，我们可以认为它对于因变量具有显著影响，但我们无法排除其他因变量也有预测能力的可能，因此需考虑多个变量的组合对因变量的贡献。\n\n#### 模型选择\n* AIC(Akaike Information Criterion,赤池信息准则)\n    * 定义: AIC是一种模型选择准则，用于在多个候选模型中选择最优模型\n    * 计算公式: AIC = 2k - 2ln(L) 其中k是模型参数个数，L是模型的最大似然值\n    * 特点:AIC在模型拟合度和复杂度之间寻求平衡值越小表示模型越好，相比于只考虑拟合优度的指标，AIC引入了对模型复杂度的惩罚项\n* BIC(Bayesian Information Criterion,贝叶斯信息准则)\n    * 定义: BIC是另一种模型选择准则，基于贝叶斯理论\n    * 计算公式: BIC = k×ln(n) - 2ln(L)其中k是模型参数个数，n是样本量，L是模型的最大似然值\n    * 特点:BIC对模型复杂度的惩罚比AIC更严格，当样本量较大时，BIC倾向于选择更简单的模型，值越小表示模型越好\n* 区别\n    * 惩罚程度: BIC对复杂模型的惩罚更重，特别是当样本量较大时\n    * 理论基础: AIC基于信息论，BIC基于贝叶斯理论\n    * 模型选择倾向: AIC可能选择较复杂的模型，BIC倾向于选择较简单的模型\n    * 一致性: BIC具有一致性，当样本量趋于无穷时能选出真实模型；AIC则不具备此性质\n#### 代码实现\n\n* 引入多元线性回归api\n~~~python\nfrom statsmodels.formula.api import ols\n~~~\n* 构建模型\n~~~python\nmodel = ols('y ~ x1 + x2 + x3 + ...', data=dataframe).fit()\n~~~\n* 模型输出\n~~~python\nmodel.summary()\n~~~\n* 注意事项：不同于前两种线性回归，多元线性回归无需在数据集中添加截距项\n* 交互项语法\n~~~python\n# 完整写法\nmodel = ols('y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3', data=dataframe).fit()\n# 等价简写形式\nmodel = ols('y ~ x1 * x2 * x3', data=dataframe).fit()\n~~~\n* 多重共线性可以根据相关系数矩阵和方差膨胀因子(VIF)判断\n~~~python\n# 相关系数矩阵\n\"\"\"corr()\n- args:\n  method: 计算方式\n    - 'pearson':皮尔逊相关系数(默认)\n    - 'kendall':肯德尔相关系数\n    - 'spearman':斯皮尔曼相关系数\n  min_periods: 最小样本数，默认为5\n- return:\n  返回一个DataFrame对象，包含相关系数矩阵\n    相关系数值范围为[-1, 1]\n      1: 完全正相关\n      0: 无线性相关\n      -1: 完全负相关\n\"\"\"\ncorr = dataframe.corr()\n# 方差膨胀因子\nimport statsmodels.stats.outliers_influence as oi\n\"\"\"variance_inflation_factor()\n- args:\n  exog: 输入矩阵\n  exog_idx: 输入矩阵的列索引\n- tips:\n  一般来说，VIF大于4，即认为存在多重共线性。\n\"\"\"\nvif = oi.variance_inflation_factor()\n~~~","slug":"machine_learning_","published":1,"updated":"2025-09-25T13:20:57.882Z","_id":"cmfwpff3u0000t8tl9ypkdwm1","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\">机器学习</span></h1><h2><span id=\"%E7%9B%AE%E5%BD%95\">目录</span></h2><ul>\n<li><a href=\"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\">机器学习</a><ul>\n<li><a href=\"#%E7%9B%AE%E5%BD%95\">目录</a></li>\n<li><a href=\"#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">线性回归</a><ul>\n<li><a href=\"#%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">一元线性回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</a></li>\n<li><a href=\"#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87\">评价指标</a></li>\n<li><a href=\"#python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">python中的实现</a></li>\n<li><a href=\"#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB\">输出结果解读</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92\">多项式回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1\">算法思想</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">多元线性回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2\">算法思想</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9\">模型选择</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1\">代码实现</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">线性回归</span></h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3><span id=\"%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">一元线性回归</span></h3><h4><span id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</span></h4><ol>\n<li>找到一条曲线 <strong>y = wx + b</strong> ，使得能够根据自变量x 尽可能准确地预测因变量y</li>\n<li>模型最优解为<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?(w^*,%20b^*)%20=%20arg\\min_{i=0}^m%20(y_i%20-%20\\hat{y}_i)^2\"></p></li>\n</ol>\n<p>即调整w和b使得预测误差平方和最小</p>\n<h4><span id=\"%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87\">评价指标</span></h4><ol>\n<li><p>均方误差：误差越小，模型预测效果越好</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?MSE%20=%20\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"></p>  \n</li>\n<li><p>均方根误差：误差越小，模型预测效果越好</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?RMSE%20=%20\\sqrt{MSE}%20=%20\\sqrt{\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2}\"></p>  \n</li>\n<li><p>回归平方和：衡量​​回归模型“解释”的因变量变异程度​​（即模型通过自变量预测后，预测值与均值的差异）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSR%20=%20\\sum_{i=1}^m%20(\\hat{y_i}%20-%20\\bar{y})^2\"></p>  \n</li>\n<li><p>残差平方和：衡量​​回归模型“未解释”的因变量变异程度​​（即预测值与实际值的误差）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSE%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"></p>  \n</li>\n<li><p>总平方和：衡量​​因变量 y自身的总变异程度​​（即数据自然波动的大小）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SST%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\bar{y})^2%20=%20SSE%20+%20SSR\"></p>  \n</li>\n<li><p>决定系数R^2^: 衡量​​回归模型对因变量变异的解释比例​​（取值范围 [0,1]）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2%20=%20\\frac{SSR}{SST}%20=%201%20-%20\\frac{SSE}{SST}\"></p></li>\n</ol>\n<p>实际中，R2越接近1，说明模型解释的变异越多，拟合效果越好<br><br></p>\n<ol start=\"7\">\n<li>调整后的决定系数R^2^<del>d</del>：在 R2基础上，​​惩罚“无意义的自变量加入”​​，更适合比较不同复杂度的模型<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2_d%20=%201%20-%20\\frac{m-1}{m-d-1}%20\\cdot%20\\frac{SSE}{SST}\"></p></li>\n</ol>\n<p>其中，m为样本量，d为自变量个数，本质是对自由度的惩罚</p>\n<h4><span id=\"python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">python中的实现</span></h4><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<ol>\n<li>引入pandas模块，读取数据</li>\n</ol>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>dataframe = pd.read_csv(<span class=\"hljs-string\">'data.csv'</span>)<br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pandas.read_csv(filename)</code></td>\n<td>读取csv文件</td>\n<td>文件名或文件路径</td>\n<td>DataFrame</td>\n</tr>\n<tr>\n<td><code>dataframe.iloc[行索引器，列索引器]</code></td>\n<td>获取行和列</td>\n<td>行索引器(切片)：表示为 <code>start:stop</code> 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 <code>start:stop</code> 即列的选择范围，当都为空时，默认选择所有列</td>\n<td>DataFrame</td>\n</tr>\n<tr>\n<td><code>dataframe.loc[行索引器，列索引器]</code></td>\n<td>获取行和列</td>\n<td>行索引器(切片)：表示为 <code>start:stop</code> 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 <code>start:stop</code> 即列的选择范围，当都为空时，默认选择所有列</td>\n<td>DataFrame</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>引入matplotlib模块，绘制图像，其中散点图为pyplot模块中的scatter()方法</li>\n</ol>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><span class=\"hljs-comment\"># 绘制散点图</span><br>plt.scatter(dataframe[<span class=\"hljs-string\">'x'</span>], dataframe[<span class=\"hljs-string\">'y'</span>], color=<span class=\"hljs-string\">'red'</span>)<br><span class=\"hljs-comment\"># 显示图像</span><br>plt.show()<br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>matplotlib.pyplot.scatter()</code></td>\n<td>绘制数据点</td>\n<td>x: 数据点的横坐标列表<br> y: 数据点的纵坐标列表<br> s: 数据点的大小列表<br> c: 数据点的颜色列表<br> marker: 数据点的标记列表<br> cmap: 颜色映射对象<br> norm: 颜色映射对象<br> vmin: 颜色映射对象<br> vmax: 颜色映射对象<br> alpha: 数据点的透明度列表<br> linewidths: 数据点的线宽列表<br> verts: 数据点的标记列表<br> edgecolors: 数据点的边框颜色列表<br> plotnon</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>matplotlib.pyplot.show()</code></td>\n<td>显示图</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>matplotlib.pyplot.figure()</code></td>\n<td>创建一个新图</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>引入statsmodels模块，增加截距项，进行数据预处理</li>\n</ol>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> statsmodels.api <span class=\"hljs-keyword\">as</span> sm<br><span class=\"hljs-comment\"># 增加截距项，即在原数据最右侧新增一列全为1的列'const'</span><br>df_const = sm.add_constant(dataframe)<br><span class=\"hljs-comment\"># 将数据集X和y分别提取出来</span><br>X = df_const.iloc[:, :-<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\"># 选取除了截距项的所有列作为自变量矩阵</span><br>y = df_const[<span class=\"hljs-string\">'y'</span>] <span class=\"hljs-comment\"># 提取因变量列作为因变量向量</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>statsmodels.api.add_constant(dataframe)</code></td>\n<td>增加截距项，即在原数据最右侧新增一列全为1的列'const'</td>\n<td>dataframe</td>\n<td>增加截距项后的数据集dataframe</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.OLS(y, X)</code></td>\n<td>建立OLS模型</td>\n<td>y: 因变量向量<br>X: 自变量矩阵</td>\n<td>OLS模型对象</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.qqplot()</code></td>\n<td>绘制QQ图</td>\n<td>data（必选参数）:待检验的样本数据（一维数据）<br> dist（可选参数）:检验分布，默认为正态分布 <br>line（可选参数）: 绘制的参考线，默认为45度线 's'：绘制标准化分位数的参考线（适用于非标准分布）'r--'：自定义直线样式（如红色虚线）<br> ax（可选参数）: 绘图对象 <br>kwargs（可选参数）:绘图参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.graphics.plot_regress_exog()</code></td>\n<td>绘制自变量和因变量的回归图</td>\n<td>model: OLS模型对象<br>exog_idx: 自变量索引<br>fig（可选参数）: 绘图对象<br>ax（可选参数）: 绘图对象<br>kwargs（可选参数）:绘图参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>model.fit()</code></td>\n<td>训练模型</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>model.predict(X)</code></td>\n<td>预测</td>\n<td>X: 自变量矩阵</td>\n<td>预测结果向量</td>\n</tr>\n<tr>\n<td><code>model.summary()</code></td>\n<td>查看模型报告</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li>建立OLS模型，并训练模型，得到训练结果</li>\n</ol>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 建立OLS模型，并训练模型</span><br>model = sm.OLS(y, X).fit()<br><span class=\"hljs-comment\"># 预测</span><br>y_pred = model.predict(X)<br><span class=\"hljs-comment\"># 查看模型报告</span><br>model.summary()<br></code></pre></td></tr></tbody></table></figure>\n<p>OLS即普通最小二乘法，即最小化残差平方和<br>实现步骤：</p>\n<ul>\n<li>RSS<br><img src=\"/../assert/machine_learining/1.png\" alt=\"RSS\"></li>\n<li>对所有的参数β求偏导<br><img src=\"/../assert/machine_learining/2.png\" alt=\"偏导\"></li>\n<li>令导数等于0，联立公式求解，得到所有的参数β<br><img src=\"/../assert/machine_learining/3.png\" alt=\"联立\"></li>\n<li>解方程组，得到参数β<br><img src=\"/../assert/machine_learining/4.png\" alt=\"求解\"></li>\n</ul>\n<ol start=\"5\">\n<li>绘制QQ图<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 绘制QQ图，用于检验残差是否服从正态分布</span><br>sm.qqplot(model.resid, line=<span class=\"hljs-string\">'r'</span>)<br>plt.show()<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<ul>\n<li>理想情况（完全拟合）</li>\n</ul>\n<p>数据点​​严格沿参考线（如45°线）分布​​，说明样本分位数与理论分位数几乎一致，数据完全服从理论分布。</p>\n<ul>\n<li>轻微偏离（可接受）</li>\n</ul>\n<p>数据点整体沿参考线分布，但存在​​局部小幅偏离​​（如在尾部或中间位置有少量点偏离），可能是随机误差导致，通常认为数据近似服从理论分布。</p>\n<ul>\n<li>显著偏离（不拟合）</li>\n</ul>\n<p>数据点明显偏离参考线，呈现以下模式时，提示数据与理论分布存在显著差异：</p>\n<ul>\n<li>尾部偏离​​：数据点在两端（低分位数或高分位数）偏离参考线（如右偏数据的右尾上翘），说明数据存在厚尾或偏态；</li>\n<li>​整体偏移​​：数据点整体平行于参考线但不重合（如整体高于或低于参考线），说明数据分布的位置参数（如均值）与理论分布不同；</li>\n<li>​曲线偏离​​：数据点呈曲线形态偏离参考线，说明数据分布的形状参数（如方差、峰度）与理论分布不同。</li>\n</ul>\n<ol start=\"6\">\n<li>残差分析<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 残差分析</span><br>fig = plt.figure(figsize=(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">8</span>))<br><span class=\"hljs-comment\"># 绘制残差图</span><br>fig = sm.graphics.plot_regress_exog(model, <span class=\"hljs-string\">'x'</span>, fig=fig)<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4><span id=\"%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB\">输出结果解读</span></h4><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Prob (F-statistic)</td>\n<td>模型F统计量的p值，用于判断整个回归模型是否显著。值越小（通常小于0.05），说明模型整体越显著，即至少有一个自变量对因变量有显著影响</td>\n</tr>\n<tr>\n<td>R-squared</td>\n<td>决定系数，表示模型能够解释的因变量总变异的比例。值越接近1，说明模型拟合效果越好</td>\n</tr>\n<tr>\n<td>Adj. R-squared</td>\n<td>调整后的决定系数，在R-squared基础上考虑了自变量个数的影响，惩罚了无意义的变量加入。值越接近1，模型越好，更适合用于比较不同复杂度的模型</td>\n</tr>\n<tr>\n<td>Skew</td>\n<td>残差分布的偏度，衡量残差分布的对称性。值越接近0，说明残差分布越对称，越接近正态分布。正值表示右偏，负值表示左偏。</td>\n</tr>\n<tr>\n<td>Kurtosis</td>\n<td>残差分布的峰度，衡量残差分布的尖锐程度。值越接近3（正态分布的峰度），说明残差分布越接近正态分布。大于3表示分布更尖锐，小于3表示分布更平坦</td>\n</tr>\n<tr>\n<td>P &gt; |t|</td>\n<td>每个回归系数的t检验p值，用于判断单个自变量是否对因变量有显著影响。值越小（通常小于0.05），说明该自变量对因变量的影响越显著</td>\n</tr>\n<tr>\n<td>coef</td>\n<td>回归系数，表示自变量对因变量的影响程度和方向。系数的绝对值越大，影响越强；系数为正表示正相关，为负表示负相关。</td>\n</tr>\n</tbody></table>\n<h3><span id=\"%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92\">多项式回归</span></h3><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<h4><span id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</span></h4><p>若有一条抛物线隐藏在数据集中，那么在模型中引入二次项或许会得到更好的拟合效果</p>\n<h4><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h4><p>在<a href=\"#python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">第三步</a>增加截距项那一步改进代码</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> statsmodels.api <span class=\"hljs-keyword\">as</span> sm<br><span class=\"hljs-comment\"># 增加二次项</span><br>df_const = sm.add_constant(dataframe)<br>df_const[<span class=\"hljs-string\">'x_2'</span>] = df_const[<span class=\"hljs-string\">'x'</span>] ** <span class=\"hljs-number\">2</span><br><span class=\"hljs-comment\"># 将数据集X和y分别提取出来 </span><br>X = df_const.loc[:, df_const.columns != <span class=\"hljs-string\">'y'</span>] <span class=\"hljs-comment\">#自变量</span><br>y = df_const.loc[:, df_const.columns == <span class=\"hljs-string\">'y'</span>] <span class=\"hljs-comment\">#因变量</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">多元线性回归</span></h3><h4><span id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</span></h4><p>对于p值小于0.05的变量，我们可以认为它对于因变量具有显著影响，但我们无法排除其他因变量也有预测能力的可能，因此需考虑多个变量的组合对因变量的贡献。</p>\n<h4><span id=\"%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9\">模型选择</span></h4><ul>\n<li>AIC(Akaike Information Criterion,赤池信息准则)<ul>\n<li>定义: AIC是一种模型选择准则，用于在多个候选模型中选择最优模型</li>\n<li>计算公式: AIC = 2k - 2ln(L) 其中k是模型参数个数，L是模型的最大似然值</li>\n<li>特点:AIC在模型拟合度和复杂度之间寻求平衡值越小表示模型越好，相比于只考虑拟合优度的指标，AIC引入了对模型复杂度的惩罚项</li>\n</ul>\n</li>\n<li>BIC(Bayesian Information Criterion,贝叶斯信息准则)<ul>\n<li>定义: BIC是另一种模型选择准则，基于贝叶斯理论</li>\n<li>计算公式: BIC = k×ln(n) - 2ln(L)其中k是模型参数个数，n是样本量，L是模型的最大似然值</li>\n<li>特点:BIC对模型复杂度的惩罚比AIC更严格，当样本量较大时，BIC倾向于选择更简单的模型，值越小表示模型越好</li>\n</ul>\n</li>\n<li>区别<ul>\n<li>惩罚程度: BIC对复杂模型的惩罚更重，特别是当样本量较大时</li>\n<li>理论基础: AIC基于信息论，BIC基于贝叶斯理论</li>\n<li>模型选择倾向: AIC可能选择较复杂的模型，BIC倾向于选择较简单的模型</li>\n<li>一致性: BIC具有一致性，当样本量趋于无穷时能选出真实模型；AIC则不具备此性质</li>\n</ul>\n</li>\n</ul>\n<h4><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h4><ul>\n<li>引入多元线性回归api<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> statsmodels.formula.api <span class=\"hljs-keyword\">import</span> ols<br></code></pre></td></tr></tbody></table></figure></li>\n<li>构建模型<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">model = ols(<span class=\"hljs-string\">'y ~ x1 + x2 + x3 + ...'</span>, data=dataframe).fit()<br></code></pre></td></tr></tbody></table></figure></li>\n<li>模型输出<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">model.summary()<br></code></pre></td></tr></tbody></table></figure></li>\n<li>注意事项：不同于前两种线性回归，多元线性回归无需在数据集中添加截距项</li>\n<li>交互项语法<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 完整写法</span><br>model = ols(<span class=\"hljs-string\">'y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3'</span>, data=dataframe).fit()<br><span class=\"hljs-comment\"># 等价简写形式</span><br>model = ols(<span class=\"hljs-string\">'y ~ x1 * x2 * x3'</span>, data=dataframe).fit()<br></code></pre></td></tr></tbody></table></figure></li>\n<li>多重共线性可以根据相关系数矩阵和方差膨胀因子(VIF)判断<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 相关系数矩阵</span><br><span class=\"hljs-string\">\"\"\"corr()</span><br><span class=\"hljs-string\">- args:</span><br><span class=\"hljs-string\">  method: 计算方式</span><br><span class=\"hljs-string\">    - 'pearson':皮尔逊相关系数(默认)</span><br><span class=\"hljs-string\">    - 'kendall':肯德尔相关系数</span><br><span class=\"hljs-string\">    - 'spearman':斯皮尔曼相关系数</span><br><span class=\"hljs-string\">  min_periods: 最小样本数，默认为5</span><br><span class=\"hljs-string\">- return:</span><br><span class=\"hljs-string\">  返回一个DataFrame对象，包含相关系数矩阵</span><br><span class=\"hljs-string\">    相关系数值范围为[-1, 1]</span><br><span class=\"hljs-string\">      1: 完全正相关</span><br><span class=\"hljs-string\">      0: 无线性相关</span><br><span class=\"hljs-string\">      -1: 完全负相关</span><br><span class=\"hljs-string\">\"\"\"</span><br>corr = dataframe.corr()<br><span class=\"hljs-comment\"># 方差膨胀因子</span><br><span class=\"hljs-keyword\">import</span> statsmodels.stats.outliers_influence <span class=\"hljs-keyword\">as</span> oi<br><span class=\"hljs-string\">\"\"\"variance_inflation_factor()</span><br><span class=\"hljs-string\">- args:</span><br><span class=\"hljs-string\">  exog: 输入矩阵</span><br><span class=\"hljs-string\">  exog_idx: 输入矩阵的列索引</span><br><span class=\"hljs-string\">- tips:</span><br><span class=\"hljs-string\">  一般来说，VIF大于4，即认为存在多重共线性。</span><br><span class=\"hljs-string\">\"\"\"</span><br>vif = oi.variance_inflation_factor()<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</body></html>","excerpt":"","more":"<h1 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\">机器学习</a><ul>\n<li><a href=\"#%E7%9B%AE%E5%BD%95\">目录</a></li>\n<li><a href=\"#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">线性回归</a><ul>\n<li><a href=\"#%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">一元线性回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</a></li>\n<li><a href=\"#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87\">评价指标</a></li>\n<li><a href=\"#python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">python中的实现</a></li>\n<li><a href=\"#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB\">输出结果解读</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92\">多项式回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1\">算法思想</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92\">多元线性回归</a><ul>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2\">算法思想</a></li>\n<li><a href=\"#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9\">模型选择</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1\">代码实现</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><p><a href=\"#%E7%9B%AE%E5%BD%95\">返回目录</a></p>\n<h3 id=\"一元线性回归\"><a href=\"#一元线性回归\" class=\"headerlink\" title=\"一元线性回归\"></a>一元线性回归</h3><h4 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h4><ol>\n<li>找到一条曲线 <strong>y &#x3D; wx + b</strong> ，使得能够根据自变量x 尽可能准确地预测因变量y</li>\n<li>模型最优解为<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?(w^*,%20b^*)%20=%20arg\\min_{i=0}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p></li>\n</ol>\n<p>即调整w和b使得预测误差平方和最小</p>\n<h4 id=\"评价指标\"><a href=\"#评价指标\" class=\"headerlink\" title=\"评价指标\"></a>评价指标</h4><ol>\n<li><p>均方误差：误差越小，模型预测效果越好</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?MSE%20=%20\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n</li>\n<li><p>均方根误差：误差越小，模型预测效果越好</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?RMSE%20=%20\\sqrt{MSE}%20=%20\\sqrt{\\frac{1}{m}%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2}\"/></p>  \n</li>\n<li><p>回归平方和：衡量​​回归模型“解释”的因变量变异程度​​（即模型通过自变量预测后，预测值与均值的差异）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSR%20=%20\\sum_{i=1}^m%20(\\hat{y_i}%20-%20\\bar{y})^2\"/></p>  \n</li>\n<li><p>残差平方和：衡量​​回归模型“未解释”的因变量变异程度​​（即预测值与实际值的误差）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SSE%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\hat{y}_i)^2\"/></p>  \n</li>\n<li><p>总平方和：衡量​​因变量 y自身的总变异程度​​（即数据自然波动的大小）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?SST%20=%20\\sum_{i=1}^m%20(y_i%20-%20\\bar{y})^2%20=%20SSE%20+%20SSR\"/></p>  \n</li>\n<li><p>决定系数R^2^: 衡量​​回归模型对因变量变异的解释比例​​（取值范围 [0,1]）</p>\n<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2%20=%20\\frac{SSR}{SST}%20=%201%20-%20\\frac{SSE}{SST}\"/></p></li>\n</ol>\n<p>实际中，R2越接近1，说明模型解释的变异越多，拟合效果越好<br><br></p>\n<ol start=\"7\">\n<li>调整后的决定系数R^2^<del>d</del>：在 R2基础上，​​惩罚“无意义的自变量加入”​​，更适合比较不同复杂度的模型<p align=\"center\"><img src=\"https://latex.codecogs.com/gif.latex?R^2_d%20=%201%20-%20\\frac{m-1}{m-d-1}%20\\cdot%20\\frac{SSE}{SST}\"/></p></li>\n</ol>\n<p>其中，m为样本量，d为自变量个数，本质是对自由度的惩罚</p>\n<h4 id=\"python中的实现\"><a href=\"#python中的实现\" class=\"headerlink\" title=\"python中的实现\"></a>python中的实现</h4><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<ol>\n<li>引入pandas模块，读取数据</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>dataframe = pd.read_csv(<span class=\"hljs-string\">&#x27;data.csv&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pandas.read_csv(filename)</code></td>\n<td>读取csv文件</td>\n<td>文件名或文件路径</td>\n<td>DataFrame</td>\n</tr>\n<tr>\n<td><code>dataframe.iloc[行索引器，列索引器]</code></td>\n<td>获取行和列</td>\n<td>行索引器(切片)：表示为 <code>start:stop</code> 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 <code>start:stop</code> 即列的选择范围，当都为空时，默认选择所有列</td>\n<td>DataFrame</td>\n</tr>\n<tr>\n<td><code>dataframe.loc[行索引器，列索引器]</code></td>\n<td>获取行和列</td>\n<td>行索引器(切片)：表示为 <code>start:stop</code> 即行的选择范围，当都为空时，默认选择所有行 <br> 列索引器(切片)：表示为 <code>start:stop</code> 即列的选择范围，当都为空时，默认选择所有列</td>\n<td>DataFrame</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>引入matplotlib模块，绘制图像，其中散点图为pyplot模块中的scatter()方法</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><span class=\"hljs-comment\"># 绘制散点图</span><br>plt.scatter(dataframe[<span class=\"hljs-string\">&#x27;x&#x27;</span>], dataframe[<span class=\"hljs-string\">&#x27;y&#x27;</span>], color=<span class=\"hljs-string\">&#x27;red&#x27;</span>)<br><span class=\"hljs-comment\"># 显示图像</span><br>plt.show()<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>matplotlib.pyplot.scatter()</code></td>\n<td>绘制数据点</td>\n<td>x: 数据点的横坐标列表<br> y: 数据点的纵坐标列表<br> s: 数据点的大小列表<br> c: 数据点的颜色列表<br> marker: 数据点的标记列表<br> cmap: 颜色映射对象<br> norm: 颜色映射对象<br> vmin: 颜色映射对象<br> vmax: 颜色映射对象<br> alpha: 数据点的透明度列表<br> linewidths: 数据点的线宽列表<br> verts: 数据点的标记列表<br> edgecolors: 数据点的边框颜色列表<br> plotnon</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>matplotlib.pyplot.show()</code></td>\n<td>显示图</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>matplotlib.pyplot.figure()</code></td>\n<td>创建一个新图</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>引入statsmodels模块，增加截距项，进行数据预处理</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> statsmodels.api <span class=\"hljs-keyword\">as</span> sm<br><span class=\"hljs-comment\"># 增加截距项，即在原数据最右侧新增一列全为1的列&#x27;const&#x27;</span><br>df_const = sm.add_constant(dataframe)<br><span class=\"hljs-comment\"># 将数据集X和y分别提取出来</span><br>X = df_const.iloc[:, :-<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\"># 选取除了截距项的所有列作为自变量矩阵</span><br>y = df_const[<span class=\"hljs-string\">&#x27;y&#x27;</span>] <span class=\"hljs-comment\"># 提取因变量列作为因变量向量</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>参数说明</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>statsmodels.api.add_constant(dataframe)</code></td>\n<td>增加截距项，即在原数据最右侧新增一列全为1的列&#39;const&#39;</td>\n<td>dataframe</td>\n<td>增加截距项后的数据集dataframe</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.OLS(y, X)</code></td>\n<td>建立OLS模型</td>\n<td>y: 因变量向量<br>X: 自变量矩阵</td>\n<td>OLS模型对象</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.qqplot()</code></td>\n<td>绘制QQ图</td>\n<td>data（必选参数）:待检验的样本数据（一维数据）<br> dist（可选参数）:检验分布，默认为正态分布 <br>line（可选参数）: 绘制的参考线，默认为45度线 &#39;s&#39;：绘制标准化分位数的参考线（适用于非标准分布）&#39;r--&#39;：自定义直线样式（如红色虚线）<br> ax（可选参数）: 绘图对象 <br>kwargs（可选参数）:绘图参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>statsmodels.api.graphics.plot_regress_exog()</code></td>\n<td>绘制自变量和因变量的回归图</td>\n<td>model: OLS模型对象<br>exog_idx: 自变量索引<br>fig（可选参数）: 绘图对象<br>ax（可选参数）: 绘图对象<br>kwargs（可选参数）:绘图参数</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>model.fit()</code></td>\n<td>训练模型</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>model.predict(X)</code></td>\n<td>预测</td>\n<td>X: 自变量矩阵</td>\n<td>预测结果向量</td>\n</tr>\n<tr>\n<td><code>model.summary()</code></td>\n<td>查看模型报告</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li>建立OLS模型，并训练模型，得到训练结果</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 建立OLS模型，并训练模型</span><br>model = sm.OLS(y, X).fit()<br><span class=\"hljs-comment\"># 预测</span><br>y_pred = model.predict(X)<br><span class=\"hljs-comment\"># 查看模型报告</span><br>model.summary()<br></code></pre></td></tr></table></figure>\n<p>OLS即普通最小二乘法，即最小化残差平方和<br>实现步骤：</p>\n<ul>\n<li>RSS<br><img src=\"/../assert/machine_learining/1.png\" alt=\"RSS\"></li>\n<li>对所有的参数β求偏导<br><img src=\"/../assert/machine_learining/2.png\" alt=\"偏导\"></li>\n<li>令导数等于0，联立公式求解，得到所有的参数β<br><img src=\"/../assert/machine_learining/3.png\" alt=\"联立\"></li>\n<li>解方程组，得到参数β<br><img src=\"/../assert/machine_learining/4.png\" alt=\"求解\"></li>\n</ul>\n<ol start=\"5\">\n<li>绘制QQ图<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 绘制QQ图，用于检验残差是否服从正态分布</span><br>sm.qqplot(model.resid, line=<span class=\"hljs-string\">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>理想情况（完全拟合）</li>\n</ul>\n<p>数据点​​严格沿参考线（如45°线）分布​​，说明样本分位数与理论分位数几乎一致，数据完全服从理论分布。</p>\n<ul>\n<li>轻微偏离（可接受）</li>\n</ul>\n<p>数据点整体沿参考线分布，但存在​​局部小幅偏离​​（如在尾部或中间位置有少量点偏离），可能是随机误差导致，通常认为数据近似服从理论分布。</p>\n<ul>\n<li>显著偏离（不拟合）</li>\n</ul>\n<p>数据点明显偏离参考线，呈现以下模式时，提示数据与理论分布存在显著差异：</p>\n<ul>\n<li>尾部偏离​​：数据点在两端（低分位数或高分位数）偏离参考线（如右偏数据的右尾上翘），说明数据存在厚尾或偏态；</li>\n<li>​整体偏移​​：数据点整体平行于参考线但不重合（如整体高于或低于参考线），说明数据分布的位置参数（如均值）与理论分布不同；</li>\n<li>​曲线偏离​​：数据点呈曲线形态偏离参考线，说明数据分布的形状参数（如方差、峰度）与理论分布不同。</li>\n</ul>\n<ol start=\"6\">\n<li>残差分析<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 残差分析</span><br>fig = plt.figure(figsize=(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">8</span>))<br><span class=\"hljs-comment\"># 绘制残差图</span><br>fig = sm.graphics.plot_regress_exog(model, <span class=\"hljs-string\">&#x27;x&#x27;</span>, fig=fig)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"输出结果解读\"><a href=\"#输出结果解读\" class=\"headerlink\" title=\"输出结果解读\"></a>输出结果解读</h4><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Prob (F-statistic)</td>\n<td>模型F统计量的p值，用于判断整个回归模型是否显著。值越小（通常小于0.05），说明模型整体越显著，即至少有一个自变量对因变量有显著影响</td>\n</tr>\n<tr>\n<td>R-squared</td>\n<td>决定系数，表示模型能够解释的因变量总变异的比例。值越接近1，说明模型拟合效果越好</td>\n</tr>\n<tr>\n<td>Adj. R-squared</td>\n<td>调整后的决定系数，在R-squared基础上考虑了自变量个数的影响，惩罚了无意义的变量加入。值越接近1，模型越好，更适合用于比较不同复杂度的模型</td>\n</tr>\n<tr>\n<td>Skew</td>\n<td>残差分布的偏度，衡量残差分布的对称性。值越接近0，说明残差分布越对称，越接近正态分布。正值表示右偏，负值表示左偏。</td>\n</tr>\n<tr>\n<td>Kurtosis</td>\n<td>残差分布的峰度，衡量残差分布的尖锐程度。值越接近3（正态分布的峰度），说明残差分布越接近正态分布。大于3表示分布更尖锐，小于3表示分布更平坦</td>\n</tr>\n<tr>\n<td>P &gt; |t|</td>\n<td>每个回归系数的t检验p值，用于判断单个自变量是否对因变量有显著影响。值越小（通常小于0.05），说明该自变量对因变量的影响越显著</td>\n</tr>\n<tr>\n<td>coef</td>\n<td>回归系数，表示自变量对因变量的影响程度和方向。系数的绝对值越大，影响越强；系数为正表示正相关，为负表示负相关。</td>\n</tr>\n</tbody></table>\n<h3 id=\"多项式回归\"><a href=\"#多项式回归\" class=\"headerlink\" title=\"多项式回归\"></a>多项式回归</h3><p><a href=\"#%E7%9B%AE%E5%BD%95\">回到目录</a></p>\n<h4 id=\"算法思想-1\"><a href=\"#算法思想-1\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h4><p>若有一条抛物线隐藏在数据集中，那么在模型中引入二次项或许会得到更好的拟合效果</p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>在<a href=\"#python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">第三步</a>增加截距项那一步改进代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> statsmodels.api <span class=\"hljs-keyword\">as</span> sm<br><span class=\"hljs-comment\"># 增加二次项</span><br>df_const = sm.add_constant(dataframe)<br>df_const[<span class=\"hljs-string\">&#x27;x_2&#x27;</span>] = df_const[<span class=\"hljs-string\">&#x27;x&#x27;</span>] ** <span class=\"hljs-number\">2</span><br><span class=\"hljs-comment\"># 将数据集X和y分别提取出来 </span><br>X = df_const.loc[:, df_const.columns != <span class=\"hljs-string\">&#x27;y&#x27;</span>] <span class=\"hljs-comment\">#自变量</span><br>y = df_const.loc[:, df_const.columns == <span class=\"hljs-string\">&#x27;y&#x27;</span>] <span class=\"hljs-comment\">#因变量</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多元线性回归\"><a href=\"#多元线性回归\" class=\"headerlink\" title=\"多元线性回归\"></a>多元线性回归</h3><h4 id=\"算法思想-2\"><a href=\"#算法思想-2\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h4><p>对于p值小于0.05的变量，我们可以认为它对于因变量具有显著影响，但我们无法排除其他因变量也有预测能力的可能，因此需考虑多个变量的组合对因变量的贡献。</p>\n<h4 id=\"模型选择\"><a href=\"#模型选择\" class=\"headerlink\" title=\"模型选择\"></a>模型选择</h4><ul>\n<li>AIC(Akaike Information Criterion,赤池信息准则)<ul>\n<li>定义: AIC是一种模型选择准则，用于在多个候选模型中选择最优模型</li>\n<li>计算公式: AIC &#x3D; 2k - 2ln(L) 其中k是模型参数个数，L是模型的最大似然值</li>\n<li>特点:AIC在模型拟合度和复杂度之间寻求平衡值越小表示模型越好，相比于只考虑拟合优度的指标，AIC引入了对模型复杂度的惩罚项</li>\n</ul>\n</li>\n<li>BIC(Bayesian Information Criterion,贝叶斯信息准则)<ul>\n<li>定义: BIC是另一种模型选择准则，基于贝叶斯理论</li>\n<li>计算公式: BIC &#x3D; k×ln(n) - 2ln(L)其中k是模型参数个数，n是样本量，L是模型的最大似然值</li>\n<li>特点:BIC对模型复杂度的惩罚比AIC更严格，当样本量较大时，BIC倾向于选择更简单的模型，值越小表示模型越好</li>\n</ul>\n</li>\n<li>区别<ul>\n<li>惩罚程度: BIC对复杂模型的惩罚更重，特别是当样本量较大时</li>\n<li>理论基础: AIC基于信息论，BIC基于贝叶斯理论</li>\n<li>模型选择倾向: AIC可能选择较复杂的模型，BIC倾向于选择较简单的模型</li>\n<li>一致性: BIC具有一致性，当样本量趋于无穷时能选出真实模型；AIC则不具备此性质</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><ul>\n<li>引入多元线性回归api<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> statsmodels.formula.api <span class=\"hljs-keyword\">import</span> ols<br></code></pre></td></tr></table></figure></li>\n<li>构建模型<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">model = ols(<span class=\"hljs-string\">&#x27;y ~ x1 + x2 + x3 + ...&#x27;</span>, data=dataframe).fit()<br></code></pre></td></tr></table></figure></li>\n<li>模型输出<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">model.summary()<br></code></pre></td></tr></table></figure></li>\n<li>注意事项：不同于前两种线性回归，多元线性回归无需在数据集中添加截距项</li>\n<li>交互项语法<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 完整写法</span><br>model = ols(<span class=\"hljs-string\">&#x27;y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3&#x27;</span>, data=dataframe).fit()<br><span class=\"hljs-comment\"># 等价简写形式</span><br>model = ols(<span class=\"hljs-string\">&#x27;y ~ x1 * x2 * x3&#x27;</span>, data=dataframe).fit()<br></code></pre></td></tr></table></figure></li>\n<li>多重共线性可以根据相关系数矩阵和方差膨胀因子(VIF)判断<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 相关系数矩阵</span><br><span class=\"hljs-string\">&quot;&quot;&quot;corr()</span><br><span class=\"hljs-string\">- args:</span><br><span class=\"hljs-string\">  method: 计算方式</span><br><span class=\"hljs-string\">    - &#x27;pearson&#x27;:皮尔逊相关系数(默认)</span><br><span class=\"hljs-string\">    - &#x27;kendall&#x27;:肯德尔相关系数</span><br><span class=\"hljs-string\">    - &#x27;spearman&#x27;:斯皮尔曼相关系数</span><br><span class=\"hljs-string\">  min_periods: 最小样本数，默认为5</span><br><span class=\"hljs-string\">- return:</span><br><span class=\"hljs-string\">  返回一个DataFrame对象，包含相关系数矩阵</span><br><span class=\"hljs-string\">    相关系数值范围为[-1, 1]</span><br><span class=\"hljs-string\">      1: 完全正相关</span><br><span class=\"hljs-string\">      0: 无线性相关</span><br><span class=\"hljs-string\">      -1: 完全负相关</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br>corr = dataframe.corr()<br><span class=\"hljs-comment\"># 方差膨胀因子</span><br><span class=\"hljs-keyword\">import</span> statsmodels.stats.outliers_influence <span class=\"hljs-keyword\">as</span> oi<br><span class=\"hljs-string\">&quot;&quot;&quot;variance_inflation_factor()</span><br><span class=\"hljs-string\">- args:</span><br><span class=\"hljs-string\">  exog: 输入矩阵</span><br><span class=\"hljs-string\">  exog_idx: 输入矩阵的列索引</span><br><span class=\"hljs-string\">- tips:</span><br><span class=\"hljs-string\">  一般来说，VIF大于4，即认为存在多重共线性。</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br>vif = oi.variance_inflation_factor()<br></code></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"二分法查找","date":"2025-09-23T14:49:18.123Z","_content":"\n# 二分法查找\n\n## 题目描述\n在排序数组中查找元素的第一个和最后一个位置\n\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n\n \n\n示例 1：\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n### 思路\n1. 我们可以用二分法查找来降低时间复杂度\n2. 二分查找的三种思路：\n   1. 闭区间：[left, right]\n   初始值：\n       * left = 0, right = n - 1\n       * mid = (left + right) // 2\n   * 当 left <= right 时，循环执行\n   * 若 nums[mid] < target: left = mid + 1\n   否则 right = mid - 1\n   * 这样，循环结束后，若target在数组中，则left在right + 1的位置，当num[mid] == target时，执行 right = mid - 1,而target值索引即为left，故最开始出现的位置为left\n   * 因此返回值left\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        \"\"\"\n        二分法查找某数字最早出现的位置\n        \"\"\"\n        l = 0\n        r = len(nums) - 1\n        while l <= r: # 闭区间[l, r]\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1 # [m + 1, r]\n            else:\n                r = m - 1 # [l, m - 1]\n        return l # 若没有则会停在-1或len(nums)\n    ~~~\n   2. 左闭右开区间：[left, right)\n    初始值：\n      * left = 0, right = n\n      * mid = (left + right) // 2\n   * 当 left < right 时，循环执行\n   * 若 nums[mid] < target: left = mid + 1\n    否则 right = mid\n   * 这样，循环结束后，若target在数组中，则left在right的位置\n   * 因此返回值left和right都可以\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums)\n        while l < r: # 左闭右开区间[l, r)\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1 # [m + 1, r)\n            else:\n                r = m # [l, m)\n        return l # r\n    ~~~\n   3. 开区间：(left, right)\n    初始值：\n      * left = -1, right = n\n      * mid = (left + right) // 2\n   * 当 left + 1 < right 时，循环执行\n   * 若 nums[mid] < target: left = mid\n   * 否则 right = mid\n   * 这样，循环结束后，若target在数组中，则left在right - 1的位置，当num[mid] == target时，执行 right = mid,而target值索引即为right，故最开始出现的位置为right\n   * 因此返回值right\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        l = -1\n        r = len(nums)\n        while l + 1 < r: # 开区间(l, r)\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m # (m, r)\n            else:\n                r = m # (l, m)\n        return r\n    ~~~\n3. 通过这三种思路，我们可以得到target最开始的位置，我们只需要再调用一次函数，将target + 1作为参数，返回值-1即为target最后出现的位置\n \n ### 代码实现\n ~~~python\n class Solution:\n    # 调用上述任意一种算法\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        start = lower_bound(nums, target)\n        if start == len(nums) or nums[start] != target:\n            return [-1,-1]\n        end = lower_bound(nums, target + 1) - 1\n        return [start,end]\n~~~\n\n### 复杂度分析\n时间复杂度：**O(log n)** 空间复杂度：**O(1)**\n  \n","source":"_posts/binarySearch.md","raw":"---\ntitle: \"二分法查找\"\ndate:\ntags: \n    - 算法\n    - 二分法\ncategories:\n    - 算法笔记\n---\n\n# 二分法查找\n\n## 题目描述\n在排序数组中查找元素的第一个和最后一个位置\n\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n\n \n\n示例 1：\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n### 思路\n1. 我们可以用二分法查找来降低时间复杂度\n2. 二分查找的三种思路：\n   1. 闭区间：[left, right]\n   初始值：\n       * left = 0, right = n - 1\n       * mid = (left + right) // 2\n   * 当 left <= right 时，循环执行\n   * 若 nums[mid] < target: left = mid + 1\n   否则 right = mid - 1\n   * 这样，循环结束后，若target在数组中，则left在right + 1的位置，当num[mid] == target时，执行 right = mid - 1,而target值索引即为left，故最开始出现的位置为left\n   * 因此返回值left\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        \"\"\"\n        二分法查找某数字最早出现的位置\n        \"\"\"\n        l = 0\n        r = len(nums) - 1\n        while l <= r: # 闭区间[l, r]\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1 # [m + 1, r]\n            else:\n                r = m - 1 # [l, m - 1]\n        return l # 若没有则会停在-1或len(nums)\n    ~~~\n   2. 左闭右开区间：[left, right)\n    初始值：\n      * left = 0, right = n\n      * mid = (left + right) // 2\n   * 当 left < right 时，循环执行\n   * 若 nums[mid] < target: left = mid + 1\n    否则 right = mid\n   * 这样，循环结束后，若target在数组中，则left在right的位置\n   * 因此返回值left和right都可以\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums)\n        while l < r: # 左闭右开区间[l, r)\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1 # [m + 1, r)\n            else:\n                r = m # [l, m)\n        return l # r\n    ~~~\n   3. 开区间：(left, right)\n    初始值：\n      * left = -1, right = n\n      * mid = (left + right) // 2\n   * 当 left + 1 < right 时，循环执行\n   * 若 nums[mid] < target: left = mid\n   * 否则 right = mid\n   * 这样，循环结束后，若target在数组中，则left在right - 1的位置，当num[mid] == target时，执行 right = mid,而target值索引即为right，故最开始出现的位置为right\n   * 因此返回值right\n    ~~~python\n    def lower_bound(nums: List[int], target: int) -> int:\n        l = -1\n        r = len(nums)\n        while l + 1 < r: # 开区间(l, r)\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m # (m, r)\n            else:\n                r = m # (l, m)\n        return r\n    ~~~\n3. 通过这三种思路，我们可以得到target最开始的位置，我们只需要再调用一次函数，将target + 1作为参数，返回值-1即为target最后出现的位置\n \n ### 代码实现\n ~~~python\n class Solution:\n    # 调用上述任意一种算法\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        start = lower_bound(nums, target)\n        if start == len(nums) or nums[start] != target:\n            return [-1,-1]\n        end = lower_bound(nums, target + 1) - 1\n        return [start,end]\n~~~\n\n### 复杂度分析\n时间复杂度：**O(log n)** 空间复杂度：**O(1)**\n  \n","slug":"binarySearch","published":1,"updated":"2025-09-23T15:26:26.991Z","_id":"cmfwpff400002t8tl42079fks","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE\">二分法查找</span></h1><h2><span id=\"%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">题目描述</span></h2><p>在排序数组中查找元素的第一个和最后一个位置</p>\n<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>\n<p>示例 1：</p>\n<p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p>\n<p>示例 2：</p>\n<p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p>\n<p>示例 3：</p>\n<p>输入：nums = [], target = 0<br>输出：[-1,-1]</p>\n<h3><span id=\"%E6%80%9D%E8%B7%AF\">思路</span></h3><ol>\n<li>我们可以用二分法查找来降低时间复杂度</li>\n<li>二分查找的三种思路：<ol>\n<li>闭区间：[left, right]<br>初始值：<ul>\n<li>left = 0, right = n - 1</li>\n<li>mid = (left + right) // 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left &lt;= right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left = mid + 1<br>否则 right = mid - 1</li>\n<li>这样，循环结束后，若target在数组中，则left在right + 1的位置，当num[mid] == target时，执行 right = mid - 1,而target值索引即为left，故最开始出现的位置为left</li>\n<li>因此返回值left <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    <span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">    二分法查找某数字最早出现的位置</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    l = <span class=\"hljs-number\">0</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">while</span> l &lt;= r: <span class=\"hljs-comment\"># 闭区间[l, r]</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [m + 1, r]</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m - <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [l, m - 1]</span><br>    <span class=\"hljs-keyword\">return</span> l <span class=\"hljs-comment\"># 若没有则会停在-1或len(nums)</span><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>左闭右开区间：[left, right)<br> 初始值：<ul>\n<li>left = 0, right = n</li>\n<li>mid = (left + right) // 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left &lt; right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left = mid + 1<br> 否则 right = mid</li>\n<li>这样，循环结束后，若target在数组中，则left在right的位置</li>\n<li>因此返回值left和right都可以 <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    l = <span class=\"hljs-number\">0</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums)<br>    <span class=\"hljs-keyword\">while</span> l &lt; r: <span class=\"hljs-comment\"># 左闭右开区间[l, r)</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [m + 1, r)</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m <span class=\"hljs-comment\"># [l, m)</span><br>    <span class=\"hljs-keyword\">return</span> l <span class=\"hljs-comment\"># r</span><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>开区间：(left, right)<br> 初始值：<ul>\n<li>left = -1, right = n</li>\n<li>mid = (left + right) // 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left + 1 &lt; right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left = mid</li>\n<li>否则 right = mid</li>\n<li>这样，循环结束后，若target在数组中，则left在right - 1的位置，当num[mid] == target时，执行 right = mid,而target值索引即为right，故最开始出现的位置为right</li>\n<li>因此返回值right <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    l = -<span class=\"hljs-number\">1</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums)<br>    <span class=\"hljs-keyword\">while</span> l + <span class=\"hljs-number\">1</span> &lt; r: <span class=\"hljs-comment\"># 开区间(l, r)</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m <span class=\"hljs-comment\"># (m, r)</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m <span class=\"hljs-comment\"># (l, m)</span><br>    <span class=\"hljs-keyword\">return</span> r<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</li>\n<li>通过这三种思路，我们可以得到target最开始的位置，我们只需要再调用一次函数，将target + 1作为参数，返回值-1即为target最后出现的位置</li>\n</ol>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3> <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>   <span class=\"hljs-comment\"># 调用上述任意一种算法</span><br>   <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">searchRange</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>       start = lower_bound(nums, target)<br>       <span class=\"hljs-keyword\">if</span> start == <span class=\"hljs-built_in\">len</span>(nums) <span class=\"hljs-keyword\">or</span> nums[start] != target:<br>           <span class=\"hljs-keyword\">return</span> [-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>]<br>       end = lower_bound(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>       <span class=\"hljs-keyword\">return</span> [start,end]<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><p>时间复杂度：<strong>O(log n)</strong> 空间复杂度：<strong>O(1)</strong></p>\n</body></html>","excerpt":"","more":"<h1 id=\"二分法查找\"><a href=\"#二分法查找\" class=\"headerlink\" title=\"二分法查找\"></a>二分法查找</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在排序数组中查找元素的第一个和最后一个位置</p>\n<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]</p>\n<p>示例 3：</p>\n<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>我们可以用二分法查找来降低时间复杂度</li>\n<li>二分查找的三种思路：<ol>\n<li>闭区间：[left, right]<br>初始值：<ul>\n<li>left &#x3D; 0, right &#x3D; n - 1</li>\n<li>mid &#x3D; (left + right) &#x2F;&#x2F; 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left &lt;&#x3D; right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left &#x3D; mid + 1<br>否则 right &#x3D; mid - 1</li>\n<li>这样，循环结束后，若target在数组中，则left在right + 1的位置，当num[mid] &#x3D;&#x3D; target时，执行 right &#x3D; mid - 1,而target值索引即为left，故最开始出现的位置为left</li>\n<li>因此返回值left <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    二分法查找某数字最早出现的位置</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    l = <span class=\"hljs-number\">0</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">while</span> l &lt;= r: <span class=\"hljs-comment\"># 闭区间[l, r]</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [m + 1, r]</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m - <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [l, m - 1]</span><br>    <span class=\"hljs-keyword\">return</span> l <span class=\"hljs-comment\"># 若没有则会停在-1或len(nums)</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>左闭右开区间：[left, right)<br> 初始值：<ul>\n<li>left &#x3D; 0, right &#x3D; n</li>\n<li>mid &#x3D; (left + right) &#x2F;&#x2F; 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left &lt; right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left &#x3D; mid + 1<br> 否则 right &#x3D; mid</li>\n<li>这样，循环结束后，若target在数组中，则left在right的位置</li>\n<li>因此返回值left和right都可以 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    l = <span class=\"hljs-number\">0</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums)<br>    <span class=\"hljs-keyword\">while</span> l &lt; r: <span class=\"hljs-comment\"># 左闭右开区间[l, r)</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># [m + 1, r)</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m <span class=\"hljs-comment\"># [l, m)</span><br>    <span class=\"hljs-keyword\">return</span> l <span class=\"hljs-comment\"># r</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>开区间：(left, right)<br> 初始值：<ul>\n<li>left &#x3D; -1, right &#x3D; n</li>\n<li>mid &#x3D; (left + right) &#x2F;&#x2F; 2</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>当 left + 1 &lt; right 时，循环执行</li>\n<li>若 nums[mid] &lt; target: left &#x3D; mid</li>\n<li>否则 right &#x3D; mid</li>\n<li>这样，循环结束后，若target在数组中，则left在right - 1的位置，当num[mid] &#x3D;&#x3D; target时，执行 right &#x3D; mid,而target值索引即为right，故最开始出现的位置为right</li>\n<li>因此返回值right <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lower_bound</span>(<span class=\"hljs-params\">nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>    l = -<span class=\"hljs-number\">1</span><br>    r = <span class=\"hljs-built_in\">len</span>(nums)<br>    <span class=\"hljs-keyword\">while</span> l + <span class=\"hljs-number\">1</span> &lt; r: <span class=\"hljs-comment\"># 开区间(l, r)</span><br>        m = (l + r) // <span class=\"hljs-number\">2</span><br>        <span class=\"hljs-keyword\">if</span> nums[m] &lt; target:<br>            l = m <span class=\"hljs-comment\"># (m, r)</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            r = m <span class=\"hljs-comment\"># (l, m)</span><br>    <span class=\"hljs-keyword\">return</span> r<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>通过这三种思路，我们可以得到target最开始的位置，我们只需要再调用一次函数，将target + 1作为参数，返回值-1即为target最后出现的位置</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>   <span class=\"hljs-comment\"># 调用上述任意一种算法</span><br>   <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">searchRange</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>], target: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>       start = lower_bound(nums, target)<br>       <span class=\"hljs-keyword\">if</span> start == <span class=\"hljs-built_in\">len</span>(nums) <span class=\"hljs-keyword\">or</span> nums[start] != target:<br>           <span class=\"hljs-keyword\">return</span> [-<span class=\"hljs-number\">1</span>,-<span class=\"hljs-number\">1</span>]<br>       end = lower_bound(nums, target + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span><br>       <span class=\"hljs-keyword\">return</span> [start,end]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度：<strong>O(log n)</strong> 空间复杂度：<strong>O(1)</strong></p>\n"},{"title":"Android 开发","date":"2025-09-26T12:02:34.646Z","_content":"\n# Android 开发\n\n## 目录\n\n## 前置条件\n* [安装Android Studio](https://developer.android.google.cn/studio/index.html?hl=ro)\n\n## 四大组件\n|组件名称|场景|用途|\n|---|---|---|\n|Activity|界面交互|是用户交互的入口点，代表一个界面，可以拉起其他的界面和组件|\n|Service|后台服务|处理耗时任务(即使应用退出)，比如下载，网络请求，跨进程访问等|\n|BroadcastReceiver|事件响应|捕获系统事件(时区变更，短信到达)或者用户发送到自定义事件，然后根据事件决定接下来的业务逻辑|\n|ContentProvider|数据共享|对外安全暴露私有数据，提供统一的api访问，内部可以是不同存储方式的实现|\n\n### 入口文件\nAndroidManifest.xml\n\n### 创建一个Activity\n* 首先在layout目录下创建一个**xml文件**，并设置文件名，如activity_1.xml\n* 创建与**xml文件**对应的activity子类\n* 把声明的子类在AndroidManifest.xml中注入\n* **xml文件**可以添加组件\n* kt文件可以为组件添加事件监听\n\n### Activity生命周期\n|生命周期|说明|\n|---|---|\n|onCreate()|首次创建Activity时调用，完成初始化工作，多用于创建视图、为列表绑定数据|\n|onStart()|当Activity可见时调用，多用于启动后台任务|\n|onResume()|当Activity开始与用户交互时调用，进入活跃状态，位于栈顶，可以接受用户输入|\n|onPause()|要启动另一个Activity时调用，暂停当前Activity，但保留状态，可以保存数据，最后一个可控的回调|\n|onStop()|当Activity不可见时调用|\n|onDestroy()|当Activity销毁时调用，发生在finish()方法执行时，或由于系统内存不足而销毁|\n|onRestart()|当Activity重新启动时调用，通常用于恢复数据|\n\n### Activity保存和恢复\n|方法|调用时机|说明|使用场景|\n|---|---|---|---|\n|onSaveInstanceState(outState:Bundle)|系统未经“你的许可”，可能销毁了你的activity，则会被调用|用户主动销毁不调用，可能销毁即调用|从一个Activity启动另一个Activity <br> 屏幕方向切换 <br> home键返回，切换别的应用 <br> 关闭屏幕显示|\n|onRestoreInstanceState(savedInstanceState:Bundle)|系统未经“你的许可”，确实销毁了你的activity，重新启动时则会被调用|用户主动销毁不调用，可能销毁即调用，与onSaveInstanceState()方法不一定成对调用|异常关闭了Activity，下次启动时则被调用 <br> onCreate() -> onStart() -> onRestoreInstanceState() -> onResume()|\n\n### Activity启动模式\n在AndroidManifest.xml中,`<application>`标签下的`<activity>`中设置Activity的启动模式 `android:launchMode=\"启动模式`\n|启动模式|说明|\n|---|---|\n|standard|默认启动模式，按Activity启动顺序压入Task Stack中|\n|singleTop|栈顶复用模式，栈顶Activity实例已经存在，则不会创建新的实例|\n|singleTask|如果Activity存在于栈中，弹出其上所有Activity，目标Activity置于栈顶并获得焦点|\n|singleInstance|全局唯一模式，为目标Activity创建一个栈，栈顶Activity获得焦点，如果已经创建过则唤醒|\n","source":"_posts/android_develop.md","raw":"---\ntitle: \"Android 开发\"\ndate: \ntags:\n    - Android\ncategories:\n    - 项目开发\n---\n\n# Android 开发\n\n## 目录\n\n## 前置条件\n* [安装Android Studio](https://developer.android.google.cn/studio/index.html?hl=ro)\n\n## 四大组件\n|组件名称|场景|用途|\n|---|---|---|\n|Activity|界面交互|是用户交互的入口点，代表一个界面，可以拉起其他的界面和组件|\n|Service|后台服务|处理耗时任务(即使应用退出)，比如下载，网络请求，跨进程访问等|\n|BroadcastReceiver|事件响应|捕获系统事件(时区变更，短信到达)或者用户发送到自定义事件，然后根据事件决定接下来的业务逻辑|\n|ContentProvider|数据共享|对外安全暴露私有数据，提供统一的api访问，内部可以是不同存储方式的实现|\n\n### 入口文件\nAndroidManifest.xml\n\n### 创建一个Activity\n* 首先在layout目录下创建一个**xml文件**，并设置文件名，如activity_1.xml\n* 创建与**xml文件**对应的activity子类\n* 把声明的子类在AndroidManifest.xml中注入\n* **xml文件**可以添加组件\n* kt文件可以为组件添加事件监听\n\n### Activity生命周期\n|生命周期|说明|\n|---|---|\n|onCreate()|首次创建Activity时调用，完成初始化工作，多用于创建视图、为列表绑定数据|\n|onStart()|当Activity可见时调用，多用于启动后台任务|\n|onResume()|当Activity开始与用户交互时调用，进入活跃状态，位于栈顶，可以接受用户输入|\n|onPause()|要启动另一个Activity时调用，暂停当前Activity，但保留状态，可以保存数据，最后一个可控的回调|\n|onStop()|当Activity不可见时调用|\n|onDestroy()|当Activity销毁时调用，发生在finish()方法执行时，或由于系统内存不足而销毁|\n|onRestart()|当Activity重新启动时调用，通常用于恢复数据|\n\n### Activity保存和恢复\n|方法|调用时机|说明|使用场景|\n|---|---|---|---|\n|onSaveInstanceState(outState:Bundle)|系统未经“你的许可”，可能销毁了你的activity，则会被调用|用户主动销毁不调用，可能销毁即调用|从一个Activity启动另一个Activity <br> 屏幕方向切换 <br> home键返回，切换别的应用 <br> 关闭屏幕显示|\n|onRestoreInstanceState(savedInstanceState:Bundle)|系统未经“你的许可”，确实销毁了你的activity，重新启动时则会被调用|用户主动销毁不调用，可能销毁即调用，与onSaveInstanceState()方法不一定成对调用|异常关闭了Activity，下次启动时则被调用 <br> onCreate() -> onStart() -> onRestoreInstanceState() -> onResume()|\n\n### Activity启动模式\n在AndroidManifest.xml中,`<application>`标签下的`<activity>`中设置Activity的启动模式 `android:launchMode=\"启动模式`\n|启动模式|说明|\n|---|---|\n|standard|默认启动模式，按Activity启动顺序压入Task Stack中|\n|singleTop|栈顶复用模式，栈顶Activity实例已经存在，则不会创建新的实例|\n|singleTask|如果Activity存在于栈中，弹出其上所有Activity，目标Activity置于栈顶并获得焦点|\n|singleInstance|全局唯一模式，为目标Activity创建一个栈，栈顶Activity获得焦点，如果已经创建过则唤醒|\n","slug":"android_develop","published":1,"updated":"2025-09-26T14:11:09.557Z","comments":1,"layout":"post","photos":[],"_id":"cmg22ta090000wotl1wgo5c5c","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"android-%E5%BC%80%E5%8F%91\">Android 开发</span></h1><h2><span id=\"%E7%9B%AE%E5%BD%95\">目录</span></h2><h2><span id=\"%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6\">前置条件</span></h2><ul>\n<li><a href=\"https://developer.android.google.cn/studio/index.html?hl=ro\">安装Android Studio</a></li>\n</ul>\n<h2><span id=\"%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6\">四大组件</span></h2><table>\n<thead>\n<tr>\n<th>组件名称</th>\n<th>场景</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Activity</td>\n<td>界面交互</td>\n<td>是用户交互的入口点，代表一个界面，可以拉起其他的界面和组件</td>\n</tr>\n<tr>\n<td>Service</td>\n<td>后台服务</td>\n<td>处理耗时任务(即使应用退出)，比如下载，网络请求，跨进程访问等</td>\n</tr>\n<tr>\n<td>BroadcastReceiver</td>\n<td>事件响应</td>\n<td>捕获系统事件(时区变更，短信到达)或者用户发送到自定义事件，然后根据事件决定接下来的业务逻辑</td>\n</tr>\n<tr>\n<td>ContentProvider</td>\n<td>数据共享</td>\n<td>对外安全暴露私有数据，提供统一的api访问，内部可以是不同存储方式的实现</td>\n</tr>\n</tbody></table>\n<h3><span id=\"%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6\">入口文件</span></h3><p>AndroidManifest.xml</p>\n<h3><span id=\"%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAactivity\">创建一个Activity</span></h3><ul>\n<li>首先在layout目录下创建一个<strong>xml文件</strong>，并设置文件名，如activity_1.xml</li>\n<li>创建与<strong>xml文件</strong>对应的activity子类</li>\n<li>把声明的子类在AndroidManifest.xml中注入</li>\n<li><strong>xml文件</strong>可以添加组件</li>\n<li>kt文件可以为组件添加事件监听</li>\n</ul>\n<h3><span id=\"activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">Activity生命周期</span></h3><table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onCreate()</td>\n<td>首次创建Activity时调用，完成初始化工作，多用于创建视图、为列表绑定数据</td>\n</tr>\n<tr>\n<td>onStart()</td>\n<td>当Activity可见时调用，多用于启动后台任务</td>\n</tr>\n<tr>\n<td>onResume()</td>\n<td>当Activity开始与用户交互时调用，进入活跃状态，位于栈顶，可以接受用户输入</td>\n</tr>\n<tr>\n<td>onPause()</td>\n<td>要启动另一个Activity时调用，暂停当前Activity，但保留状态，可以保存数据，最后一个可控的回调</td>\n</tr>\n<tr>\n<td>onStop()</td>\n<td>当Activity不可见时调用</td>\n</tr>\n<tr>\n<td>onDestroy()</td>\n<td>当Activity销毁时调用，发生在finish()方法执行时，或由于系统内存不足而销毁</td>\n</tr>\n<tr>\n<td>onRestart()</td>\n<td>当Activity重新启动时调用，通常用于恢复数据</td>\n</tr>\n</tbody></table>\n<h3><span id=\"activity%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D\">Activity保存和恢复</span></h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>调用时机</th>\n<th>说明</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onSaveInstanceState(outState:Bundle)</td>\n<td>系统未经“你的许可”，可能销毁了你的activity，则会被调用</td>\n<td>用户主动销毁不调用，可能销毁即调用</td>\n<td>从一个Activity启动另一个Activity <br> 屏幕方向切换 <br> home键返回，切换别的应用 <br> 关闭屏幕显示</td>\n</tr>\n<tr>\n<td>onRestoreInstanceState(savedInstanceState:Bundle)</td>\n<td>系统未经“你的许可”，确实销毁了你的activity，重新启动时则会被调用</td>\n<td>用户主动销毁不调用，可能销毁即调用，与onSaveInstanceState()方法不一定成对调用</td>\n<td>异常关闭了Activity，下次启动时则被调用 <br> onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</td>\n</tr>\n</tbody></table>\n<h3><span id=\"activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F\">Activity启动模式</span></h3><p>在AndroidManifest.xml中,<code>&lt;application&gt;</code>标签下的<code>&lt;activity&gt;</code>中设置Activity的启动模式 <code>android:launchMode=\"启动模式</code></p>\n<table>\n<thead>\n<tr>\n<th>启动模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>standard</td>\n<td>默认启动模式，按Activity启动顺序压入Task Stack中</td>\n</tr>\n<tr>\n<td>singleTop</td>\n<td>栈顶复用模式，栈顶Activity实例已经存在，则不会创建新的实例</td>\n</tr>\n<tr>\n<td>singleTask</td>\n<td>如果Activity存在于栈中，弹出其上所有Activity，目标Activity置于栈顶并获得焦点</td>\n</tr>\n<tr>\n<td>singleInstance</td>\n<td>全局唯一模式，为目标Activity创建一个栈，栈顶Activity获得焦点，如果已经创建过则唤醒</td>\n</tr>\n</tbody></table>\n</body></html>","excerpt":"","more":"<h1 id=\"Android-开发\"><a href=\"#Android-开发\" class=\"headerlink\" title=\"Android 开发\"></a>Android 开发</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><h2 id=\"前置条件\"><a href=\"#前置条件\" class=\"headerlink\" title=\"前置条件\"></a>前置条件</h2><ul>\n<li><a href=\"https://developer.android.google.cn/studio/index.html?hl=ro\">安装Android Studio</a></li>\n</ul>\n<h2 id=\"四大组件\"><a href=\"#四大组件\" class=\"headerlink\" title=\"四大组件\"></a>四大组件</h2><table>\n<thead>\n<tr>\n<th>组件名称</th>\n<th>场景</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Activity</td>\n<td>界面交互</td>\n<td>是用户交互的入口点，代表一个界面，可以拉起其他的界面和组件</td>\n</tr>\n<tr>\n<td>Service</td>\n<td>后台服务</td>\n<td>处理耗时任务(即使应用退出)，比如下载，网络请求，跨进程访问等</td>\n</tr>\n<tr>\n<td>BroadcastReceiver</td>\n<td>事件响应</td>\n<td>捕获系统事件(时区变更，短信到达)或者用户发送到自定义事件，然后根据事件决定接下来的业务逻辑</td>\n</tr>\n<tr>\n<td>ContentProvider</td>\n<td>数据共享</td>\n<td>对外安全暴露私有数据，提供统一的api访问，内部可以是不同存储方式的实现</td>\n</tr>\n</tbody></table>\n<h3 id=\"入口文件\"><a href=\"#入口文件\" class=\"headerlink\" title=\"入口文件\"></a>入口文件</h3><p>AndroidManifest.xml</p>\n<h3 id=\"创建一个Activity\"><a href=\"#创建一个Activity\" class=\"headerlink\" title=\"创建一个Activity\"></a>创建一个Activity</h3><ul>\n<li>首先在layout目录下创建一个<strong>xml文件</strong>，并设置文件名，如activity_1.xml</li>\n<li>创建与<strong>xml文件</strong>对应的activity子类</li>\n<li>把声明的子类在AndroidManifest.xml中注入</li>\n<li><strong>xml文件</strong>可以添加组件</li>\n<li>kt文件可以为组件添加事件监听</li>\n</ul>\n<h3 id=\"Activity生命周期\"><a href=\"#Activity生命周期\" class=\"headerlink\" title=\"Activity生命周期\"></a>Activity生命周期</h3><table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onCreate()</td>\n<td>首次创建Activity时调用，完成初始化工作，多用于创建视图、为列表绑定数据</td>\n</tr>\n<tr>\n<td>onStart()</td>\n<td>当Activity可见时调用，多用于启动后台任务</td>\n</tr>\n<tr>\n<td>onResume()</td>\n<td>当Activity开始与用户交互时调用，进入活跃状态，位于栈顶，可以接受用户输入</td>\n</tr>\n<tr>\n<td>onPause()</td>\n<td>要启动另一个Activity时调用，暂停当前Activity，但保留状态，可以保存数据，最后一个可控的回调</td>\n</tr>\n<tr>\n<td>onStop()</td>\n<td>当Activity不可见时调用</td>\n</tr>\n<tr>\n<td>onDestroy()</td>\n<td>当Activity销毁时调用，发生在finish()方法执行时，或由于系统内存不足而销毁</td>\n</tr>\n<tr>\n<td>onRestart()</td>\n<td>当Activity重新启动时调用，通常用于恢复数据</td>\n</tr>\n</tbody></table>\n<h3 id=\"Activity保存和恢复\"><a href=\"#Activity保存和恢复\" class=\"headerlink\" title=\"Activity保存和恢复\"></a>Activity保存和恢复</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>调用时机</th>\n<th>说明</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onSaveInstanceState(outState:Bundle)</td>\n<td>系统未经“你的许可”，可能销毁了你的activity，则会被调用</td>\n<td>用户主动销毁不调用，可能销毁即调用</td>\n<td>从一个Activity启动另一个Activity <br> 屏幕方向切换 <br> home键返回，切换别的应用 <br> 关闭屏幕显示</td>\n</tr>\n<tr>\n<td>onRestoreInstanceState(savedInstanceState:Bundle)</td>\n<td>系统未经“你的许可”，确实销毁了你的activity，重新启动时则会被调用</td>\n<td>用户主动销毁不调用，可能销毁即调用，与onSaveInstanceState()方法不一定成对调用</td>\n<td>异常关闭了Activity，下次启动时则被调用 <br> onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</td>\n</tr>\n</tbody></table>\n<h3 id=\"Activity启动模式\"><a href=\"#Activity启动模式\" class=\"headerlink\" title=\"Activity启动模式\"></a>Activity启动模式</h3><p>在AndroidManifest.xml中,<code>&lt;application&gt;</code>标签下的<code>&lt;activity&gt;</code>中设置Activity的启动模式 <code>android:launchMode=&quot;启动模式</code></p>\n<table>\n<thead>\n<tr>\n<th>启动模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>standard</td>\n<td>默认启动模式，按Activity启动顺序压入Task Stack中</td>\n</tr>\n<tr>\n<td>singleTop</td>\n<td>栈顶复用模式，栈顶Activity实例已经存在，则不会创建新的实例</td>\n</tr>\n<tr>\n<td>singleTask</td>\n<td>如果Activity存在于栈中，弹出其上所有Activity，目标Activity置于栈顶并获得焦点</td>\n</tr>\n<tr>\n<td>singleInstance</td>\n<td>全局唯一模式，为目标Activity创建一个栈，栈顶Activity获得焦点，如果已经创建过则唤醒</td>\n</tr>\n</tbody></table>\n"},{"title":"单调栈","date":"2025-09-27T07:55:31.068Z","_content":"\n# 单调栈\n\n## 例题一：每日温度\n\n### 题目描述\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n \n\n示例 1:\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n\n示例 2:\n\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n\n示例 3:\n\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n\n### 解题思路\n* 从前往后考虑\n    * 对于当前天，我们只有在**遍历**到下一个更高温度的时候，才更新结果\n    * 那么，对于下一天，如果温度比当前天高，我们需要立刻更新结果；如果温度比当前天低，我们需要**保留**下来\n    * 对于下一个更高天，我们需要依次处理保存下来的天\n    * 对此我们可以想到，可以利用**单调栈**来储存保留的天的索引\n    * 将当前天与栈顶元素比较，如果栈顶更低，**弹出栈顶**就可以获得栈顶的索引，当前与栈顶索引差值就是所求的n天之后；否则，**入栈等待**下一个更高温度\n\n* 从后往前考虑\n    * 对于当前天，往前遍历，每一个低于当前天的，都需要处理比较，更新差值\n    * 往前遍历，若遇到一个高于当前天的，则可以弹出所有栈元素，并将此天入栈\n    * 此时，此天作为最大值，按照前面步骤继续处理，即可获得结果\n\n* 无论从前往后还是从后往前，**单调栈**的核心就是及时**弹出无用数据，保持栈中元素有序**\n\n### 代码实现\n* 从前往后\n    ~~~python\n    class Solution:\n        def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n            n = len(temperatures)\n            ans = [0] * n\n            stack = [] # 栈用于记录标\n            # 从前往后\n            for i in range(n):\n                t = temperatures[i]\n                # 一旦当前大于栈顶元素，就要处理栈顶元素，进行弹出比较，并更新列表\n                while stack and t > temperatures[stack[-1]]:\n                    x = stack.pop()\n                    ans[x] = i - x \n                stack.append(i)\n            return ans\n    ~~~\n\n* 从后往前\n    ~~~python\n    class Solution:\n        def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n            n = len(temperatures)\n            ans = [0] * n\n            stack = [] # 栈用于记录标\n            for i in range(-1, -n - 1, -1): # 从后往前遍历\n                t = temperatures[i] # 当前下标的温度\n                while stack and t >= temperatures[stack[-1]]: # 当栈中还有小于当前温度的下标，则弹出\n                    stack.pop() # 弹出后栈下标向前移动，直到比当前温度更大的下标\n                if stack: # 栈不为空，即当前栈顶对应温度大于当前天，需比较更新列表\n                    ans[i] = stack[-1] - i # 当前与栈中最大温度下标的差值就是所求的\n                stack.append(i)\n            return ans\n    ~~~\n\n### 复杂度分析\n* 从前往后\n    * 时间复杂度：O(n)，其中 n 为 temperatures 的长度。每个元素只进栈一次，出栈一次\n    * 空间复杂度：O(n)\n* 从后往前\n    * 时间复杂度：O(n)，原因同上\n    * 空间复杂度：O(n)\n\n\n\n## 例题二：接雨水\n\n### 题目描述\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![图](../assert/algorithm/rainwatertrap2.png)\n\n示例 1：\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n示例 2：\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n### 解题思路\n* 对于求解下一个比当前高或低的索引类型的问题，我们都可以使用**单调栈**来解决\n* 与上一题类似，我们无论从前往后或从后往前都可以得到下一次更高的索引差\n* 我们以弹出栈的索引为 k 作为底，栈顶索引 i 为左边界，当前索引 j 为右边界\n![示意图](../assert/algorithm/rainwatertrap.png)\n* 则雨水的高度为左右边界高的较小值与底高度差值，即 **min(height[i], height[j]) - height[k]**\n* 雨水的长度为 **j - i - 1**\n* 故雨水容量为 **min(height[i], height[j]) - height[k] * (j - i - 1)**\n\n### 代码实现\n~~~python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        # 遇到上一个更大更小问题，可以使用单调栈解决\n        ans = 0\n        stack = [] # 栈用于存放下标\n        for i, h in enumerate(height):\n            while stack and h > height[stack[-1]]:\n                # 弹出栈顶下标的高度作为底\n                bottom_h = height[stack.pop()]\n                # 栈弹空了说明没有左边界，立刻跳出循环\n                if not stack:\n                    break\n                # 栈顶为左边界\n                left = stack[-1]\n                # 左右边界高的较小值减去底高度，得到雨水的高度\n                dh = min(height[left], h) - bottom_h\n                # 累加雨水容量\n                ans += dh * (i - left -1)\n            stack.append(i)\n        return ans\n~~~\n\n### 复杂度分析\n* 时间复杂度：O(n)，其中 n 为 height 的长度。每个元素进栈一次，出栈一次\n* 空间复杂度：O(n)\n","source":"_posts/monotonic_stack.md","raw":"---\ntitle: \"单调栈\"\ndate:\ntags:\n    - 算法\n    - 栈\ncategories:\n    - 算法笔记\n---\n\n# 单调栈\n\n## 例题一：每日温度\n\n### 题目描述\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n \n\n示例 1:\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n\n示例 2:\n\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n\n示例 3:\n\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n\n### 解题思路\n* 从前往后考虑\n    * 对于当前天，我们只有在**遍历**到下一个更高温度的时候，才更新结果\n    * 那么，对于下一天，如果温度比当前天高，我们需要立刻更新结果；如果温度比当前天低，我们需要**保留**下来\n    * 对于下一个更高天，我们需要依次处理保存下来的天\n    * 对此我们可以想到，可以利用**单调栈**来储存保留的天的索引\n    * 将当前天与栈顶元素比较，如果栈顶更低，**弹出栈顶**就可以获得栈顶的索引，当前与栈顶索引差值就是所求的n天之后；否则，**入栈等待**下一个更高温度\n\n* 从后往前考虑\n    * 对于当前天，往前遍历，每一个低于当前天的，都需要处理比较，更新差值\n    * 往前遍历，若遇到一个高于当前天的，则可以弹出所有栈元素，并将此天入栈\n    * 此时，此天作为最大值，按照前面步骤继续处理，即可获得结果\n\n* 无论从前往后还是从后往前，**单调栈**的核心就是及时**弹出无用数据，保持栈中元素有序**\n\n### 代码实现\n* 从前往后\n    ~~~python\n    class Solution:\n        def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n            n = len(temperatures)\n            ans = [0] * n\n            stack = [] # 栈用于记录标\n            # 从前往后\n            for i in range(n):\n                t = temperatures[i]\n                # 一旦当前大于栈顶元素，就要处理栈顶元素，进行弹出比较，并更新列表\n                while stack and t > temperatures[stack[-1]]:\n                    x = stack.pop()\n                    ans[x] = i - x \n                stack.append(i)\n            return ans\n    ~~~\n\n* 从后往前\n    ~~~python\n    class Solution:\n        def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n            n = len(temperatures)\n            ans = [0] * n\n            stack = [] # 栈用于记录标\n            for i in range(-1, -n - 1, -1): # 从后往前遍历\n                t = temperatures[i] # 当前下标的温度\n                while stack and t >= temperatures[stack[-1]]: # 当栈中还有小于当前温度的下标，则弹出\n                    stack.pop() # 弹出后栈下标向前移动，直到比当前温度更大的下标\n                if stack: # 栈不为空，即当前栈顶对应温度大于当前天，需比较更新列表\n                    ans[i] = stack[-1] - i # 当前与栈中最大温度下标的差值就是所求的\n                stack.append(i)\n            return ans\n    ~~~\n\n### 复杂度分析\n* 从前往后\n    * 时间复杂度：O(n)，其中 n 为 temperatures 的长度。每个元素只进栈一次，出栈一次\n    * 空间复杂度：O(n)\n* 从后往前\n    * 时间复杂度：O(n)，原因同上\n    * 空间复杂度：O(n)\n\n\n\n## 例题二：接雨水\n\n### 题目描述\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![图](../assert/algorithm/rainwatertrap2.png)\n\n示例 1：\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n示例 2：\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n### 解题思路\n* 对于求解下一个比当前高或低的索引类型的问题，我们都可以使用**单调栈**来解决\n* 与上一题类似，我们无论从前往后或从后往前都可以得到下一次更高的索引差\n* 我们以弹出栈的索引为 k 作为底，栈顶索引 i 为左边界，当前索引 j 为右边界\n![示意图](../assert/algorithm/rainwatertrap.png)\n* 则雨水的高度为左右边界高的较小值与底高度差值，即 **min(height[i], height[j]) - height[k]**\n* 雨水的长度为 **j - i - 1**\n* 故雨水容量为 **min(height[i], height[j]) - height[k] * (j - i - 1)**\n\n### 代码实现\n~~~python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        # 遇到上一个更大更小问题，可以使用单调栈解决\n        ans = 0\n        stack = [] # 栈用于存放下标\n        for i, h in enumerate(height):\n            while stack and h > height[stack[-1]]:\n                # 弹出栈顶下标的高度作为底\n                bottom_h = height[stack.pop()]\n                # 栈弹空了说明没有左边界，立刻跳出循环\n                if not stack:\n                    break\n                # 栈顶为左边界\n                left = stack[-1]\n                # 左右边界高的较小值减去底高度，得到雨水的高度\n                dh = min(height[left], h) - bottom_h\n                # 累加雨水容量\n                ans += dh * (i - left -1)\n            stack.append(i)\n        return ans\n~~~\n\n### 复杂度分析\n* 时间复杂度：O(n)，其中 n 为 height 的长度。每个元素进栈一次，出栈一次\n* 空间复杂度：O(n)\n","slug":"monotonic_stack","published":1,"updated":"2025-09-27T09:26:52.098Z","comments":1,"layout":"post","photos":[],"_id":"cmg22ta0g0003wotlb4vj1mx0","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"%E5%8D%95%E8%B0%83%E6%A0%88\">单调栈</span></h1><h2><span id=\"%E4%BE%8B%E9%A2%98%E4%B8%80%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6\">例题一：每日温度</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">题目描述</span></h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>\n<p>示例 1:</p>\n<p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>\n<p>示例 2:</p>\n<p>输入: temperatures = [30,40,50,60]<br>输出: [1,1,1,0]</p>\n<p>示例 3:</p>\n<p>输入: temperatures = [30,60,90]<br>输出: [1,1,0]</p>\n<h3><span id=\"%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\">解题思路</span></h3><ul>\n<li><p>从前往后考虑</p>\n<ul>\n<li>对于当前天，我们只有在<strong>遍历</strong>到下一个更高温度的时候，才更新结果</li>\n<li>那么，对于下一天，如果温度比当前天高，我们需要立刻更新结果；如果温度比当前天低，我们需要<strong>保留</strong>下来</li>\n<li>对于下一个更高天，我们需要依次处理保存下来的天</li>\n<li>对此我们可以想到，可以利用<strong>单调栈</strong>来储存保留的天的索引</li>\n<li>将当前天与栈顶元素比较，如果栈顶更低，<strong>弹出栈顶</strong>就可以获得栈顶的索引，当前与栈顶索引差值就是所求的n天之后；否则，<strong>入栈等待</strong>下一个更高温度</li>\n</ul>\n</li>\n<li><p>从后往前考虑</p>\n<ul>\n<li>对于当前天，往前遍历，每一个低于当前天的，都需要处理比较，更新差值</li>\n<li>往前遍历，若遇到一个高于当前天的，则可以弹出所有栈元素，并将此天入栈</li>\n<li>此时，此天作为最大值，按照前面步骤继续处理，即可获得结果</li>\n</ul>\n</li>\n<li><p>无论从前往后还是从后往前，<strong>单调栈</strong>的核心就是及时<strong>弹出无用数据，保持栈中元素有序</strong></p>\n</li>\n</ul>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><ul>\n<li><p>从前往后</p>\n  <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dailyTemperatures</span>(<span class=\"hljs-params\">self, temperatures: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>        n = <span class=\"hljs-built_in\">len</span>(temperatures)<br>        ans = [<span class=\"hljs-number\">0</span>] * n<br>        stack = [] <span class=\"hljs-comment\"># 栈用于记录标</span><br>        <span class=\"hljs-comment\"># 从前往后</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):<br>            t = temperatures[i]<br>            <span class=\"hljs-comment\"># 一旦当前大于栈顶元素，就要处理栈顶元素，进行弹出比较，并更新列表</span><br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> t &gt; temperatures[stack[-<span class=\"hljs-number\">1</span>]]:<br>                x = stack.pop()<br>                ans[x] = i - x <br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>从后往前</p>\n  <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dailyTemperatures</span>(<span class=\"hljs-params\">self, temperatures: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>        n = <span class=\"hljs-built_in\">len</span>(temperatures)<br>        ans = [<span class=\"hljs-number\">0</span>] * n<br>        stack = [] <span class=\"hljs-comment\"># 栈用于记录标</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(-<span class=\"hljs-number\">1</span>, -n - <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>): <span class=\"hljs-comment\"># 从后往前遍历</span><br>            t = temperatures[i] <span class=\"hljs-comment\"># 当前下标的温度</span><br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> t &gt;= temperatures[stack[-<span class=\"hljs-number\">1</span>]]: <span class=\"hljs-comment\"># 当栈中还有小于当前温度的下标，则弹出</span><br>                stack.pop() <span class=\"hljs-comment\"># 弹出后栈下标向前移动，直到比当前温度更大的下标</span><br>            <span class=\"hljs-keyword\">if</span> stack: <span class=\"hljs-comment\"># 栈不为空，即当前栈顶对应温度大于当前天，需比较更新列表</span><br>                ans[i] = stack[-<span class=\"hljs-number\">1</span>] - i <span class=\"hljs-comment\"># 当前与栈中最大温度下标的差值就是所求的</span><br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><ul>\n<li>从前往后<ul>\n<li>时间复杂度：O(n)，其中 n 为 temperatures 的长度。每个元素只进栈一次，出栈一次</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n</li>\n<li>从后往前<ul>\n<li>时间复杂度：O(n)，原因同上</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"%E4%BE%8B%E9%A2%98%E4%BA%8C%E6%8E%A5%E9%9B%A8%E6%B0%B4\">例题二：接雨水</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">题目描述</span></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><img src=\"/../assert/algorithm/rainwatertrap2.png\" alt=\"图\"></p>\n<p>示例 1：</p>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>\n<p>示例 2：</p>\n<p>输入：height = [4,2,0,3,2,5]<br>输出：9</p>\n<h3><span id=\"%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\">解题思路</span></h3><ul>\n<li>对于求解下一个比当前高或低的索引类型的问题，我们都可以使用<strong>单调栈</strong>来解决</li>\n<li>与上一题类似，我们无论从前往后或从后往前都可以得到下一次更高的索引差</li>\n<li>我们以弹出栈的索引为 k 作为底，栈顶索引 i 为左边界，当前索引 j 为右边界<br><img src=\"/../assert/algorithm/rainwatertrap.png\" alt=\"示意图\"></li>\n<li>则雨水的高度为左右边界高的较小值与底高度差值，即 <strong>min(height[i], height[j]) - height[k]</strong></li>\n<li>雨水的长度为 <strong>j - i - 1</strong></li>\n<li>故雨水容量为 <strong>min(height[i], height[j]) - height[k] * (j - i - 1)</strong></li>\n</ul>\n<h3><span id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</span></h3><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">trap</span>(<span class=\"hljs-params\">self, height: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>        <span class=\"hljs-comment\"># 遇到上一个更大更小问题，可以使用单调栈解决</span><br>        ans = <span class=\"hljs-number\">0</span><br>        stack = [] <span class=\"hljs-comment\"># 栈用于存放下标</span><br>        <span class=\"hljs-keyword\">for</span> i, h <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(height):<br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> h &gt; height[stack[-<span class=\"hljs-number\">1</span>]]:<br>                <span class=\"hljs-comment\"># 弹出栈顶下标的高度作为底</span><br>                bottom_h = height[stack.pop()]<br>                <span class=\"hljs-comment\"># 栈弹空了说明没有左边界，立刻跳出循环</span><br>                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> stack:<br>                    <span class=\"hljs-keyword\">break</span><br>                <span class=\"hljs-comment\"># 栈顶为左边界</span><br>                left = stack[-<span class=\"hljs-number\">1</span>]<br>                <span class=\"hljs-comment\"># 左右边界高的较小值减去底高度，得到雨水的高度</span><br>                dh = <span class=\"hljs-built_in\">min</span>(height[left], h) - bottom_h<br>                <span class=\"hljs-comment\"># 累加雨水容量</span><br>                ans += dh * (i - left -<span class=\"hljs-number\">1</span>)<br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\">复杂度分析</span></h3><ul>\n<li>时间复杂度：O(n)，其中 n 为 height 的长度。每个元素进栈一次，出栈一次</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n</body></html>","excerpt":"","more":"<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><h2 id=\"例题一：每日温度\"><a href=\"#例题一：每日温度\" class=\"headerlink\" title=\"例题一：每日温度\"></a>例题一：每日温度</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>\n<p>示例 1:</p>\n<p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>\n<p>示例 2:</p>\n<p>输入: temperatures &#x3D; [30,40,50,60]<br>输出: [1,1,1,0]</p>\n<p>示例 3:</p>\n<p>输入: temperatures &#x3D; [30,60,90]<br>输出: [1,1,0]</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ul>\n<li><p>从前往后考虑</p>\n<ul>\n<li>对于当前天，我们只有在<strong>遍历</strong>到下一个更高温度的时候，才更新结果</li>\n<li>那么，对于下一天，如果温度比当前天高，我们需要立刻更新结果；如果温度比当前天低，我们需要<strong>保留</strong>下来</li>\n<li>对于下一个更高天，我们需要依次处理保存下来的天</li>\n<li>对此我们可以想到，可以利用<strong>单调栈</strong>来储存保留的天的索引</li>\n<li>将当前天与栈顶元素比较，如果栈顶更低，<strong>弹出栈顶</strong>就可以获得栈顶的索引，当前与栈顶索引差值就是所求的n天之后；否则，<strong>入栈等待</strong>下一个更高温度</li>\n</ul>\n</li>\n<li><p>从后往前考虑</p>\n<ul>\n<li>对于当前天，往前遍历，每一个低于当前天的，都需要处理比较，更新差值</li>\n<li>往前遍历，若遇到一个高于当前天的，则可以弹出所有栈元素，并将此天入栈</li>\n<li>此时，此天作为最大值，按照前面步骤继续处理，即可获得结果</li>\n</ul>\n</li>\n<li><p>无论从前往后还是从后往前，<strong>单调栈</strong>的核心就是及时<strong>弹出无用数据，保持栈中元素有序</strong></p>\n</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><ul>\n<li><p>从前往后</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dailyTemperatures</span>(<span class=\"hljs-params\">self, temperatures: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>        n = <span class=\"hljs-built_in\">len</span>(temperatures)<br>        ans = [<span class=\"hljs-number\">0</span>] * n<br>        stack = [] <span class=\"hljs-comment\"># 栈用于记录标</span><br>        <span class=\"hljs-comment\"># 从前往后</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):<br>            t = temperatures[i]<br>            <span class=\"hljs-comment\"># 一旦当前大于栈顶元素，就要处理栈顶元素，进行弹出比较，并更新列表</span><br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> t &gt; temperatures[stack[-<span class=\"hljs-number\">1</span>]]:<br>                x = stack.pop()<br>                ans[x] = i - x <br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>从后往前</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dailyTemperatures</span>(<span class=\"hljs-params\">self, temperatures: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:<br>        n = <span class=\"hljs-built_in\">len</span>(temperatures)<br>        ans = [<span class=\"hljs-number\">0</span>] * n<br>        stack = [] <span class=\"hljs-comment\"># 栈用于记录标</span><br>        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(-<span class=\"hljs-number\">1</span>, -n - <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>): <span class=\"hljs-comment\"># 从后往前遍历</span><br>            t = temperatures[i] <span class=\"hljs-comment\"># 当前下标的温度</span><br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> t &gt;= temperatures[stack[-<span class=\"hljs-number\">1</span>]]: <span class=\"hljs-comment\"># 当栈中还有小于当前温度的下标，则弹出</span><br>                stack.pop() <span class=\"hljs-comment\"># 弹出后栈下标向前移动，直到比当前温度更大的下标</span><br>            <span class=\"hljs-keyword\">if</span> stack: <span class=\"hljs-comment\"># 栈不为空，即当前栈顶对应温度大于当前天，需比较更新列表</span><br>                ans[i] = stack[-<span class=\"hljs-number\">1</span>] - i <span class=\"hljs-comment\"># 当前与栈中最大温度下标的差值就是所求的</span><br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><ul>\n<li>从前往后<ul>\n<li>时间复杂度：O(n)，其中 n 为 temperatures 的长度。每个元素只进栈一次，出栈一次</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n</li>\n<li>从后往前<ul>\n<li>时间复杂度：O(n)，原因同上</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"例题二：接雨水\"><a href=\"#例题二：接雨水\" class=\"headerlink\" title=\"例题二：接雨水\"></a>例题二：接雨水</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><img src=\"/../assert/algorithm/rainwatertrap2.png\" alt=\"图\"></p>\n<p>示例 1：</p>\n<p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>\n<p>示例 2：</p>\n<p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ul>\n<li>对于求解下一个比当前高或低的索引类型的问题，我们都可以使用<strong>单调栈</strong>来解决</li>\n<li>与上一题类似，我们无论从前往后或从后往前都可以得到下一次更高的索引差</li>\n<li>我们以弹出栈的索引为 k 作为底，栈顶索引 i 为左边界，当前索引 j 为右边界<br><img src=\"/../assert/algorithm/rainwatertrap.png\" alt=\"示意图\"></li>\n<li>则雨水的高度为左右边界高的较小值与底高度差值，即 <strong>min(height[i], height[j]) - height[k]</strong></li>\n<li>雨水的长度为 <strong>j - i - 1</strong></li>\n<li>故雨水容量为 <strong>min(height[i], height[j]) - height[k] * (j - i - 1)</strong></li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">trap</span>(<span class=\"hljs-params\">self, height: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -&gt; <span class=\"hljs-built_in\">int</span>:<br>        <span class=\"hljs-comment\"># 遇到上一个更大更小问题，可以使用单调栈解决</span><br>        ans = <span class=\"hljs-number\">0</span><br>        stack = [] <span class=\"hljs-comment\"># 栈用于存放下标</span><br>        <span class=\"hljs-keyword\">for</span> i, h <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(height):<br>            <span class=\"hljs-keyword\">while</span> stack <span class=\"hljs-keyword\">and</span> h &gt; height[stack[-<span class=\"hljs-number\">1</span>]]:<br>                <span class=\"hljs-comment\"># 弹出栈顶下标的高度作为底</span><br>                bottom_h = height[stack.pop()]<br>                <span class=\"hljs-comment\"># 栈弹空了说明没有左边界，立刻跳出循环</span><br>                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> stack:<br>                    <span class=\"hljs-keyword\">break</span><br>                <span class=\"hljs-comment\"># 栈顶为左边界</span><br>                left = stack[-<span class=\"hljs-number\">1</span>]<br>                <span class=\"hljs-comment\"># 左右边界高的较小值减去底高度，得到雨水的高度</span><br>                dh = <span class=\"hljs-built_in\">min</span>(height[left], h) - bottom_h<br>                <span class=\"hljs-comment\"># 累加雨水容量</span><br>                ans += dh * (i - left -<span class=\"hljs-number\">1</span>)<br>            stack.append(i)<br>        <span class=\"hljs-keyword\">return</span> ans<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><ul>\n<li>时间复杂度：O(n)，其中 n 为 height 的长度。每个元素进栈一次，出栈一次</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfwpff400002t8tl42079fks","category_id":"cmfwpg9v10000ugtlbce15dne","_id":"cmfwpg9v50003ugtl6sg1aeyf"},{"post_id":"cmfs3zg9r0000gwtl2q1j32rk","category_id":"cmfwpg9v10000ugtlbce15dne","_id":"cmfwpipii0004ugtl9b720oi4"},{"post_id":"cmfs3zg9x000cgwtl34b2ghyq","category_id":"cmfwpg9v10000ugtlbce15dne","_id":"cmfwpjo530005ugtl0u1bafmu"},{"post_id":"cmg22ta0g0003wotlb4vj1mx0","category_id":"cmfwpg9v10000ugtlbce15dne","_id":"cmg22ta0o0007wotlcosr86vs"},{"post_id":"cmf88q04a0003c4tl7ruk57xr","category_id":"cmg22ta0b0001wotl6ge6ge9d","_id":"cmg22ta0p0008wotlgmt5gm9j"},{"post_id":"cmfs3zg9u0002gwtlhb459op3","category_id":"cmfwpg9v10000ugtlbce15dne","_id":"cmg22ta0p0009wotlcrgia9l4"},{"post_id":"cmg22ta090000wotl1wgo5c5c","category_id":"cmg22ta0j0004wotlg4lnacog","_id":"cmg22ta0p000bwotlcrf7cf45"}],"PostTag":[{"post_id":"cmewhlst20000c0tl6a4l66i8","tag_id":"cmewhlst60001c0tlbeh77vu4","_id":"cmewhlst70002c0tl4tnbg9ic"},{"post_id":"cmf88q0440000c4tlhzl9avjf","tag_id":"cmf88q0470001c4tl9al0aoia","_id":"cmf88q0490002c4tl0gpf4zj9"},{"post_id":"cmf88q04a0003c4tl7ruk57xr","tag_id":"cmf88qxn100000stl9kmugljk","_id":"cmf88qxn300010stlhv83g16l"},{"post_id":"cmfs3zg9r0000gwtl2q1j32rk","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmfs3zg9w0006gwtl8gas4x9w"},{"post_id":"cmfs3zg9r0000gwtl2q1j32rk","tag_id":"cmfs3zg9v0003gwtlerc63m7y","_id":"cmfs3zg9w0007gwtl9hukg5gm"},{"post_id":"cmfs3zg9r0000gwtl2q1j32rk","tag_id":"cmfs3zg9v0004gwtl2e5hci1f","_id":"cmfs3zg9x0009gwtl7wtkbe4n"},{"post_id":"cmfs3zg9u0002gwtlhb459op3","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmfs3zg9x000agwtl0nq01fos"},{"post_id":"cmfs3zg9u0002gwtlhb459op3","tag_id":"cmfs3zg9v0003gwtlerc63m7y","_id":"cmfs3zg9x000bgwtl07uhgfny"},{"post_id":"cmfs3zg9x000cgwtl34b2ghyq","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmfs3zg9y000egwtlglbf4tfu"},{"post_id":"cmfwpff3u0000t8tl9ypkdwm1","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmfwpff3z0001t8tl1vhy4tkr"},{"post_id":"cmfwpff400002t8tl42079fks","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmfwpk0q80007ugtlhfjp9kqw"},{"post_id":"cmfwpff400002t8tl42079fks","tag_id":"cmfwpk0q60006ugtl8f8j76kn","_id":"cmfwpk0q80008ugtlas0a7m50"},{"post_id":"cmg22ta090000wotl1wgo5c5c","tag_id":"cmg22ta0f0002wotl4lsj3l9e","_id":"cmg22ta0n0006wotlb3v2gq0r"},{"post_id":"cmg22ta0g0003wotlb4vj1mx0","tag_id":"cmfs3zg9t0001gwtl3im58ztx","_id":"cmg22ta0p000awotl7stud06v"},{"post_id":"cmg22ta0g0003wotlb4vj1mx0","tag_id":"cmg22ta0m0005wotlcdf28zwz","_id":"cmg22ta0p000cwotl6m27f5yr"}],"Tag":[{"name":"txt","_id":"cmewhlst60001c0tlbeh77vu4"},{"name":"Java","_id":"cmf88q0470001c4tl9al0aoia"},{"name":"Python","_id":"cmf88qxn100000stl9kmugljk"},{"name":"算法","_id":"cmfs3zg9t0001gwtl3im58ztx"},{"name":"动态规划","_id":"cmfs3zg9v0003gwtlerc63m7y"},{"name":"递归","_id":"cmfs3zg9v0004gwtl2e5hci1f"},{"name":"algorithm","_id":"cmfwpg9v30001ugtl0kmj7ob4"},{"name":"二分法","_id":"cmfwpk0q60006ugtl8f8j76kn"},{"name":"Android","_id":"cmg22ta0f0002wotl4lsj3l9e"},{"name":"栈","_id":"cmg22ta0m0005wotlcdf28zwz"}]}}